---
title: "Simulations chromium"
author: "Izaskun Mallona at Robinsonlab"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
    code_download: true
    number_sections: true
    df_print: kable
    theme: lumen
    always_allow_html: yes
---

```
params:
    repeats_featurecounts_unique: ""
    repeats_only_unique: ""
    repeats_featurecounts_multi: ""
    repeats_only_multi: ""
    repeats_alevin_locus: ""
    repeats_alevin_no_decoy_locus: ""
    repeats_bowtie_unique: ""
    repeats_bowtie_multi: ""
    scte: ""
    shao_counts: ""
    shao_saf: ""
    shao_sam: ""
    truth: ""
    reps_gtf: ""
    nthreads: ""
```

Memory intensive, caution (see future memory options)

```{r, include = FALSE, eval = TRUE}
suppressPackageStartupMessages({
    library(Matrix)
    library(knitr)
    library(pheatmap)
    library(ggplot2)
    library(tximeta)
    library(SummarizedExperiment)
    library(forcats)    
    library(dplyr)
    library(reshape2)
    library(future.apply)
    library(data.table)
    library(GenomicRanges)
    library(scales)
})

## if (!requireNamespace("BiocManager", quietly = TRUE))
##     install.packages("BiocManager")

## install.packages(c('waldo',
##                    'rematch2',
##                    'testthat',
##                    'ggplot2'), dependencies = TRUE)
                 
## BiocManager::install(c("knitr","tximeta",
##                        "pheatmap",
##                        lib = "/home/imallona/R/bioc-312"), dependencies = TRUE)


```


```{r}
flavour_annot <- read.csv(text="id,multimapping,overlap
truth,truth,truth
repeats_alevin,multimapping,strict
repeats_alevin_no_decoy,multimapping,all
repeats_featurecounts_unique,unique,all
repeats_only_unique,unique,strict
repeats_featurecounts_multi,multimapping,all
repeats_only_multi,multimapping,strict
repeats_bowtie_unique,unique,all
scte,multimapping,all
shao,multimapping,all", header = TRUE)
```


```{r}
## palettes definition
pal_mapping <- setNames(c("#3fadaf","#cb5362","#6ea84e","#9d6cc1","#bb873c"),
                        c('truth', 'correct', 'multimapping', 'wrong', 'missing'))
```

```{r, include = FALSE, eval = TRUE}
BASE <- file.path('/home', 'imallona', 'repeats_sc')
```

```{r, include = FALSE, eval = TRUE}
opts_chunk$set(fig.width = 5,
               fig.height = 5,
               dev = 'png',
               cache = TRUE,
               echo = TRUE,
               include = TRUE,
               cache.lazy = FALSE,
               warning = TRUE,
               error = FALSE,
               message = FALSE)


options(bitmapType='cairo')
## getOption('bitmapType')

## data.table

```


```{r justfordebugging, include = FALSE, eval = TRUE}
params <- list(repeats_alevin_locus = "/home/imallona/repeats_sc/runs/sim_5k_pbmc_v3/alevin/repeats_per_locus/alevin/quants_mat.gz",
               repeats_alevin_no_decoy_locus = "/home/imallona/repeats_sc/runs/sim_5k_pbmc_v3/alevin/repeats_no_decoy_per_locus/alevin/quants_mat.gz",
               truth = "/home/imallona/repeats_sc/data/sim_5k_pbmc_v3/truth.tsv.gz",
               repeats_featurecounts_unique = "/home/imallona/repeats_sc/runs/sim_5k_pbmc_v3/count_repeats_loci_on_cellranger_standard/unique_reads/sim_5k_pbmc_v3_repeats.counts.gz",
               repeats_only_unique = '~/repeats_sc/runs/sim_5k_pbmc_v3/count_repeats_loci_on_cellranger_standard_not_overlapping_genes/unique_reads/sim_5k_pbmc_v3_repeats_not_overlapping_genes.counts.gz',
               repeats_featurecounts_multi = "/home/imallona/repeats_sc/runs/sim_5k_pbmc_v3/count_repeats_loci_on_cellranger_standard/multimappers/sim_5k_pbmc_v3_repeats.counts.gz",
               repeats_only_multi = '~/repeats_sc/runs/sim_5k_pbmc_v3/count_repeats_loci_on_cellranger_standard_not_overlapping_genes/multimappers/sim_5k_pbmc_v3_repeats_not_overlapping_genes.counts.gz',
               repeats_bowtie_multi = "/home/imallona/repeats_sc/runs/sim_5k_pbmc_v3/bowtie_repeatome/multimappers/by_locus_repeats.counts.gz",
               repeats_bowtie_unique = "/home/imallona/repeats_sc/runs/sim_5k_pbmc_v3/bowtie_repeatome/unique_reads/by_locus_repeats.counts.gz",
               scte = "/home/imallona/repeats_sc/runs/sim_5k_pbmc_v3/scTE/scTE.out.csv.gz",
               shao_counts = '~/repeats_sc/runs/sim_5k_pbmc_v3/zumis/sim_5k_zumis_count_dt.txt',
               shao_saf = '~/repeats_sc/annotation/shao/shao_GRCh38_te.saf',
               shao_sam = '~/repeats_sc/runs/sim_5k_pbmc_v3/zumis/sim_5k_zumis_featurecount.sam.txt',
               reps_gtf = '~/repeats_sc/annotation/GRCh38_rmsk_TE.gtf.gz',
               nthreads = 40)
```

```{r}
NTHREADS <- params$nthreads
setDTthreads(threads = params$nthreads)
```

```{r}
d <- list()
truth <- read.table(params$truth, header = TRUE)
truth <- cbind(truth, t(sapply(strsplit(truth$locus, ';'), function(x) return(x))))
colnames(truth)[5:9] <- c('name', 'id', 'family', 'class', 'locus')
```

```{r}
d$repeats_alevin <- tximeta::tximeta(
     coldata = data.frame(
         names = "genes",
         files = params$repeats_alevin_locus,
         stringsAsFactors = FALSE,
         skipMeta = TRUE,
         skipSeqinfo = TRUE
     ), type = "alevin")

d$repeats_alevin <- assays(d$repeats_alevin)$counts
```

```{r}
d$repeats_alevin_no_decoy <- tximeta::tximeta(
     coldata = data.frame(
         names = "genes",
         files = params$repeats_alevin_no_decoy_locus,
         stringsAsFactors = FALSE,
         skipMeta = TRUE,
         skipSeqinfo = TRUE
     ), type = "alevin")

d$repeats_alevin_no_decoy <- assays(d$repeats_alevin_no_decoy)$counts
```


```{r}
read_featurecounts <- function(fn){
    ## without multimappers
    tmp <- data.table::fread(fn,
                             sep = '\t', header = TRUE,
                             drop = c('Chr', 'Start', 'End', 'Strand', 'Length'))
    gene_ids <- tmp$Geneid ## here

    colnames(tmp) <- gsub(".*:([A-Z]+)-1.*.bam","\\1", colnames(tmp))
    ## tmp <- tmp[,7:ncol(tmp)]
    tmp  <- as(object = as.matrix(tmp[,-'Geneid']), Class = "dgCMatrix")
    rownames(tmp) <- gene_ids


    return(tmp)
}
```

```{r}
featurecounts_runs <- c('repeats_featurecounts_unique',
                        'repeats_only_unique',
                        'repeats_featurecounts_multi',
                        'repeats_only_multi',
                        ## 'repeats_bowtie_multi',
                        'repeats_bowtie_unique')
```


```{r}
for (item in featurecounts_runs) {
    d[[item]] <- read_featurecounts(params[[item]])
    ## colnames(d[[item]]) <-  gsub(".*:([A-Z]+)-1.*.bam","\\1", colnames(d[[item]]))
}
```


Read scTE

```{r scte}
tmp <- data.table::fread(params$scte,
                         sep = ',',
                         header = TRUE)

repnames <- setdiff(colnames(tmp), 'barcodes')
barcodes <- tmp$barcodes

tmp <- as.data.frame(data.table::transpose(tmp[,-'barcodes']))

colnames(tmp) <- barcodes

rownames(tmp) <- repnames
print(tmp[1:3,1:3])

## filter out genes here maybe?

d$scte <- tmp
rm(tmp)

```

```{r}
# read shao

d$shao <- list()
d$shao$counts <- fread(params$shao_counts)
d$shao$saf <- fread(params$shao_saf)
d$shao$sam <- fread(params$shao_sam)
## d$shao <- merge(d$shao$counts, d$shao$saf, by.x= 'feature', by.y = 'GeneID', all = TRUE)

```

```{r}

truth$chr <- gsub(".*::(.+):([0-9]+)-([0-9]+)", "\\1", truth$locus)
truth$start <- gsub("(.+):([0-9]+)-([0-9]+)", "\\2", truth$locus)
truth$end <- gsub("(.+):([0-9]+)-([0-9]+)", "\\3", truth$locus)
```

```{r, eval = FALSE}
saveRDS(file = 'd.rds', object = d)
```


Assign Shao's `EM_distri`buted counts to the original simulated reads according to their overlap


```{r}
## we consider a te_x identifier overlaps with a real simulated read if
##  cell barcodes and coordinates match and overlap
does_overlap <- function(x) {
    return (x$Chr == paste0('chr', x$sim_chr) &
            x$sim_start < x$End &
            x$sim_end >= x$Start)
}
```

We use a SAF that does contain all TEs, regardless of whether overlapping RefGenes

```{r}
d$shao$saf <- as.data.frame(d$shao$saf)
head(d$shao$saf)

d$shao$counts <- as.data.frame(na.omit(d$shao$counts))
head(d$shao$counts)
```

We also use the SAM file from the mapping to be able to get the original read information, which was encoded at the read name level.

```{r}
d$shao$sam <- as.data.frame(d$shao$sam)
head(d$shao$sam)
```

```{r}
d$shao$sam$sim_locus <-  gsub("(.+);(.+);(.+);(.+)::.*", "\\2", d$shao$sam$V1)
d$shao$sam$sim_chr <-  gsub("(.*)_([0-9XY]+)_([0-9]+)_([0-9]+)_([+-]+)", "\\2",
                            d$shao$sam$sim_locus)
d$shao$sam$sim_start <-  as.numeric(gsub("(.*)_([0-9XY]+)_([0-9]+)_([0-9]+)_([+-]+)", "\\3",
                              d$shao$sam$sim_locus))
d$shao$sam$sim_end <-  as.numeric(gsub("(.*)_([0-9XY]+)_([0-9]+)_([0-9]+)_([+-]+)", "\\4",
                            d$shao$sam$sim_locus))
d$shao$sam$sim_family <-  gsub("(.+);(.+);(.+);(.+)::.*", "\\3", d$shao$sam$V1)
d$shao$sam$sim_class <-  gsub("(.+);(.+);(.+);(.+);::.*", "\\4", d$shao$sam$V1)
d$shao$sam$sim_name <- gsub("(.*)_([0-9XY]+)_([0-9]+)_([0-9]+)_([+-]+)", "\\1",
                            d$shao$sam$sim_locus)


```


For those TE ids which were counted, and hence assigned to a cell barcode, we retrieve the SAF coordinates

```{r}
d$shao$merged <- merge(d$shao$counts, d$shao$saf, by.x = 'feature', by.y = 'GeneID', all.x = TRUE)
head(d$shao$merged)
```

Then, merge with the SAM file to assign TE_x identifers to CBs, but also to the original simulated read name/origin

```{r}
d$shao$merged <- merge(d$shao$merged, d$shao$sam, by.x = 'feature', by.y = 'V4', all.x = TRUE)
d$shao$merged <- d$shao$merged[!is.na(d$shao$merged$RG),]
head(d$shao$merged)

```

Some of the ZUMI's RGs were not simulated - we'll remove them from the analysis.

Then, we check whether the te_x feature identifier's coordinates overlap the simulated reads' coordinates

```{r}
d$shao$merged$overlaps <- does_overlap(d$shao$merged)
table(d$shao$merged$V2 == d$shao$merged$RG)
d$shao$merged <- d$shao$merged[d$shao$merged$V2 == d$shao$merged$RG,]
table(d$shao$merged$overlaps)
## d$shao <- as.data.frame(d$shao$merged)
```


# Locus level 


```{r, eval = FALSE}
## heavy downsampling

d <- lapply(d, function(x) return(head(x, 1e4)[,1:50]))

## scte does not provide outputs at the locus level
sapply(d, dim)
sapply(d, class)
d$scte[1:3,1:3]

sapply(d, function(x) head(colnames(x)))

```

Proportion of correctly mapped, incorrectly mapped, unaligned etc, using dgCmatrices.

```{r}
props <- list()
```

We define: 
- correct, unique mapping, simulated read maps to the simulated origin
- multi, multimapping, regardless of where does it map
- wrong, the reported mapping coordinates were not simulated (for that cell)
- missing, the simulated reads are not present neither as correct or multimapping

```{r}
## 130 GB
options(future.globals.maxSize = 130 * 1024^3)

plan(multiprocess, workers = NTHREADS)

fc  <- c(featurecounts_runs, grep('alevin', names(d), value = TRUE))

props2 <- future_lapply(fc, function(x) {
    res <- list()
    for (cell in unique(truth$cell)) {

        if (cell %in% colnames(d[[x]])) {
            true <- truth[truth$cell == cell, 'id']

            tmp <- d[[x]][,cell]
            observed <- tmp[tmp > 0]
            ## names(observed) <- rownames(tmp)[tmp>0]

            ## among these, some are observed 'fractionally', if multimappers are allowed
            correct <- observed[names(observed) %in% true] 

            ## under- or overestimation
            multi <- observed[observed != 1]

            missing <- setdiff(true, names(observed))
            wrong <- setdiff(names(observed), true)

            stopifnot(all(missing %in% true))

            res[[cell]] <- setNames(c(cell,
                                      length(true), length(correct), length(multi),
                                      length(missing),
                                      length(wrong)),
                                    c('cell', 'true', 'correct', 'multi', 'missing', 'wrong'))
        }
        else {
            res[[cell]] <- setNames( c(cell, length(true), 0, 0, length(true), 0),
                                    c('cell', 'true', 'correct', 'multi', 'missing', 'wrong'))
        }
    }

    res <- do.call(rbind.data.frame, res)
    colnames(res) <-  c('cell', 'true', 'correct', 'multi', 'missing', 'wrong')
    res$flavour <- x
    return(res)
})


## res <- list()
## for (cell in unique(truth$cell)) {

##     if (cell %in% colnames(d$repeats_alevin)) {
##         true <- truth[truth$cell == cell, 'id']

##         tmp <- d$repeats_alevin[,cell]
##         observed <- tmp[tmp > 0]

##         ## among these, some are observed 'fractionally'
##         correct <- observed[observed == 1]

##         ## under- or overestimation
##         multi <- observed[observed != 1]

##         missing <- setdiff(true, names(observed))
##         wrong <- setdiff(names(observed), true)

##         stopifnot(all(missing %in% true))

##         res[[cell]] <- setNames(c(cell,
##                                   length(true), length(correct), length(multi),
##                                   length(missing),
##                                   length(wrong)),
##                                 c('cell', 'true', 'correct', 'multi', 'missing', 'wrong'))
##     }
##     else {
##         res[[cell]] <- setNames( c(cell, length(true), 0, 0, length(true), 0),
##                                 c('cell', 'true', 'correct', 'multi', 'missing', 'wrong'))
##     }
##     ## stopifnot(as.numeric(res[[cell]]['true']) == (as.numeric(res[[cell]]['correct']) +
##     ##                                               as.numeric(res[[cell]]['multi']) +
##     ##                                               as.numeric(res[[cell]]['missing']) +
##     ##                                               as.numeric(res[[cell]]['wrong'])))
## }

## res <- do.call(rbind.data.frame, res)
## colnames(res) <-  c('cell', 'true', 'correct', 'multi', 'missing', 'wrong')
## props[['repeats_alevin']] <- res
## props[['repeats_alevin']]$flavour <- 'repeats_alevin'


```


<!-- For feature counts -->

<!-- ```{r} -->
<!-- for (fc in c('repeats_featurecounts_unique', -->
<!--                'repeats_only_unique', -->
<!--                'repeats_featurecounts_multi', -->
<!--                'repeats_only_multi')) { -->
<!--     res <- list() -->
<!--     for (cell in unique(truth$cell)) { -->

<!--         if (cell %in% colnames(d[[fc]])) { -->
<!--             true <- truth[truth$cell == cell, 'id'] -->

<!--             observed <- rownames(d[[fc]])[d[[fc]][,cell] > 0] -->

<!--             ## among these, some are observed 'fractionally' -->
<!--             correct <- observed[d[[fc]][observed,cell] == 1] -->

<!--             ## under- or overestimation -->
<!--             multi <- observed[d[[fc]][observed,cell] != 1] -->

<!--             missing <- setdiff(true, observed) -->
<!--             wrong <- setdiff(observed, true) -->

<!--             res[[cell]] <- setNames(c(cell, -->
<!--                                       length(true), length(correct), length(multi), -->
<!--                                       length(missing), -->
<!--                                       length(wrong)), -->
<!--                                     c('cell', 'true', 'correct', 'multi', 'missing', 'wrong')) -->
<!--         } -->
<!--         else { -->
<!--             res[[cell]] <- setNames( c(cell, length(true), 0, 0, length(true), 0), -->
<!--                                     c('cell', 'true', 'correct', 'multi', 'missing', 'wrong')) -->
<!--         } -->
<!--     } -->

<!--     res <- do.call(rbind.data.frame, res) -->
<!--     colnames(res) <-  c('cell', 'true', 'correct', 'multi', 'missing', 'wrong') -->
<!--     props[[fc]] <- res -->
<!--     props[[fc]]$flavour <- fc -->
<!-- } -->
<!-- ``` -->




Shao: now we get the proportions of correct/multimapping etc for the truth. Mind that the sum of multimap, wrong, missing and observed might not match the simulated, and that we added an extra step of overlapping the reported TE identifier's coordinates with the simulated ones.

Here:

- correct, unique mappings that also overlap the simulated read
- multi, multimapping, regardless of whether the mapping site is ok or not
- wrong, the reported coordinates do not overlap any of the simulated repeats for that cell
- missing, the simulated reads are not present neither as correct or multimapping



<!-- ```{r} -->
<!-- res <- list() -->
<!-- for (cell in unique(truth$cell)) { -->

<!--     if (cell %in% d$shao$counts$RG) { -->
<!--         true <- truth[truth$cell == cell, 'id'] -->

<!--         ## observed <- na.omit(d$shao$merged[d$shao$merged$RG == cell,]) -->
<!--         obs_counts <- d$shao$counts[d$shao$counts$RG == cell,] -->

<!--         ## test to do the merges locally start -->
<!--         foo <- merge(obs_counts, d$shao$saf, by.x = 'feature', by.y = 'GeneID', all.x = TRUE) -->
<!--         observed <-  na.omit(merge(foo, d$shao$sam, by.x = 'feature', by.y = 'V4', all.x = TRUE)) -->
<!--         observed$overlaps <- does_overlap(observed) -->

<!--         ## we disambiguate the tes with two potential origins to one, prioritizing the one that -->
<!--         ##   does overlap -->
<!--         observed <- observed[order(observed$feature, observed$overlap, decreasing = TRUE),] -->
<!--         prev <- 'empty' -->
<!--         observed$keep <- TRUE -->
<!--         for (i in 1:nrow(observed)) { -->
<!--             ## cat(prev, curr, i, '\n') -->
<!--             curr <- observed$feature[i] -->
<!--             if (curr == prev) { -->
<!--                 observed$keep[i] <- FALSE -->
<!--             } -->
<!--             prev <- curr  -->
<!--         } -->

<!--         observed <- observed[observed$keep,] -->
        
<!--         ## test end -->

<!--         ## with all the merging, I introduce some dupes- -->
<!--         ##  stop procedure if those exceed 2% of the original records -->
<!--         ## stopifnot(abs(nrow(observed) - nrow(obs_counts)) < nrow(obs_counts)*0.02) -->
<!--         ## among these, some te_x overlap with the simulated reads -->
<!--         correct <- observed[observed$overlaps & -->
<!--                             !duplicated(observed$sim_locus) & -->
<!--                             observed$EM_distri == 1 & -->
<!--                             observed$sim_locus %in% true, 'sim_locus'] -->

<!--         ## multimapping -->
<!--         ## multi <- unique(observed[observed$EM_distri != 1 , 'sim_locus']) -->
<!--         ## simulated reads perspective -->
<!--         multi <- observed[duplicated(observed$sim_locus) | -->
<!--                         observed$EM_distri != 1, 'sim_locus'] -->

<!--         wrong <- unique(observed[!observed$overlaps, -->
<!--                                    'sim_locus' ]) -->

<!--         missing <- setdiff(true, unique(observed$sim_locus)) -->
<!--         ## missing <- setdiff(true, unique(c(correct, multi))) -->

<!--         res[[cell]] <- setNames(c(cell, -->
<!--                                   length(true), length(correct), length(multi), -->
<!--                                   length(missing), -->
<!--                                   length(wrong)), -->
<!--                                 c('cell', 'true', 'correct', 'multi', 'missing', 'wrong')) -->
<!--     } -->
<!--     else { -->
<!--         res[[cell]] <- setNames( c(cell, length(true), 0, 0, length(true), 0), -->
<!--                                 c('cell', 'true', 'correct', 'multi', 'missing', 'wrong')) -->
<!--     } -->
<!--     ## stopifnot(as.numeric(res[[cell]]['true']) == (as.numeric(res[[cell]]['correct']) + -->
<!--     ##                                            as.numeric(res[[cell]]['multi']) + -->
<!--     ##                                            as.numeric(res[[cell]]['missing']) + -->
<!--     ##                                            as.numeric(res[[cell]]['wrong']))) -->
<!-- } -->

<!-- res <- do.call(rbind.data.frame, res) -->
<!-- colnames(res) <-  c('cell', 'true', 'correct', 'multi', 'missing', 'wrong') -->
<!-- props[['shao']] <- res -->
<!-- props[['shao']]$flavour <- 'shao' -->

<!-- ``` -->



```{r}
res <- list()
for (cell in unique(truth$cell)) {

    if (cell %in% d$shao$counts$RG) {
        true <- truth[truth$cell == cell, 'id']

        ## observed <- na.omit(d$shao$merged[d$shao$merged$RG == cell,])
        obs_counts <- d$shao$counts[d$shao$counts$RG == cell,]

        ## test to do the merges locally start
        foo <- merge(obs_counts, d$shao$saf, by.x = 'feature', by.y = 'GeneID', all.x = TRUE)
        observed <-  na.omit(merge(foo, d$shao$sam, by.x = 'feature', by.y = 'V4', all.x = TRUE))
        observed$overlaps <- does_overlap(observed)

        ## ## we disambiguate the tes with two potential origins to one, prioritizing the one that
        ## ##   does overlap
        ## observed <- observed[order(observed$feature, observed$overlap, decreasing = TRUE),]
        ## prev <- 'empty'
        ## observed$keep <- TRUE
        ## for (i in 1:nrow(observed)) {
        ##     ## cat(prev, curr, i, '\n')
        ##     curr <- observed$feature[i]
        ##     if (curr == prev) {
        ##         observed$keep[i] <- FALSE
        ##     }
        ##     prev <- curr 
        ## }

        ## observed <- observed[observed$keep,]
        
        ## test end

        ## with all the merging, I introduce some dupes-
        ##  stop procedure if those exceed 2% of the original records
        ## stopifnot(abs(nrow(observed) - nrow(obs_counts)) < nrow(obs_counts)*0.02)
        ## among these, some te_x overlap with the simulated reads
        correct <- observed[observed$overlaps &
                            !duplicated(observed$sim_locus) &
                            observed$EM_distri == 1 &
                            observed$sim_locus %in% true, 'sim_locus']

        ## multimapping
        ## multi <- unique(observed[observed$EM_distri != 1 , 'sim_locus'])
        ## simulated reads perspective
        multi <- observed[duplicated(observed$sim_locus) |
                        observed$EM_distri != 1, 'sim_locus']

        wrong <- unique(observed[!observed$overlaps,
                                   'sim_locus' ])

        missing <- setdiff(true, unique(observed$sim_locus))
        ## missing <- setdiff(true, unique(c(correct, multi)))

        res[[cell]] <- setNames(c(cell,
                                  length(true), length(correct), length(multi),
                                  length(missing),
                                  length(wrong)),
                                c('cell', 'true', 'correct', 'multi', 'missing', 'wrong'))
    }
    else {
        res[[cell]] <- setNames( c(cell, length(true), 0, 0, length(true), 0),
                                c('cell', 'true', 'correct', 'multi', 'missing', 'wrong'))
    }
    ## stopifnot(as.numeric(res[[cell]]['true']) == (as.numeric(res[[cell]]['correct']) +
    ##                                            as.numeric(res[[cell]]['multi']) +
    ##                                            as.numeric(res[[cell]]['missing']) +
    ##                                            as.numeric(res[[cell]]['wrong'])))
}

res <- do.call(rbind.data.frame, res)
colnames(res) <-  c('cell', 'true', 'correct', 'multi', 'missing', 'wrong')
props[['shao']] <- res
props[['shao']]$flavour <- 'shao'

```


```{r}
sapply(d, function(x) head(colnames(x)))
sapply(props2, function(x) head(colnames(x)))
```


```{r}
saveRDS(file = 'props.rds', object = c(props, props2))

```


```{r}
fd <- do.call(rbind.data.frame, c(props, props2))
tail(fd)
for (col in setdiff(colnames(fd), c('flavour', 'cell'))) {
    fd[,col] <- as.numeric(fd[,col])
}
```

```{r}
## stolen from https://stackoverflow.com/questions/53241804/error-bars-incorrectly-positioned-in-a-stacked-bar-graph-r

fd <- reshape2::melt(fd,  id.vars = c('cell', 'flavour'))
fd$value <- as.numeric(fd$value)
fd <- fd[fd$variable != 'true',]
## discarded multimapping
fd$variable <- as.character(fd$variable)
fd$variable[fd$variable == 'multi'] <- 'multimapping'

fd$variable <- factor(fd$variable, levels = rev(c('correct', 'multimapping', 'missing', 'wrong')))

## group_by(fd, flavour, variable) %>%
##     summarize(mean = mean(value),
##               sd = sd(value),
##               lower = mean(value) - sd(value),
##               upper = mean(value) + sd(value)) %>%
##     arrange(flavour) %>%
##     group_by(flavour) %>%

##     ungroup() %>%
##     ggplot(aes(x = flavour, y = mean, fill = variable),
##            xLabels = NA) +
##     geom_bar(stat="identity") +
##     geom_errorbar(aes(ymin = lower, ymax = upper),
##                                          width = .2, col = "red") +
##     theme_bw() + scale_x_discrete(limits = unique(fd$flavour)) +
##     xlab("") +
##     ylab ("") +
##     scale_fill_grey() +
##     theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```

```{r}
fd2 <- as.data.frame(group_by(fd, flavour, variable) %>%
              summarize(mean = mean(value),
                        sd = sd(value),
                        lower = mean(value) - sd(value),
                        upper = mean(value) + sd(value)) %>%
              arrange(flavour) %>%
              group_by(flavour)) 

fd2$variable <- factor(fd2$variable, levels = c('correct', 'multimapping', 'wrong', 'missing'))

# fd2 <- fd2[order(fd2$flavour, fd2$variable),]

## ggplot(fd2, aes(x = flavour, y = mean, fill = variable),
##            xLabels = NA) +
##     geom_bar(stat="identity") +
##     geom_errorbar(aes(ymin = lower, ymax = upper),
##                                          width = .2, col = "red") +
##     theme_bw() + scale_x_discrete(limits = unique(fd$flavour)) +
##     xlab("") +
##     ylab ("") +
##     scale_fill_grey() +
##     theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

```


```{r}
ggplot(fd2, aes(x=flavour, weight=mean, ymin=lower, ymax=upper, fill=variable)) +
    geom_bar      (position=position_dodge(), aes(y=mean), stat="identity") +
    geom_errorbar (position=position_dodge(width=0.9), colour="black", width = 0.2) +
    theme_bw() +
    scale_x_discrete(limits = unique(fd2$flavour)) +
    ## scale_fill_grey(name = 'mapping\ncategory') +
    scale_fill_manual("mapping\ncategory", values = pal_mapping) +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + 
    xlab('strategy') +
    ylab('alignments per cell (counts)')
```

```{r}
ggplot(fd2, aes(x=variable, weight=mean, ymin=lower, ymax=upper, fill=flavour)) +
    geom_bar      (position=position_dodge(), aes(y=mean), stat="identity") +
    geom_errorbar (position=position_dodge(width=0.9), colour="black", width = 0.2) +
    theme_bw() +
    scale_x_discrete(limits = unique(fd2$variable)) +
    scale_fill_grey(name = 'mapping\ncategory') +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
    xlab('strategy') +
    ylab('alignments per cell (counts)')

```

Maybe the same with percentages of the simulated reads?


```{r}
fd <- do.call(rbind.data.frame, c(props, props2))

for (item in c('correct', 'multi', 'missing', 'wrong'))
    fd[,item] <- as.numeric(fd[,item])

pt <- prop.table(as.matrix(fd[,c('correct', 'multi', 'missing', 'wrong')]),1 )

fd <- data.frame(cell = fd$cell,
                 flavour = fd$flavour,
                 pt)

fd <- reshape2::melt(fd,  id.vars = c('cell', 'flavour'))
fd$value <- as.numeric(fd$value)

## discarded multimapping
fd$variable <- as.character(fd$variable)
fd$variable[fd$variable == 'multi'] <- 'multimapping'

fd$variable <- factor(fd$variable, levels = rev(c('correct', 'multimapping', 'missing', 'wrong')))



fd2 <- as.data.frame(group_by(fd, flavour, variable) %>%
              summarize(mean = mean(value),
                        sd = sd(value),
                        lower = mean(value) - sd(value),
                        upper = mean(value) + sd(value)) %>%
              arrange(flavour) %>%
              group_by(flavour)) 

fd2$variable <- factor(fd2$variable, levels = c('correct', 'multimapping', 'wrong', 'missing'))

```


```{r}

ggplot(data = fd2,
       mapping = aes_string(x = "variable", 
                            y = "flavour")) +
    geom_point(mapping = aes_string(size = "mean"))

```


```{r}
ggplot(fd2, aes(x=flavour, weight=mean, ymin=lower, ymax=upper, fill=variable)) +
    geom_bar      (position=position_dodge(), aes(y=mean), stat="identity") +
    geom_errorbar (position=position_dodge(width=0.9), colour="black", width = 0.2) +
    theme_bw() +
    scale_x_discrete(limits = unique(fd$flavour)) +
    ## scale_fill_grey(name = 'mapping\ncategory') +
    scale_fill_manual("mapping\ncategory", values = pal_mapping) + 
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
    xlab('strategy') +
    ylab('alignments per cell (proportion)')
```


```{r}
ggplot(fd2, aes(x=variable, weight=mean, ymin=lower, ymax=upper, fill=flavour)) +
    geom_bar      (position=position_dodge(), aes(y=mean), stat="identity") +
    geom_errorbar (position=position_dodge(width=0.9), colour="black", width = 0.2) +
    theme_bw() +
    scale_x_discrete(limits = unique(fd$variable)) +
    scale_fill_grey(name = 'mapping\ncategory') +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
    xlab('strategy') +
    ylab('alignments per cell (proportion)')


```


From incorrectly mapped, get those that at least mach the repName, repFamily, or repClass

# Not averages, but rather total amounts

```{r}
fd <- do.call(rbind.data.frame, c(props, props2))

## fd <- reshape2::melt(fd,  id.vars = c('cell', 'flavour'))
## fd$value <- as.numeric(fd$value)

grouped <- aggregate(list(correct = as.numeric(fd$correct),
                          truth = as.numeric(fd$true),
                          wrong = as.numeric(fd$wrong),
                          multimapping = as.numeric(fd$multi),
                          missing = as.numeric(fd$missing)),
                     by = list(fd$flavour), sum)

grouped <- reshape2::melt(grouped, id.vars = 'Group.1') 
grouped$variable <- factor(grouped$variable, levels = c('truth', 'correct',
                                                        'multimapping', 'missing', 'wrong'))

levels(grouped$variable)
grouped %>% ggplot(aes(x=Group.1, y=value, fill =variable)) +
    geom_bar      (position=position_dodge(), stat="identity") +
    theme_bw() +
    scale_x_discrete(limits = unique(fd$flavour)) +
    scale_fill_manual("mapping\ncategory", values = pal_mapping) + 
    ## scale_fill_grey(name = 'mapping\ncategory') +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
    xlab('strategy') +
    ylab('alignments (number of)')


```

# Grouping by repname etc, to be able to include scTE

Proportion of families?

```{r}

aggs <- list()
for (item in c('name', 'family', 'class')) {
    tryCatch({
        flavour <- 'truth'
        
        ## truth contains a dictionary
        ## we weight half counts for multimappers (truth doesn't have them, but other tools might)
        weighted <- as.data.frame(table(truth[,item], truth$count))
        head(weighted)
        weighted$weight <- as.numeric(as.character(weighted$Var2)) * weighted$Freq
        
        weighted <- aggregate(weighted$weight, by = list(weighted$Var1), sum)
        colnames(weighted) <- c(item, 'truth')
        aggs[[item]] <- list(truth = weighted)

        cat('done truth ', item, '\n\n')

        for (flavour in rev(names(d))) {
            if (flavour == 'scte') {
                d[[flavour]][] <- lapply(d[[flavour]], function(x) {
                    if(is.factor(x)) as.numeric(as.character(x))
                    else if (is.character(x)) as.numeric(x)
                    else x
                })
                
                summed <- rowSums(d[[flavour]])
                summed <- data.frame(name = names(summed),
                                     sum = summed)

                annot <- truth[,c('name', item)]
                annot <- annot[!duplicated(annot),]

                summed <- merge(summed,
                                annot,
                                by.x = 'name',
                                by.y = 'name')

                weighted <- aggregate(summed$sum, by = list(summed[,item]), sum)
                colnames(weighted) <- c(item, flavour)
                aggs[[item]][[flavour]] <- weighted
            }
            else if (flavour == 'shao') {
                summed <- aggregate(d$shao$merged$EM_distri,
                                    by=list(name = d$shao$merged$sim_name), FUN = sum)
                
                colnames(summed) <- c('name', 'sum')

                annot <- truth[,c('name', item)]
                annot <- annot[!duplicated(annot),]
                
                summed <- merge(summed, annot,
                                by.x = 'name',
                                by.y = 'name')
                
                weighted <- aggregate(summed$sum, by = list(summed[,item]), sum)
                colnames(weighted) <- c(item, flavour)
                aggs[[item]][[flavour]] <- weighted        
                
            }
            else {
                summed <- rowSums(d[[flavour]])
                summed <- data.frame(id = names(summed),
                                     sum = summed)
                summed <- merge(summed, truth[,c('id', item)],
                                by.x = 'id',
                                by.y = 'id')
                
                weighted <- aggregate(summed$sum, by = list(summed[,item]), sum)
                colnames(weighted) <- c(item, flavour)
                aggs[[item]][[flavour]] <- weighted            
            }
            cat('done ', item, flavour, '\n\n')
            
        }
    }, error = function(x) cat(item, '\n',
                               ## 'flavour', flavour, '\n',
                               ## 'error', str(x), '\n',
                               ## 'summed', str(summed), '\n',
                               ## 'weighted', str(weighted),
                               str(x),
                               '\n\n'))
}
```


```{r}

```

<!-- ``` -->

<!-- ```{r} -->
<!-- tail(d$shao$sam) -->

<!-- ## all(d$shao$sam$family == d$shao$sam$class) -->
<!-- table(d$shao$sam$mapped_name == d$shao$sam$sim_name) -->

<!-- tmp <- merge(d$shao$counts, as.data.frame(d$shao$sam), by.x = 'feature', by.y = 'V4') -->

<!-- ``` -->

<!-- Removing Shao's te identifiers with multiple assignments. Skipped, or the total mapping is very low. -->

<!-- Getting the aggregated counts for Shao's -->

<!-- ```{r} -->

<!-- d$shao <- merge(d$shao$counts, overlap, by.x = 'feature', by.y='feature', all.x = TRUE) -->

<!-- d$shao$name <- gsub("(.+);(.+);(.+);(.+)::.*", "\\1", d$shao$locus) -->
<!-- d$shao$family <- gsub("(.+);(.+);(.+);(.+)::.*", "\\3", d$shao$locus) -->
<!-- d$shao$class <- gsub("(.+);(.+);(.+);(.+);::.*", "\\4", d$shao$locus) -->

<!-- flavour <- 'shao_EM' -->
<!-- d$shao <- as.data.frame(d$shao) -->

<!-- for (item in c('name', 'family', 'class')) { -->
<!--     weighted <- aggregate(d$shao$EM_distri, by = list(d$shao[,item]), -->
<!--                           function(x) sum(na.omit(x))) -->
    
    
<!--     colnames(weighted) <- c(item, flavour) -->
<!--     aggs[[item]][[flavour]] <- weighted        -->
<!-- } -->

<!-- ``` -->


<!-- ```{r} -->
<!-- ## head(d$shao$merged) -->
<!-- ## head(unique(truth$cell)) -->
<!-- ## head(unique(d$shao$merged$RG)) -->
<!-- ## intersect(unique(truth$cell), unique(d$shao$merged$RG)) -->
<!-- ## intersect(unique(truth$umi), unique(d$shao$merged$RG)) -->
<!-- for (RG in unique(truth$cell)) { -->
<!--     ## subsetting the the current cell -->
<!--     curr <- d$shao$merged[d$shao$merged$RG == RG,] -->
<!-- } -->
<!-- ``` -->


by Class

```{r}
tmp <- data.frame(class = aggs$class$truth$class)
for (flavour in aggs$class) {
    tmp <- merge(tmp, flavour, by = 'class', all.x = TRUE)
}

tmp <- melt(tmp,  id.vars = c('class'))
colnames(tmp) <- c('class', 'flavour', 'counts')

## remove the classes that have a '?' on them
tmp <- tmp[grep('?', tmp$class, invert = TRUE, fixed = TRUE),]
```


```{r}
## sort classes by number of members in truth
sorted_classes <- rev(tmp[tmp$flavour == 'truth', ][order(tmp[tmp$flavour == 'truth', 'counts'], decreasing = TRUE), 'class'])

tmp$class <- factor(as.character(tmp$class), levels = sorted_classes)

## tmp$multimap <- NA
## tmp[tmp$flavour %in% c('repeats_alevin', 'repeats_alevin_no_decoy',
##                        'repeats_featurecounts_multi', 'repeats_only_multi',
##                        'scte')] <- 'multimappers'


## tmp <- tmp[order(tmp$class, tmp$counts, decreasing = TRUE),]
## tmp$class <- as.factor(tmp$class)

```

<!-- palette from https://medialab.github.io/iwanthue/ -->
```{r}
class_pal <- c("#81722e",
              "#5ab74b",
              "#7561cf",
              "#a2b046",
              "#647fc6",
              "#d59a45",
              "#45aecf",
              "#cf5330",
              "#5cbf93",
              "#d63d65",
              "#478146",
              "#c089d2",
              "#c452bb",
              "#a0497b",
              "#b96750",
              "#e2809f")
```

```{r}
tmp <- merge(tmp, flavour_annot, by.x = 'flavour', by.y = 'id', all.x = TRUE)
tmp$overlap <- factor(tmp$overlap, levels = c('truth', 'all', 'strict'))
tmp$multimapping <- factor(tmp$multimapping, levels = c('truth', 'unique', 'multimapping'))
```

```{r}

ggplot(tmp, aes(fill = class, y = counts, x = flavour)) + 
    geom_bar(position="stack", stat="identity", width = 1, colour = 'black')  +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
    scale_fill_manual(values = class_pal) +
    facet_grid(~overlap*multimapping, scales = "free", space = "free") 
```




```{r}

## logp3_trans <- trans_new(
##   name = "logp",
##   trans = function(x) log(x + 3),
##   inverse = function(x) exp(x) - 3,
##   breaks = log_breaks()
## )

ggplot(tmp, aes(fill = class, y = counts, x = flavour)) + 
    geom_bar(position="stack", stat="identity", colour = 'black')  +
    scale_y_continuous(trans = 'sqrt', labels = label_scientific(digits = 3)) +
    ## coord_trans(y='log10') +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
    scale_fill_manual(values = class_pal) +
    facet_grid(~overlap*multimapping, scales = "free", space = "free") 
```


```{r}
ggplot(data = tmp,
       mapping = aes_string(y = "class", 
                            x = "flavour")) +
    geom_point(mapping = aes_string(size = "counts",
                                    color = "counts")) +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

```



by family, only the top 10 families in the truth are shown


```{r}
family_pal <-  c("#7ab743",
                 "#7665ca",
                 "#c59643",
                 "#c25fbc",
                 "#51b48c",
                 "#d1406e",
                 "#6a803a",
                 "#6890ce",
                 "#c75a3a",
                 "#c16e8b")
```



```{r}
tmp <- data.frame(family = aggs$family$truth$family)
for (flavour in aggs$family) {
    tmp <- merge(tmp, flavour, by = 'family', all.x = TRUE)
}

selected <- head(tmp[order(tmp$truth, decreasing = TRUE),'family'], 10)

tmp <- reshape2::melt(tmp,  id.vars = c('family'))
colnames(tmp) <- c('family', 'flavour', 'counts')

tmp <- tmp[tmp$family %in% selected,]
tmp$family <- as.character(tmp$family)
```

```{r}
tmp <- merge(tmp, flavour_annot, by.x = 'flavour', by.y = 'id', all.x = TRUE)
tmp$overlap <- factor(tmp$overlap, levels = c('truth', 'all', 'strict'))
tmp$multimapping <- factor(tmp$multimapping, levels = c('truth', 'unique', 'multimapping'))
```

```{r}
ggplot(tmp, aes(fill = family, y = counts, x = flavour)) + 
    geom_bar(position="stack", stat="identity", width = 1, colour = 'black')  +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
    scale_fill_manual(values = family_pal) +
    facet_grid(~overlap*multimapping, scales = "free", space = "free") 
    
```



by name, only the top 10 names are shown


```{r}
tmp <- data.frame(name = aggs$name$truth$name)
for (flavour in aggs$name) {
    tmp <- merge(tmp, flavour, by = 'name', all.x = TRUE)
}

selected <- head(tmp[order(tmp$truth, decreasing = TRUE),'name'], 10)

tmp <- melt(tmp,  id.vars = c('name'))
colnames(tmp) <- c('name', 'flavour', 'counts')

tmp <- tmp[tmp$name %in% selected,]
```

```{r}
names_pal <- c("#c95171",
               "#74b44a",
               "#c852b5",
               "#4baf90",
               "#7965ce",
               "#cc9d46",
               "#5d8ece",
               "#c85e3c",
               "#b378b4",
               "#707a35")
```

```{r}

tmp <- merge(tmp, flavour_annot, by.x = 'flavour', by.y = 'id', all.x = TRUE)
tmp$overlap <- factor(tmp$overlap, levels = c('truth', 'all', 'strict'))
tmp$multimapping <- factor(tmp$multimapping, levels = c('truth', 'unique', 'multimapping'))
```

```{r}
ggplot(tmp, aes(fill = name, y = counts, x = flavour)) + 
    geom_bar(position="stack", stat="identity", width = 1, colour = 'black')  +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
    scale_fill_manual(values = names_pal) +
    facet_grid(~overlap*multimapping, scales = "free", space = "free") 
    
```


# Timestamp

```{r, cache = FALSE}
date()
sessionInfo()
devtools::session_info()

```

```{r}
knitr::knit_exit()
```

# Cells corr


Some pairwise correlations for randomly picked cells


```{r}
set.seed(64554)
sampled <- sample(x = truth$cell, size = 10, replace = FALSE)


for (cell in sampled) {
    tmp <- list()
    tmp$truth <- truth[truth$cell == cell, 'id']
    for (item in grep('repeats', names(d), value = TRUE)) {
        tmp[[item]] <- rownames(d[[item]])[d[[item]][,cell] > 0]

    }

    ## build a matrix with binary distances?
    
    
}

```

```{r, eval = FALSE}
print('knit me')
knit::exit()
```

# are the wrong mappings things from the same family?


```{r}



gtf <- fread(params$reps_gtf, colClasses = c(rep('NULL', 8), 'character'))

reg <- 'gene_id "(.+)"; transcript_id "(.+)"; family_id "(.+)"; class_id "(.+)";'

gtf$id <- gsub(pattern = reg, replacement = '\\2', x = gtf$V9)
gtf$name <- gsub(pattern = reg, replacement = '\\1', x = gtf$V9)
gtf$family <- gsub(pattern = reg, replacement = '\\3', x = gtf$V9)
gtf$class <- gsub(pattern = reg, replacement = '\\4', x = gtf$V9)

gtf <- as.data.frame(gtf[,c('id', 'name', 'family', 'class')])

fds <- list()
for (item in setdiff(names(params), c('scte', 'shao_saf', 'truth', 'shao_counts', 'nthreads'))) {
    for (fn in list.files(dirname(params[[item]]), pattern = "*featureCounts")){
        print(fn)
        foo <- as.data.frame(fread(fn, sep = '\t'))
        foo <- merge(foo, gtf, by.x= 'V4', by.y = 'id', all.x = TRUE)
        colnames(foo) <- c('mapped.id', 'read_name', 'status', 'count', 'mapped.name', 'mapped.family',
                           'mapped.class')

        foo$sim.id <- gsub(pattern = '(.+);(.+);(.+);(.+);.*', replacement = '\\2', x = foo$read_name)
        foo <- merge(foo, gtf, by.x= 'sim.id', by.y = 'id', all.x = TRUE)
        ## head(foo)

        ## spawn multioverlaps?
        ## strsplit(foo$V4, split = ",")
        ## data.frame(V1 = rep(df$V1, sapply(s, length)), V2 = unlist(s))
        
        colnames(foo)[9:11] <- c('sim.name', 'sim.family', 'sim.class') 

        
        fds[[fn]] <- list(fn = fn,
                          family.correct = sum(na.omit(foo$mapped.family == foo$sim.family)),
                          family.wrong = sum(na.omit(foo$mapped.family != foo$sim.family)),
                          name.correct = sum(na.omit(foo$mapped.name == foo$sim.name)),
                          name.wrong = sum(na.omit(foo$mapped.name != foo$sim.name)),
                          class.correct = sum(na.omit(foo$mapped.class == foo$sim.class)),
                          class.wrong = sum(na.omit(foo$mapped.class != foo$sim.class)),
                          Unassigned_MultiMapping = sum(foo$status == 'Unassigned_MultiMapping'),
                          Unassigned_NoFeatures = sum(foo$status == 'Unassigned_NoFeatures'),
                          Unassigned_Unmapped = sum(foo$status == 'Unassigned_Unmapped'),
                          Unassigned_Ambiguity = sum(foo$status == 'Unassigned_Ambiguity'),
                          Assigned = sum(foo$status == 'Assigned'))
                          
        
        

        data.frame(cbind(table(foo$mapped.family == foo$sim.family, useNA = 'always')))
                              
        table(foo$mapped.name == foo$sim.name, useNA = 'always')
        table(foo$mapped.class == foo$sim.class, useNA = 'always')
        table(foo$status)


    }
        
}

```

# Timestamp

```{r sessionInfo, cache = FALSE}
date()
sessionInfo()
devtools::session_info()

```

```{r}
knitr::knit_exit()
```


