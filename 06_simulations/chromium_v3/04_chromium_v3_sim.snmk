#!/usr/bin/env snakemake -s
## 
## Started 28 Apr 2021
##
## Izaskun Mallona
## GPLv3

## important note: simulations are implemented in 03_simulate_chromium_v3.sh


import os.path as op
from glob import glob

RUN_NAME  = 'sim_5k_pbmc_v3'
RUN_TECH = 'chromium'


## Folder structure start --------------------------------------------------------------------- ##

#@FIXME to be moved to config, not hardcoded!
BASE = op.join('/home', 'imallona', 'repeats_sc')
# BASE = op.join('/scratch', 'imallona', 'repeats_sc')
NTHREADS = 10
NTHREADS_WITHIN=5
LOCAL_MEM_GB = 100
GENOME= 'GRCh38'
GENOME_SHORT = 'hg38'
SHAO_PATH=op.join('/home', 'imallona', 'src', 'repeats_sc', 'third_party') 

## @FIXME to be moved to config
GENOME_URL = 'ftp://ftp.ensembl.org/pub/release-98/fasta/homo_sapiens/dna/Homo_sapiens.GRCh38.dna.primary_assembly.fa.gz'
# GENES_GTF_URL =  'ftp://ftp.ensembl.org/pub/release-98/gtf/homo_sapiens/Homo_sapiens.GRCh38.98.gtf.gz'
GENES_GTF_URL = 'ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_33/gencode.v33.primary_assembly.annotation.gtf.gz'
REP_GTF_URL = 'hg38_rmsk.gtf.gz'
# REP_GTF_URL = 'http://labshare.cshl.edu/shares/mhammelllab/www-data/TEtranscripts/TE_GTF/mm10_rmsk_TE.gtf.gz'
DFAM_EMBL_URL = 'https://www.dfam.org/releases/current/families/Dfam.embl.gz'
# TRANSCRIPTOME_URL= 'ftp://ftp.ensembl.org/pub/release-98/fasta/homo_sapiens/cdna/Homo_sapiens.GRCh38.cdna.all.fa.gz'
TRANSCRIPTOME_URL = 'ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_33/gencode.v33.pc_transcripts.fa.gz'

CELLRANGER_DB_URL = 'http://cf.10xgenomics.com/supp/cell-exp/refdata-cellranger-GRCh38-3.0.0.tar.gz'
CELLRANGER_DB_ID = 'refdata-cellranger-GRCh38-3.0.0'

## @FIXME to be moved to config

GTF_PARSING_RSCRIPT = '~/src/repeats_sc/04_snakemake/scripts/gtf_parser.R'
FEATURECOUNTS_RSCRIPT= '~/src/repeats_sc/04_snakemake/scripts/plot_featurecounts_profile.R'
GTF_MAKING_SCRIPT = '~/src/repeats_sc/04_snakemake/scripts/gtf_maker.R'

BOWTIE_BUILD = '/home/imallona/soft/bowtie/bowtie-1.2.3/bowtie-build'
BOWTIE = '/home/imallona/soft/bowtie/bowtie-1.2.3/bowtie'

##pigz 2.3.1
PIGZ = '/usr/bin/pigz'
BIOPYTHON_CONVERT='biopython.convert'
STAR = '~/soft/star/STAR-2.7.3a/source/STAR'
FEATURECOUNTS = '~/soft/subread/subread-2.0.0-source/bin/featureCounts'
SALMON = '~/soft/salmon/salmon-1.1.0_linux_x86_64/bin/salmon'
CELLRANGER = '~/soft/cellranger/cellranger-3.1.0/cellranger'
BIOAWK = '~/soft/bioawk/bioawk'
BEDTOOLS = '~/soft/bedtools/bedtools-2.29.2/bin/bedtools'
Rscript = '/usr/local/R/R-4.0.5/bin/Rscript'
FASTQ_DUMP= '~/soft/sra-toools/sratoolkit.2.10.4-ubuntu64/bin/fastq-dump' # fastq-dump : 2.10.4
VDB_VALIDATE = '~/soft/sra-toools/sratoolkit.2.10.4-ubuntu64/bin/vdb-validate'
BEDOPS='~/soft/bedops/bedops-2.4.39/bin/bedops'

GSE144357_srr = ['SRR10974769', 'SRR10974768']

## config file start ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# configfile: "config.yaml"
# validate(config, "schemas/config.schema.yaml")

# samples = pd.read_csv(config["samples"], sep = '\t').set_index("id", drop=False)

CHEMISTRY = 'SC3Pv3'
DEMUX = False

# samples_R2, = glob_wildcards(op.join(BASE, "data", RUN_NAME, "{sample}_1.fastq.gz"))
# samples_R1, = glob_wildcards(op.join(BASE, "data", RUN_NAME, "{sample}_2.fastq.gz"))
# samples_I3, = glob_wildcards(op.join(BASE, "data", RUN_NAME, "{sample}_3.fastq.gz"))

## this is needed to be hardcoded/config file

try:
   if not op.exists(op.dirname(op.join(BASE, 'annotation'))):
      os.makedirs(op.join(BASE, 'annotation'))
except OSError as err:
   print(err)
      
for item in ['bowtie', 'star', 'salmon']:
   try:
      if not op.exists(op.dirname(op.join(BASE, 'indices', item))):
         os.makedirs(op.join(BASE, 'indices', item))
   except OSError as err:
      print(err)
      
## Folder structure end ----------------------------------------------------------------------- ##

include: "/home/imallona/src/repeats_sc/04_snakemake/chromium_flow.snmk"
    
rule all:
    input:
        # expand(op.join(BASE, 'runs', RUN_NAME, RUN_NAME + '_pbmc_chromium_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.html'), regress_ncount = ['TRUE', 'FALSE'],
        #                regress_nfeature = ['TRUE', 'FALSE']),
        # op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard_not_overlapping_genes',
        #         RUN_NAME + "_repeats_not_overlapping_genes.counts.gz"),
        op.join(BASE, 'data', RUN_NAME, "truth.tsv.gz"),
        expand(op.join(BASE, "runs", RUN_NAME,
                       'count_repeats_loci_on_cellranger_standard_not_overlapping_genes',
                            '{multimappers}',
                            RUN_NAME + "_repeats_not_overlapping_genes.counts.gz"),
                multimappers = ['multimappers', 'unique_reads']),
        expand(op.join(BASE, "runs", RUN_NAME, 'count_repeats_loci_on_cellranger_standard',
                            '{multimappers}',
                            RUN_NAME + "_repeats.counts.gz"),        
                 multimappers = ['multimappers', 'unique_reads']),
        # expand(op.join(BASE, "runs", RUN_NAME, 'test_count_repeats_loci_on_cellranger_standard',
        #                     '{multimappers}',
        #                     RUN_NAME + "_repeats.counts.gz"),        
        #          multimappers = ['multimappers', 'unique_reads']),
        op.join(BASE, 'runs', RUN_NAME, 'alevin', 'genes', 'alevin', 'quants_mat.gz'),
        op.join(BASE, 'runs', RUN_NAME, 'alevin', 'repeats', 'alevin', 'quants_mat.gz'),
        op.join(BASE, 'runs', RUN_NAME, 'cellranger_repeats', 'outs', 'web_summary.html'),
        op.join(BASE, 'runs', RUN_NAME, 'cellranger_standard', 'outs', 'web_summary.html'),
        op.join(BASE, 'runs', RUN_NAME, 'alevin', 'repeats_per_locus', 'alevin', 'quants_mat.gz'),
        expand(op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome", "{multimappers}",
                            "by_locus_repeats.counts.gz"),
               multimappers = ['multimappers', 'unique_reads']),
        op.join(BASE, 'runs', RUN_NAME, 'sim_postproc.html'),
        op.join(BASE, 'runs', RUN_NAME, 'scTE', 'scTE.out.csv.gz'),
        op.join(BASE, "runs", RUN_NAME, 'bowtie_repeatome', 'split_bowtie.flag'),
        op.join(BASE, 'runs', RUN_NAME, 'alevin', 'repeats_no_decoy_per_locus', 'alevin',
                'quants_mat.gz'),
        op.join(BASE, 'runs', RUN_NAME, 'zumis', 'sim_5k_zumis_count_dt.txt'),
        expand(op.join(BASE, "runs", RUN_NAME, 'count_repeats_loci_on_cellranger_repeats',
                            '{multimappers}',
                            RUN_NAME + "_repeats.counts.gz"),        
                 multimappers = ['multimappers', 'unique_reads'])
        # expand(op.join(BASE, 'runs', RUN_NAME, RUN_NAME + '_pbmc_alevin_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.html'), regress_ncount = ['TRUE', 'FALSE'],
        #                regress_nfeature = ['TRUE', 'FALSE']),
        #  op.join(BASE, "runs", RUN_NAME, 'bowtie_repeatome', 'split_bowtie.flag'),
        #  expand(op.join(BASE, "runs", RUN_NAME, 'bowtie_repeatome',
        #                 '{multimappers}',
        #                 "all_cells_repeats.counts.gz"),
        #         multimappers = ['multimappers', 'unique_reads'])


rule spawn_cellranger_repeats_bam_file_by_cell:
    input:
        bam = op.join(BASE, 'runs', RUN_NAME, 'cellranger_repeats', 'outs', 'possorted_genome_bam.bam'),
        barcodes = op.join(BASE, 'runs', RUN_NAME, 'cellranger_repeats', 'outs', 'filtered_feature_bc_matrix', 'barcodes.tsv.gz')
    output:
        rgs = temp(op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_repeats', 'rgs.txt')),
        header = temp(op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_repeats', 'header.txt')),
        body = temp(op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_repeats', 'body.txt.gz')),
        shortened_bam = temp(op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_repeats', 'shortened.bam')),
        flag = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_repeats', 'split.flag'),
        path = directory(op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_repeats', 'split'))
    threads:
        NTHREADS
    params:
        barcodes_script = op.join('scripts', 'get_cell_barcodes.py'),
        split_script = op.join('scripts','split_by_cell_barcode_in_sorted_bam.py'),
        split_path = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_repeats', 'split')
    log:
        log1 = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_repeats', 'split_add_rg.log'),
        log2 = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_repeats', 'split_pick.log'),
    shell:
        """
        mkdir -p {output.path}
        
        # python3 {params.barcodes_script} {input.bam} | {PIGZ} -p {threads} > {output.rgs}

        python3 {params.barcodes_script} {input.bam}  > {output.rgs}

        rm -f {input.bam}.bai
        samtools view -@ {threads} -H {input.bam} > {output.header}

        ## updated 2 oct to handle SRR8847571
        ( samtools view -@ {threads} {input.bam} | cut -f 1-15 | \
        paste - {output.rgs} | \
          fgrep "RG:Z" | \
          sed 's/\t$//' | sort -S1G --parallel={threads} -k16 | {PIGZ} -p {threads} --keep --stdout > {output.body} ) &> {log.log1}


        {PIGZ} --decompress -p {threads} --keep --stdout {output.body} | cat {output.header} - | samtools view -@ {threads} -Sb - > {output.shortened_bam}
        
        python3 {params.split_script} {output.shortened_bam} -outdir {params.split_path} -barcodes {input.barcodes} &> {log.log2}

        touch {output.flag}

        """

        
rule run_featurecounts_spawned_bams_cellranger_repeats_by_locus:
    input:
        bam = op.join(BASE, 'runs', RUN_NAME, 'cellranger_repeats', 'outs',
                      'possorted_genome_bam.bam'),
        flag = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_repeats',
                       'split.flag'),
        gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL))
    params:
        path = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_repeats', 'split')
    output:
        counts  = temp(op.join(BASE, "runs", RUN_NAME, 'count_repeats_loci_on_cellranger_repeats',
                               '{multimappers}',
                               RUN_NAME + "_repeats.counts")),
        gz_counts = op.join(BASE, "runs", RUN_NAME, 'count_repeats_loci_on_cellranger_repeats',
                            '{multimappers}',
                            RUN_NAME + "_repeats.counts.gz"),
        summary = op.join(BASE, "runs", RUN_NAME, 'count_repeats_loci_on_cellranger_repeats',
                          '{multimappers}',
                            RUN_NAME + "_repeats.counts.summary")
    log:
        op.join(BASE, 'runs', RUN_NAME, 'count_repeats_loci_on_cellranger_repeats',
                '{multimappers}',
                RUN_NAME + "_repeats_counting.log")   
    threads:
        NTHREADS_WITHIN
    run:
        if wildcards.multimappers == 'multimappers':
            shell("""
            echo multimappers allowed

            mkdir -p {params.path}
            cd {params.path}

            {FEATURECOUNTS} -T {threads} \
            -t exon \
            -g transcript_id \
            -a {input.gtf} \
            -o  {output.counts} \
            -M \
            --fraction \
            -R CORE \
            {params.path}/*bam  2>&1 > {log}

            {PIGZ} -f --keep -p {threads} {output.counts} -c > {output.gz_counts}
            # {PIGZ} -p {threads} "*featureCounts"

            """)
        elif wildcards.multimappers == 'unique_reads':
            shell("""
            echo unique only

            mkdir -p {params.path}
            cd {params.path}

            {FEATURECOUNTS} -T {threads} \
            -t exon \
            -g transcript_id \
            -a {input.gtf} \
            -o  {output.counts} \
            -R CORE \
            {params.path}/*bam  2>&1 > {log}

            {PIGZ} -f --keep -p {threads} {output.counts} -c > {output.gz_counts}
            # {PIGZ} -p {threads} "*featureCounts"
            """)
        

rule run_simulation:
    input:
        gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL)),
        genome_fasta = op.join(BASE, 'annotation', op.basename(GENOME_URL)),
        r1_origin = op.join(BASE, 'data', '5k_pbmc_v3', '5k_pbmc_v3_fastqs',
                            "5k_pbmc_v3_S1_L002_R1_001.fastq.gz"),
        r2_sim_origin =  op.join(BASE, 'data', '5k_pbmc_v3', '5k_pbmc_v3_fastqs',
                                 "5k_pbmc_v3_S1_L002_R2_001.fastq.gz")
    output:
        genome_fasta_uncomp = temp(op.join(BASE, 'annotation', op.splitext(op.basename(GENOME_URL))[0])),
        truth = op.join(BASE, 'data', RUN_NAME, "truth.tsv.gz"),       
        i1_sim =  op.join(BASE, 'data', RUN_NAME, 'sim_5k_pbmc_v3_S1_L002_I1_001.fastq.gz'),
        r1_sim =  op.join(BASE, 'data', RUN_NAME, 'sim_5k_pbmc_v3_S1_L002_R1_001.fastq.gz'),
        r2_sim =  op.join(BASE, 'data', RUN_NAME, 'sim_5k_pbmc_v3_S1_L002_R2_001.fastq.gz')
    params:
        path = op.join(BASE, 'data', RUN_NAME),
        length = 91,
        bedtools = BEDTOOLS,
        i1_origin = op.join(BASE, 'data', RUN_NAME, "5k_pbmc_v3_S1_L002_I1_001.fastq.gz"),
        # r1_origin = op.join(BASE, 'data', RUN_NAME, "5k_pbmc_v3_S1_L002_R1_001.fastq.gz"),
        # r1_origin = op.join(BASE, 'data', '5k_pbmc_v3', '5k_pbmc_v3_fastqs',
        #                          "5k_pbmc_v3_S1_L002_R1_001.fastq.gz"),
        truth_count_table = op.join(BASE, 'data', RUN_NAME, "truth.tsv"),
        cb=16,
        umi=12,
        num_cells=1000,
        dependency = "02_simulate_ground_truth_fastqs.sh",
        ti1_sim =  op.join(BASE, 'data', RUN_NAME, "sim_5k_pbmc_v3_S1_L002_I1_001.fastq"),
        tr1_sim =  op.join(BASE, 'data', RUN_NAME, "sim_5k_pbmc_v3_S1_L002_R1_001.fastq"),
        tr2_sim_origin =  op.join(BASE, 'data', RUN_NAME, "sim_5k_pbmc_v3_S1_L002_R2_001.fastq")
    log:
        op.join(BASE, 'data', RUN_NAME, "simulation.log")
    threads:
        NTHREADS 
    shell:
        """
        mkdir -p {params.path}

        bash 03_simulate_chromium_v3.sh --length {params.length} \
        --nthreads {threads} \
        --qual_symbol "F" \
        --gtf {input.gtf} \
        --genome_fasta {output.genome_fasta_uncomp} \
        --bedtools_bin {params.bedtools} \
        --i1_origin {params.i1_origin} \
        --r1_origin {input.r1_origin} \
        --r2_sim_origin {params.tr2_sim_origin} \
        --i1_sim {params.ti1_sim} \
        --r1_sim {params.tr1_sim} \
        --truth_count_table {params.truth_count_table} \
        --cb {params.cb} \
        --umi {params.umi} \
        --num_cells {params.num_cells} &> {log}

        # pigz -p {threads} --keep {params.path}/*

        """        
        
rule run_cellranger_repeats:
    input:
        truth = op.join(BASE, 'data', RUN_NAME, "truth.tsv.gz"),
        flag = op.join(BASE, 'indices', 'cellranger', 'repeats_' + GENOME,
                       'repeats_' + GENOME, 'reference.json')
    params:
        transcriptome = op.join(BASE, 'indices', 'cellranger', 'repeats_' + GENOME, 'repeats_' + GENOME),
        fastqs_path = op.join(BASE, 'data', RUN_NAME),
        sample_name = RUN_NAME,
        local_mem_gb = LOCAL_MEM_GB,
        processing_path = op.join(BASE, 'runs', RUN_NAME)
    output:
        op.join(BASE, 'runs', RUN_NAME, 'cellranger_repeats', 'outs', 'possorted_genome_bam.bam'),
        op.join(BASE, 'runs', RUN_NAME, 'cellranger_repeats', 'outs', 'web_summary.html'),
        op.join(BASE, 'runs', RUN_NAME, 'cellranger_repeats', 'outs', 'filtered_feature_bc_matrix', 'barcodes.tsv.gz')
    threads:
        NTHREADS_WITHIN
    log:
        op.join(BASE, 'runs', RUN_NAME, 'cellranger_repeats.log')
    shell:
        """
        mkdir -p {params.processing_path}
        cd {params.processing_path}
        rm -rf cellranger_repeats
        
        {CELLRANGER} count --id=cellranger_repeats \
          --fastqs={params.fastqs_path} \
          --transcriptome={params.transcriptome} \
          --jobmode=local \
          --localcores={threads} \
          --chemistry=SC3Pv3 \
          --sample={params.sample_name} \
          --localmem={params.local_mem_gb} &> {log}
        """
        
rule run_cellranger_standard:
    input:
        truth = op.join(BASE, 'data', RUN_NAME, "truth.tsv.gz"),
        transcriptome = op.join(BASE, 'indices', 'cellranger',
                                'refdata-cellranger-GRCh38-3.0.0')
    params:
        fastqs_path = op.join(BASE, 'data', RUN_NAME),
        sample_name = RUN_NAME,
        local_mem_gb = LOCAL_MEM_GB,
        processing_path = op.join(BASE, 'runs', RUN_NAME)
    output:
        op.join(BASE, 'runs', RUN_NAME, 'cellranger_standard', 'outs', 'web_summary.html'),
        op.join(BASE, 'runs', RUN_NAME, 'cellranger_standard', 'outs', 'filtered_feature_bc_matrix', 'barcodes.tsv.gz'),
        op.join(BASE, 'runs', RUN_NAME, 'cellranger_standard', 'outs', 'possorted_genome_bam.bam')
    threads:
        NTHREADS_WITHIN
    log:
        op.join(BASE, 'runs',  RUN_NAME, 'cellranger_standard.log')
    shell:
        """
        mkdir -p {params.processing_path}
        cd {params.processing_path}
        rm -rf cellranger_standard

        {CELLRANGER} count --id=cellranger_standard \
          --fastqs={params.fastqs_path} \
          --transcriptome={input.transcriptome} \
          --jobmode=local \
          --chemistry=SC3Pv3 \
          --localcores={threads} \
          --sample={params.sample_name} \
          --localmem={params.local_mem_gb} &> {log}
        """


        
rule map_salmon_repeats_chromium:
    input:
        truth = op.join(BASE, 'data', RUN_NAME, "truth.tsv.gz"),
        tgmap = op.join(BASE, 'indices', 'salmon', GENOME, 'repeats_salmon', 'txp2gene.tsv'),
        idx_tracker = op.join(BASE, 'indices', 'salmon', GENOME, 'repeats_salmon', 'duplicate_clusters.tsv'),
        cb = sorted(glob(op.join(BASE, 'data', RUN_NAME, '*R1*fastq.gz'))),
        r2 = sorted(glob(op.join(BASE, 'data', RUN_NAME, '*R2*fastq.gz')))        
    output:
        op.join(BASE, 'runs', RUN_NAME, 'alevin', 'repeats', 'alevin', 'quants_mat.gz')
    threads:
        NTHREADS_WITHIN
    params:
        fastqs_path = op.join(BASE, 'data', RUN_NAME),
        processing_path = op.join(BASE, 'runs', RUN_NAME, 'alevin', 'repeats'),
        salmon_idx = op.join(BASE, 'indices', 'salmon', GENOME, 'repeats_salmon'),
        cb = ' '.join(sorted(glob(op.join(BASE, 'data', RUN_NAME, '*R1*fastq.gz')))),
        r2 = ' '.join(sorted(glob(op.join(BASE, 'data', RUN_NAME, '*R2*fastq.gz')))) 
    log:
        op.join(BASE, 'runs', RUN_NAME, 'run_salmon_repeats_chromium.log')
    shell:
        """
    mkdir -p {params.processing_path}
    cd {params.processing_path}

    ({SALMON} alevin \
    -l ISR \
    -1 {params.cb} \
    -2 {params.r2} \
    --chromiumV3  \
    --dumpBfh \
    -i {params.salmon_idx} \
    --forceCells 1000 \
    -p {threads} -o {params.processing_path} \
    --tgMap {input.tgmap} ) 2> {log}

    touch -c {output}
        """
    

rule TESTING_map_salmon_repeats_chromium_no_decoy_per_locus:
    input:
        truth = op.join(BASE, 'data', RUN_NAME, "truth.tsv.gz"),
        tgmap = op.join(BASE, 'indices', 'salmon', GENOME, 'repeats_salmon_per_locus', 'txp2gene.tsv'),
        idx_tracker = op.join(BASE, 'indices', 'salmon', GENOME, 'repeats_salmon_no_decoy', 'duplicate_clusters.tsv'),
        cb = sorted(glob(op.join(BASE, 'data', RUN_NAME, '*R1*fastq.gz'))),
        r2 = sorted(glob(op.join(BASE, 'data', RUN_NAME, '*R2*fastq.gz')))        
    output:
        op.join(BASE, 'runs', RUN_NAME, 'alevin', 'repeats_no_decoy_per_locus', 'alevin',
                'quants_mat.gz')
    threads:
        NTHREADS_WITHIN
    params:
        fastqs_path = op.join(BASE, 'data', RUN_NAME),
        processing_path = op.join(BASE, 'runs', RUN_NAME, 'alevin', 'repeats_no_decoy_per_locus'),
        salmon_idx = op.join(BASE, 'indices', 'salmon', GENOME, 'repeats_salmon_no_decoy'),
        cb = ' '.join(sorted(glob(op.join(BASE, 'data', RUN_NAME, '*R1*fastq.gz')))),
        r2 = ' '.join(sorted(glob(op.join(BASE, 'data', RUN_NAME, '*R2*fastq.gz')))) 
    log:
        op.join(BASE, 'runs', RUN_NAME, 'run_salmon_repeats_chromium_no_decoy_per_locus.log')
    shell:
        """
    mkdir -p {params.processing_path}
    cd {params.processing_path}

    ({SALMON} alevin \
    -l ISR \
    -1 {params.cb} \
    -2 {params.r2} \
    --chromiumV3  \
    --dumpBfh \
    -i {params.salmon_idx} \
    --forceCells 1000 \
    -p {threads} -o {params.processing_path} \
    --tgMap {input.tgmap} ) 2> {log}

    touch -c {output}
        """
    
        
## beware the cb path for pbmc5k, they shouldn't be there at `RUN_NAME + '_fastqs/` subfoder
rule map_salmon_genes_chromium:
    input:
        truth = op.join(BASE, 'data', RUN_NAME, "truth.tsv.gz"),
        tgmap = op.join(BASE, 'indices', 'salmon', GENOME, 'genes_salmon', 'txp2gene.tsv'),
        idx_tracker = op.join(BASE, 'indices', 'salmon', GENOME, 'genes_salmon', 'duplicate_clusters.tsv'),
        cb = sorted(glob(op.join(BASE, 'data', RUN_NAME, '*R1*fastq.gz'))),
        r2 = sorted(glob(op.join(BASE, 'data', RUN_NAME, '*R2*fastq.gz')))        
    output:
        op.join(BASE, 'runs', RUN_NAME, 'alevin', 'genes', 'alevin', 'quants_mat.gz')
    threads:
        NTHREADS_WITHIN
    params:
        fastqs_path = op.join(BASE, 'data', RUN_NAME),
        processing_path = op.join(BASE, 'runs', RUN_NAME, 'alevin', 'genes'),
        salmon_idx = op.join(BASE, 'indices', 'salmon', GENOME, 'genes_salmon'),
        cb = ' '.join(sorted(glob(op.join(BASE, 'data', RUN_NAME, '*R1*fastq.gz')))),
        r2 = ' '.join(sorted(glob(op.join(BASE, 'data', RUN_NAME, '*R2*fastq.gz')))) 
    log:
        op.join(BASE, 'runs', RUN_NAME, 'run_salmon_genes_chromium.log')
    shell:
        """
    mkdir -p {params.processing_path}
    cd {params.processing_path}

    ({SALMON} alevin \
    -l ISR \
    -1 {params.cb} \
    -2 {params.r2} \
    --chromiumV3  \
    --forceCells 1000 \
    -i {params.salmon_idx} \
    -p {threads} -o {params.processing_path} \
    --tgMap {input.tgmap} ) 2> {log}

    touch -c {output}
        """

# index at the locus level?

# rather, modify the txp2gene to quantify individual items?

rule locify_txp2gene_repeats:
    input:
        txp2gene_repeats = op.join(BASE, 'indices', 'salmon', GENOME, 'repeats_salmon',
                                   'txp2gene.tsv')
    output:
        txp2gene_repeat_locus = op.join(BASE, 'indices', 'salmon', GENOME,
                                        'repeats_salmon_per_locus',
                                        'txp2gene.tsv')
    params:
        path = op.join(BASE, 'salmon', GENOME, 'repeats_salmon_per_locus')
    shell:
        """
        mkdir -p {params.path}
        awk '{{print $1,$1}}' {input.txp2gene_repeats} > {output.txp2gene_repeat_locus} 
        """
   
rule map_salmon_repeats_chromium_per_locus:
    input:
        truth = op.join(BASE, 'data', RUN_NAME, "truth.tsv.gz"),
        tgmap = op.join(BASE, 'indices', 'salmon', GENOME, 'repeats_salmon_per_locus',
                                        'txp2gene.tsv'),
        idx_tracker = op.join(BASE, 'indices', 'salmon', GENOME, 'repeats_salmon',
                              'duplicate_clusters.tsv'),
        cb = sorted(glob(op.join(BASE, 'data', RUN_NAME, '*R1*fastq.gz'))),
        r2 = sorted(glob(op.join(BASE, 'data', RUN_NAME, '*R2*fastq.gz')))        
    output:
        op.join(BASE, 'runs', RUN_NAME, 'alevin', 'repeats_per_locus', 'alevin', 'quants_mat.gz')
    threads:
        NTHREADS_WITHIN
    params:
        fastqs_path = op.join(BASE, 'data', RUN_NAME),
        processing_path = op.join(BASE, 'runs', RUN_NAME, 'alevin', 'repeats_per_locus'),
        salmon_idx = op.join(BASE, 'indices', 'salmon', GENOME, 'repeats_salmon'),
        cb = ' '.join(sorted(glob(op.join(BASE, 'data', RUN_NAME, '*R1*fastq.gz')))),
        r2 = ' '.join(sorted(glob(op.join(BASE, 'data', RUN_NAME, '*R2*fastq.gz')))) 
    log:
        op.join(BASE, 'runs', RUN_NAME, 'run_salmon_repeats_chromium_per_locus.log')
    shell:
        """
    mkdir -p {params.processing_path}
    cd {params.processing_path}

    ({SALMON} alevin \
    -l ISR \
    -1 {params.cb} \
    -2 {params.r2} \
    --chromiumV3  \
    --dumpBfh \
    --dumpFeatures \
    -i {params.salmon_idx} \
    --forceCells 1000 \
    -p {threads} -o {params.processing_path} \
    --tgMap {input.tgmap} ) 2> {log}

    touch -c {output}
        """

        
rule run_featurecounts_spawned_bams_per_locus:
    input:
        truth = op.join(BASE, 'data', RUN_NAME, "truth.tsv.gz"),
        flag = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'split.flag'),
        gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL))
    params:
        path = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'split')        
    output:
        counts  = temp(op.join(BASE, "runs", RUN_NAME, 'count_repeats_loci_on_cellranger_standard',
                               '{multimappers}',
                               RUN_NAME + "_repeats.counts")),
        gz_counts = op.join(BASE, "runs", RUN_NAME, 'count_repeats_loci_on_cellranger_standard',
                            '{multimappers}',
                            RUN_NAME + "_repeats.counts.gz"),
        summary = op.join(BASE, "runs", RUN_NAME, 'count_repeats_loci_on_cellranger_standard',
                          '{multimappers}',
                            RUN_NAME + "_repeats.counts.summary")
    log :
        log = op.join(BASE, "runs",  RUN_NAME, 'count_repeats_loci_on_cellranger_standard',
                      '{multimappers}',                      
                      'feature_counts.log'),
    threads:
        NTHREADS_WITHIN
    run:
        if wildcards.multimappers == 'multimappers':
            shell("""
            echo multimappers allowed

            cd {params.path}

            {FEATURECOUNTS} -T {threads} \
            -t exon \
            -g transcript_id \
            -a {input.gtf} \
            -o  {output.counts} \
            -M \
            --fraction \
            -R CORE \
            {params.path}/*bam  2>&1 > {log}

            {PIGZ} -f --keep -p {threads} {output.counts} -c > {output.gz_counts}

            """)
        elif wildcards.multimappers == 'unique_reads':
            shell("""
            echo unique only

            cd {params.path}

            {FEATURECOUNTS} -T {threads} \
            -t exon \
            -g transcript_id \
            -a {input.gtf} \
            -o  {output.counts} \
            -R CORE \
            {params.path}/*bam  2>&1 > {log}

            {PIGZ} -f --keep -p {threads} {output.counts} -c > {output.gz_counts}
            """)

                    
rule test_featurecounts_o:
    input:
        truth = op.join(BASE, 'data', RUN_NAME, "truth.tsv.gz"),
        flag = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'split.flag'),
        gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL))
    params:
        path = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'split')        
    output:
        counts  = temp(op.join(BASE, "runs", RUN_NAME, 'test_count_repeats_loci_on_cellranger_standard',
                               '{multimappers}',
                               RUN_NAME + "_repeats.counts")),
        gz_counts = op.join(BASE, "runs", RUN_NAME, 'test_count_repeats_loci_on_cellranger_standard',
                            '{multimappers}',
                            RUN_NAME + "_repeats.counts.gz"),
        summary = op.join(BASE, "runs", RUN_NAME, 'test_count_repeats_loci_on_cellranger_standard',
                          '{multimappers}',
                            RUN_NAME + "_repeats.counts.summary")
    log :
        log = op.join(BASE, "runs",  RUN_NAME, 'test_count_repeats_loci_on_cellranger_standard',
                      '{multimappers}',                      
                      'feature_counts.log'),
    threads:
        NTHREADS_WITHIN
    run:
        if wildcards.multimappers == 'multimappers':
            shell("""
            echo multimappers allowed
            mkdir -p {params.path}
            cd {params.path}

            {FEATURECOUNTS} -T {threads} \
            -t exon \
            -g transcript_id \
            -a {input.gtf} \
            -o  {output.counts} \
            -M -O \
            -R CORE \
            --fraction \
            {params.path}/*bam  2>&1 > {log}

            {PIGZ} -f --keep -p {threads} {output.counts} -c > {output.gz_counts}

            """)
        elif wildcards.multimappers == 'unique_reads':
            shell("""
            echo unique only
            mkdir -p {params.path}

            cd {params.path}

            {FEATURECOUNTS} -T {threads} \
            -t exon \
            -g transcript_id \
            -a {input.gtf} \
            -o  {output.counts} \
            -O \
            --fraction \
            -R CORE \
            {params.path}/*bam  2>&1 > {log}

            {PIGZ} -f --keep -p {threads} {output.counts} -c > {output.gz_counts}
            """)

            
rule run_feature_counts_repeats_not_overlapping_genes_spawned_bams_per_locus:
    input:
        truth = op.join(BASE, 'data', RUN_NAME, "truth.tsv.gz"),
        flag = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'split.flag'),
        gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL) + '_minus_' + op.basename(GENES_GTF_URL))
    params:
        path = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'split')
    output:
        counts  = temp(op.join(BASE, "runs", RUN_NAME,
                               'count_repeats_loci_on_cellranger_standard_not_overlapping_genes',
                               '{multimappers}',
                               RUN_NAME + "_repeats_not_overlapping_genes.counts")),
        gz_counts = op.join(BASE, "runs", RUN_NAME, 'count_repeats_loci_on_cellranger_standard_not_overlapping_genes',
                            '{multimappers}',
                            RUN_NAME + "_repeats_not_overlapping_genes.counts.gz"),
        summary = op.join(BASE, "runs", RUN_NAME, 'count_repeats_loci_on_cellranger_standard_not_overlapping_genes',
                          '{multimappers}',
                           RUN_NAME + "_repeats_not_overlapping_genes.counts.summary")
    log :
        log = op.join(BASE, "runs",  RUN_NAME, 'count_repeats_loci_on_cellranger_standard_not_overlapping_genes',
                      '{multimappers}',
                      'feature_counts_not_overlapping_genes.log'),
    threads:
        NTHREADS_WITHIN
    run:
        if wildcards.multimappers == 'multimappers':
            shell("""
            echo multimappers allowed

            cd {params.path}

            {FEATURECOUNTS} -T {threads} \
            -t exon \
            -g transcript_id \
            -a {input.gtf} \
            -o  {output.counts} \
            -M -R CORE \
            --fraction \
            {params.path}/*bam  2>&1 > {log}

            {PIGZ} -f --keep -p {threads} {output.counts} -c > {output.gz_counts}

            """)
        elif wildcards.multimappers == 'unique_reads':
            shell("""
            echo unique only

            cd {params.path}

            {FEATURECOUNTS} -T {threads} \
            -t exon \
            -g transcript_id \
            -a {input.gtf} \
            -o  {output.counts} \
            -R CORE \
            {params.path}/*bam  2>&1 > {log}

            {PIGZ} -f --keep -p {threads} {output.counts} -c > {output.gz_counts}
            """)

# index cellranger so it counts transcript ids? for that, hacking the GTF and having the
## gene_ids replaced by transcript ids content would be needed.


rule knit_report:
    input:
        repeats_repeats_unique = op.join(
           BASE, "runs", RUN_NAME, 'count_repeats_loci_on_cellranger_repeats',
           'unique_reads',
           RUN_NAME + "_repeats.counts.gz"),
        repeats_repeats_multi = op.join(
           BASE, "runs", RUN_NAME, 'count_repeats_loci_on_cellranger_repeats',
           'unique_reads',
           RUN_NAME + "_repeats.counts.gz"),        
        repeats_only_multi = op.join(
           BASE, "runs", RUN_NAME,
           'count_repeats_loci_on_cellranger_standard_not_overlapping_genes',
           'multimappers',
           RUN_NAME + "_repeats_not_overlapping_genes.counts.gz"),           
        repeats_featurecounts_multi = op.join(
           BASE, "runs", RUN_NAME, 'count_repeats_loci_on_cellranger_standard',
           'multimappers',
           RUN_NAME + "_repeats.counts.gz"),
        repeats_only_unique = op.join(
           BASE, "runs", RUN_NAME,
           'count_repeats_loci_on_cellranger_standard_not_overlapping_genes',
           'unique_reads',
           RUN_NAME + "_repeats_not_overlapping_genes.counts.gz"),           
        repeats_featurecounts_unique = op.join(
           BASE, "runs", RUN_NAME, 'count_repeats_loci_on_cellranger_standard',
           'unique_reads',
           RUN_NAME + "_repeats.counts.gz"), 
        repeats_alevin_locus = op.join(BASE, 'runs', RUN_NAME, 'alevin', 'repeats_per_locus',
                                       'alevin', 'quants_mat.gz'),
        repeats_alevin_no_decoy_locus = op.join(BASE, 'runs', RUN_NAME, 'alevin',
                                               'repeats_no_decoy_per_locus',
                                       'alevin', 'quants_mat.gz'),
       
        repeats_bowtie_unique = op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome",
                                        "unique_reads",
                                        "by_locus_repeats.counts.gz"),
        repeats_bowtie_multi = op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome",
                                        "multimappers",
                                        "by_locus_repeats.counts.gz"),
        scte = op.join(BASE, 'runs', RUN_NAME, 'scTE', 'scTE.out.csv.gz'),
        truth = op.join(BASE, 'data', RUN_NAME, "truth.tsv.gz"),
        shao_counts = op.join(BASE, 'runs', RUN_NAME, 'zumis',
                              'sim_5k_zumis_count_dt.txt'),
        shao_saf = op.join(BASE, 'annotation', 'shao', GENOME_SHORT,
                           'shao_' + GENOME_SHORT + '_te.saf'),
        shao_sam = op.join(BASE, 'runs', RUN_NAME, 'zumis',
                              'sim_5k_zumis_featurecount.sam.txt'),
        reps_gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL))
    params:
        rmd = 'postprocess_simulation.Rmd',
        run_name = RUN_NAME,
        threads = NTHREADS_WITHIN
    output:
        html = op.join(BASE, 'runs', RUN_NAME, 'sim_postproc.html')
    log:
        op.join(BASE, 'runs', RUN_NAME, 'sim_postproc.log')
    shell: """
        {Rscript} -e 'rmarkdown::render(\"{params.rmd}\", 
          output_file = \"{output.html}\", 
          params = list(truth = \"{input.truth}\", 
                     repeats_lenient_multi = \"{input.repeats_featurecounts_multi}\", 
                     repeats_lenient_unique = \"{input.repeats_featurecounts_unique}\",
                     repeats_strict_multi = \"{input.repeats_only_multi}\", 
                     repeats_strict_unique = \"{input.repeats_only_unique}\",
                     repeats_alevin_locus = \"{input.repeats_alevin_locus}\",
                     repeats_alevin_no_decoy_locus = \"{input.repeats_alevin_no_decoy_locus}\",
                     repeats_bowtie_unique = \"{input.repeats_bowtie_unique}\",
                     repeats_bowtie_multi = \"{input.repeats_bowtie_multi}\",
                     repeats_unique = \"{input.repeats_repeats_unique}\",
                     repeats_multi = \"{input.repeats_repeats_multi}\",
                     scte = \"{input.scte}\",
                     shao_counts = \"{input.shao_counts}\",
                     shao_saf = \"{input.shao_saf}\",
                     shao_sam = \"{input.shao_sam}\",
                     reps_gtf = \"{input.reps_gtf}\",
                     nthreads = {params.threads}))' &> {log}
        """

## run bowtie
   
## test run bowtie start
## to avoid explicitly handling the cell barcodes, we take the cellranger output as correct
##   (e.g. splitting the cells by CB from the cellranger standard output)


# multimappers with ifelse?
rule featurecounts_bowtie_repeats_repeatome_by_locus:
    input:
        flag = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'split.flag'),
        flag_map_bowtie =  op.join(BASE, "runs", RUN_NAME, 'bowtie_repeatome', 'split_bowtie.flag'),
        gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL)),
        fake_repeatome_gtf = op.join(BASE, 'annotation', 'fake_repeatome_from_' + op.splitext(op.basename(REP_GTF_URL))[0]) + '.gtf.gz'
    output:
        counts  = temp(op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome", "{multimappers}",
                               "by_locus_repeats.counts")),
        gz_counts = op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome", "{multimappers}",
                            "by_locus_repeats.counts.gz")
    params:
        bam_path = op.join(BASE, "runs", RUN_NAME, 'bowtie_repeatome'),
        processing_path = op.join(BASE, "runs", RUN_NAME, "{multimappers}", 'bowtie_repeatome')
    log :
        op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome", "{multimappers}", "by_locus_featurecounts.log"),
    threads:
        NTHREADS_WITHIN
    run:
        if wildcards.multimappers == 'multimappers':
            shell("""
            echo multimappers allowed

            mkdir -p {params.processing_path}

            cd {params.processing_path}
            
            # find .. -empty -delete
            
            {FEATURECOUNTS} -T {threads} \
            -t exon \
            -g transcript_id \
            -a {input.fake_repeatome_gtf} \
            -o  {output.counts} \
            -R CORE \
            -M --fraction \
            {params.bam_path}/*bam  &> {log}

            {PIGZ} --keep  -p {threads} {output.counts}
         """)
        elif wildcards.multimappers == 'unique_reads':
            shell("""
            echo unique only

            mkdir -p {params.processing_path}

            cd {params.processing_path}
            
            # find .. -empty -delete
            
            {FEATURECOUNTS} -T {threads} \
            -t exon \
            -g transcript_id \
            -a {input.fake_repeatome_gtf} \
            -R CORE \
            -o  {output.counts} \
            {params.bam_path}/*bam  &> {log}

            {PIGZ} --keep  -p {threads} {output.counts}

            """)

# rule build_gtf:
#     priority:
#         100
#     output:
#         gtf = op.join(BASE, 'annotation', REP_GTF_URL),
#         tmp = temp(op.join(op.join(BASE, "runs", RUN_NAME, 'tmp.dump.gz')))
#     params:
#         genome = GENOME_SHORT,
#         Rscript = Rscript,
#         processing_path = op.join(BASE, "runs", RUN_NAME)
#     threads:
#         NTHREADS_WITHIN
#     shell:
#         """
#         # bash gtf_build.sh
#         mysql --user=genome --host=genome-mysql.cse.ucsc.edu -D {params.genome} -A \
#            -B -sN -e  "select genoName, genoStart, genoEnd, swScore, strand, 
#                repName,repClass,repFamily
#            from rmsk
#            order by genoName,genoStart, genoEnd" | sed 's/^chr//g' | \
#                   grep -P  '^[0-9]{{1,2}}\t|^[XY]\t' | \
#                   pigz -p {threads} > {output.tmp}

#         {params.Rscript} parse_dump_gtf.R --rmsk {output.tmp} \
#                 --source {params.genome} | pigz -p {threads} > {output.gtf}
#         """

rule build_gtf_cellranger_compliant:
    priority:
        100
    output:
        gtf = op.join(BASE, 'annotation', REP_GTF_URL),
        tmp = temp(op.join(op.join(BASE, "runs", RUN_NAME, 'tmp.dump.gz')))
    params:
        genome = GENOME_SHORT,
        Rscript = Rscript,
        processing_path = op.join(BASE, "runs", RUN_NAME)
    threads:
        NTHREADS_WITHIN
    shell:
        """
        # bash gtf_build.sh
        mysql --user=genome --host=genome-mysql.cse.ucsc.edu -D {params.genome} -A \
           -B -sN -e  "select genoName, genoStart, genoEnd, swScore, strand, 
               repName,repClass,repFamily
           from rmsk
           order by genoName,genoStart, genoEnd" | sed 's/^chr//g' | \
                  grep -P  '^[0-9]{{1,2}}\t|^[XY]\t' | \
                  pigz -p {threads} > {output.tmp}

        {params.Rscript} parse_dump_gtf.R --rmsk {output.tmp} \
                --source {params.genome} | pigz -p {threads} > {output.gtf}
        """
    
rule generate_scte_index:
    output:
        idx = op.join(BASE,  'annotation', 'scTE', GENOME_SHORT, GENOME_SHORT + ".exclusive.idx")
    log:
        op.join(BASE,  'annotation', 'scTE', GENOME_SHORT, GENOME_SHORT + ".exclusive.log")
    params:
        path = op.join(BASE, 'annotation', 'scTE', GENOME_SHORT),
        genome = GENOME_SHORT
    threads:
        NTHREADS
    shell:
        """
        mkdir -p {params.path}
        cd {params.path}
        scTE_build -g {params.genome} &> {log} 
        """

rule run_scte_on_cellranger:
    input:
        truth = op.join(BASE, 'data', RUN_NAME, "truth.tsv.gz"),
        bam = op.join(BASE, 'runs', RUN_NAME, 'cellranger_standard', 'outs',
                      'possorted_genome_bam.bam'),
        idx = op.join(BASE,  'annotation', 'scTE', GENOME_SHORT, GENOME_SHORT + ".exclusive.idx")
    output:
        tmp = temp(op.join(BASE, 'runs', RUN_NAME, 'scTE', 'scTE.out.csv')),
        counts = op.join(BASE, 'runs', RUN_NAME, 'scTE', 'scTE.out.csv.gz')
    params:
        path = op.join(BASE, 'runs', RUN_NAME, 'scTE'),
        out_fn = 'scTE.out'

    log:
        op.join(BASE, 'runs', RUN_NAME, 'scTE', 'scTE.log')        
    threads:
        NTHREADS
    shell:
        """
        mkdir -p {params.path}
        cd {params.path}

        scTE -i {input.bam} -o {params.out_fn} \
          -x {input.idx} \
          --hdf5 False \
          -CB CR \
          -UMI UR \
          --expect-cells 1000 \
          -p {threads} &> {log} 
        
        pigz -p {threads} --keep {output.tmp}
        """


rule generate_shao_index:
    params:
        shao_id = 'shao_' + GENOME_SHORT,
        genome = GENOME_SHORT,
        rmsk_url = temp("http://hgdownload.cse.ucsc.edu/goldenpath/" + GENOME_SHORT + "/database/rmsk.txt.gz"),
        refgene_url = temp("http://hgdownload.cse.ucsc.edu/goldenpath/" + GENOME_SHORT + "/database/refGene.txt.gz"),
        path = op.join(BASE, 'annotation', 'shao', GENOME_SHORT),
        export_saf_files = op.join(SHAO_PATH, 'TE_expression_in_scRNAseq',
                                   'scripts', 'export_saf_files.r')
    output:
        rmsk_gz = op.join(BASE, 'annotation', 'shao', GENOME_SHORT, 'rmsk.txt.gz'),
        refgene_gz = op.join(BASE, 'annotation', 'shao',  GENOME_SHORT, 'refGene.txt.gz'),
        chrlengths = op.join(BASE, 'annotation', 'shao', GENOME_SHORT, 'chrlengths.txt'),
        shao_te_saf = op.join(BASE, 'annotation', 'shao', GENOME_SHORT, 'shao_' + GENOME_SHORT + '_te.saf')
    threads:
        NTHREADS
    shell:
        """
        mkdir -p {params.path}
        cd {params.path}
        
        wget {params.rmsk_url} -O {output.rmsk_gz}
        wget {params.refgene_url}  -O {output.refgene_gz}

        mysql  --user=genome --host=genome-mysql.cse.ucsc.edu -A -D {params.genome} \
          -e 'select size from chromInfo' -B -N > {output.chrlengths}

        {Rscript} {params.export_saf_files} \
         -g {output.refgene_gz} \
         -r {output.rmsk_gz} \
         -l {output.chrlengths} \
         -n {params.shao_id} \
         -m chrM -p {threads}
        """

## @todo this should not be hardcoded 
rule write_VERY_hardcoded_yaml_file_zumis_shao:
    input:
        not_used_actually = op.join(BASE, 'annotation', 'shao', GENOME_SHORT,
                                    'shao_' + GENOME_SHORT + '_te.saf')
    output:
        yaml = op.join(BASE, 'runs', RUN_NAME, "shao", 'zumis.yaml')
    params:
        path = op.join(BASE, 'runs', RUN_NAME, "shao")
    shell:
        """
mkdir -p {params.path}

cat << EOF > {output.yaml}
###########################################
#Welcome to zUMIs
#below, please fill the mandatory inputs
#We expect full paths for all files.
###########################################

#define a project name that will be used to name output files
project: sim_5k_zumis

#Sequencing File Inputs:
#For each input file, make one list object & define path and barcode ranges
#base definition vocabulary: BC(n) UMI(n) cDNA(n).
#Barcode range definition needs to account for all ranges. You can give several comma-separated ranges for BC & UMI sequences, eg. BC(1-6,20-26)
#you can specify between 1 and 4 input files
sequence_files:
  file1:
    name: /home/imallona/repeats_sc/data/sim_5k_pbmc_v3/sim_5k_pbmc_v3_S1_L002_R1_001.fastq.gz  #path to first file
    base_definition:
      - BC(1-16) #example: BC(1-6)
      - UMI(17-28) #example: UMI(7-16)
  file2:
    name: /home/imallona/repeats_sc/data/sim_5k_pbmc_v3/sim_5k_pbmc_v3_S1_L002_R2_001.fastq.gz  #path to second file
    base_definition:
      - cDNA(1-92) #example: cDNA(1-50)

#reference genome setup
reference:
  STAR_index: /home/imallona/repeats_sc/indices/star/GRCh38/transcriptome/
  SAF_file: /home/imallona/repeats_sc/annotation/shao/shao_GRCh38_te.saf
  # GTF_file: /home/imallona/repeats_sc/annotation/gencode.v33.primary_assembly.annotation.gtf.gz
  additional_files: #Optional parameter. It is possible to give additional reference sequences here, eg ERCC.fa
  additional_STAR_params: #Optional parameter. you may add custom mapping parameters to STAR here
  allow_multimapping: yes #yes or no for multimapping option
#output directory
out_dir: /home/imallona/repeats_sc/runs/sim_5k_pbmc_v3/zumis # directory

###########################################
#below, you may optionally change default parameters
###########################################

#number of processors to use
num_threads: 10
mem_limit: 300 #Memory limit in Gigabytes, null meaning unlimited RAM usage.

#barcode & UMI filtering options
#number of bases under the base quality cutoff that should be filtered out.
#Phred score base-cutoff for quality control.
filter_cutoffs:
  BC_filter:
    num_bases: 1
    phred: 20
  UMI_filter:
    num_bases: 1
    phred: 20

#Options for Barcode handling
#You can give either number of top barcodes to use or give an annotation of cell barcodes.
#If you leave both barcode_num and barcode_file empty, zUMIs will perform automatic cell barcode selection for you!
barcodes:
  barcode_num: null
  barcode_file: null
  automatic: yes #Give yes/no to this option. If the cell barcodes should be detected automatically. If the barcode file is given in combination with automatic barcode detection, the list of given barcodes will be used as whitelist.
  BarcodeBinning: 1 #Hamming distance binning of close cell barcode sequences.
  nReadsperCell: 100 #Keep only the cell barcodes with atleast n number of reads.

#Options related to counting of reads towards expression profiles
counting_opts:
  strand: 1 #Is the library stranded? 0 = unstranded, 1 = positively stranded, 2 = negatively stranded
  countMultiMappingReads: yes #Do you want to count the multiple aligned reads
  fracOverlap: 0.1 #percentage reads to overlap with features
  twoPass: yes #perform basic STAR twoPass mapping


#Start zUMIs from stage. Possible TEXT(Filtering, Mapping, Counting, Summarising). Default: Filtering.
which_Stage: Filtering

#define dependencies program paths
samtools_exec: samtools #samtools executable
Rscript_exec: /usr/local/R/R-4.1.0/bin/Rscript # Rscript #Rscript executable
STAR_exec: /home/imallona/soft/star/STAR-2.7.3a/bin/Linux_x86_64/STAR #STAR executable
pigz_exec: pigz #pigz executable

#below, fqfilter will add a read_layout flag defining SE or PE
zUMIs_directory: /home/imallona/soft/TE_expression_in_scRNAseq/scripts/zUMIs_TE_modified/
read_layout: SE
EOF
    """

# these are coded under third_party, shao_installs.sh
rule run_shao:
    input:
        truth = op.join(BASE, 'data', RUN_NAME, "truth.tsv.gz"),
        yaml = op.join(BASE, 'runs', RUN_NAME, "shao", 'zumis.yaml'),
        shao_te_saf = op.join(BASE, 'annotation', 'shao', GENOME_SHORT,
                              'shao_' + GENOME_SHORT + '_te.saf')
    params:
        zumis_master_te = op.join(SHAO_PATH,
                                  'TE_expression_in_scRNAseq', 'scripts',
                                  'zUMIs_TE_modified', 'zUMIs-master-TE.sh'),
        path = op.join(SHAO_PATH, 'TE_expression_in_scRNAseq', 'scripts', 'zUMIs_TE_modified'),
        path2 = op.join(BASE, 'runs', RUN_NAME, 'zumis'),
        umi_counting = op.join(SHAO_PATH,
                               "TE_expression_in_scRNAseq", 'scripts',
                               "scRNA_UMI_counting.R")
    threads:
        NTHREADS
    output:
        dt = op.join(BASE, 'runs', RUN_NAME, 'zumis', 'sim_5k_zumis_count_dt.txt'),
        shao_sam =op.join(BASE, 'runs', RUN_NAME, 'zumis',
                              'sim_5k_zumis_featurecount.sam.txt')
    shell:
        """        
        mkdir -p {params.path} {params.path2}
        cd {params.path2}

        {params.zumis_master_te} \
          -y {input.yaml} \
          -d {params.path}

        {Rscript} {params.umi_counting} \
         -f {output.shao_sam} \
         -r {input.shao_te_saf} \
         -n sim_5k_zumis \
         -s 50 \
         -m 1 \
         -p {threads}
        """
