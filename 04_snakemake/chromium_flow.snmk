#!/usr/bin/env snakemake -s
## 
## Started 14th Jan 2020
##
## Izaskun Mallona
## GPLv3

import os.path as op
from glob import glob


## salmon start



# https://salmon.readthedocs.io/en/latest/alevin.html
# ./bin/salmon index -t transcripts.fa -i transcripts_index --decoys decoys.txt -k 31
## shall I use a decoy? https://github.com/COMBINE-lab/SalmonTools/README.md
# apparently not
# **NOTE:** Salmon version [v1.0](https://github.com/COMBINE-lab/salmon/releases/tag/v1.0.0) can directly index the genome and transcriptome and doesn't mandates to run the `generateDecoyTranscriptome` script, however it's still backward compatible. Please checkout [this](https://combine-lab.github.io/alevin-tutorial/2019/selective-alignment/) tutorial on how to run salmon with full genome + transcriptome without the annotation.
rule index_genes_salmon_no_decoy:
    input:
        transcripts = op.join(BASE, 'annotation', op.basename(TRANSCRIPTOME_URL))
    params:
        k = 31,
        path = op.join(BASE, 'indices', 'salmon', GENOME, 'genes_salmon')
    log:
        op.join(BASE, 'indices', 'salmon', GENOME, 'genes_salmon', 'genes_salmon_index.log')
    threads:
        NTHREADS
    output:
        op.join(BASE, 'indices', 'salmon', GENOME, 'genes_salmon', 'duplicate_clusters.tsv'),
        op.join(BASE, 'indices', 'salmon', GENOME, 'genes_salmon', 'complete_ref_lens.bin')
    shell:        
        """
        mkdir -p {params.path}
        
        ({SALMON} index --gencode -p {threads} index \
           -t {input.transcripts} -i {params.path} -k {params.k})  2> {log}

        touch -c {params.path}

        """
        
rule get_transcriptome_fasta:
    priority:
        100
    output:
        tmp = temp(op.join(BASE, 'annotation', op.basename(TRANSCRIPTOME_URL) + '_temp.fa.gz')),
        tx = temp(op.join(BASE, 'annotation', op.basename(TRANSCRIPTOME_URL)))
    params:
        url = TRANSCRIPTOME_URL
    threads:
        NTHREADS
    shell:
        """
        curl -s -L -C - {params.url} -o {output.tmp}

        ## to go from
        # >ENST00000456328.2|ENSG00000223972.5|OTTHUMG0000000096 (etc)
        # to
        # >ENST00000456328.2
        {PIGZ} -p {threads} --decompress --keep -c {output.tmp}  |  cut -d '|' -f1 | \
        {PIGZ} -p {threads} -c  > {output.tx}
        """


rule get_decoy:
    input:
        transcriptome = op.join(BASE, 'annotation', op.basename(TRANSCRIPTOME_URL))
    output:        
        decoys = op.join(BASE, 'annotation', op.splitext(op.basename(TRANSCRIPTOME_URL))[0] + '_transcriptome_decoys.txt')
    threads:
       NTHREADS
    shell:
        """
        {PIGZ} --decompress --keep --processes {threads} --to-stdout {input.transcriptome} |  grep ">" | \
        cut -d ">" -f 2 | cut -d "|" -f 1 > {output.decoys}
        """

rule index_repeats_salmon_repeats_with_decoy_transcriptome:
    input:
        repeats = op.join(BASE, 'annotation', 'repeatome_from_' + op.splitext(op.basename(REP_GTF_URL))[0] + '.fa.gz'),
        # genome =  op.join(BASE, 'annotation', op.basename(GENOME_URL)),
        transcriptome = op.join(BASE, 'annotation', op.basename(TRANSCRIPTOME_URL)),
        decoys =  op.join(BASE, 'annotation', op.splitext(op.basename(TRANSCRIPTOME_URL))[0] + '_transcriptome_decoys.txt')
    output:
        op.join(BASE, 'indices', 'salmon', GENOME, 'repeats_salmon', 'duplicate_clusters.tsv'),
        op.join(BASE, 'indices', 'salmon', GENOME, 'repeats_salmon', 'complete_ref_lens.bin')
    params:
        path = op.join(BASE, 'indices', 'salmon', GENOME, 'repeats_salmon'),
        k = 31
    threads:
        NTHREADS
    log:
        op.join(BASE, 'indices', 'salmon', GENOME, 'repeats_salmon_index.log')
    shell:
        """
        mkdir -p {params.path}
        
        ({SALMON} index -p {threads} \
          index -t <( zcat {input.repeats} {input.transcriptome}) -i {params.path} -k {params.k} \
          -d {input.decoys}) 2> {log}
        """

# rule map_salmon_repeats_chromium:
#     input:


# from https://gist.github.com/k3yavi/c501705ed2d29b12b0d10cf78b3ed001
## and https://github.com/COMBINE-lab/salmon/issues/336 to get the `attribute` instead of
##   the group
rule get_txp2gene_gene:
    input:
        genes_gtf = op.join(BASE, 'annotation', op.basename(GENES_GTF_URL))
    output:
        op.join(BASE, 'indices', 'salmon', GENOME, 'genes_salmon', 'txp2gene.tsv')
    shell:
         """
         {PIGZ} --decompress -p {threads} -c {input.genes_gtf} | \
           grep transcript | awk '{{print $12,$10}}' | sed -e 's|"||g' -e 's|;||g' | uniq > {output}
         """

## untested @todo check
rule get_txp2gene_repeat:
    input:
        repeats_gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL))
    output:
        op.join(BASE, 'indices', 'salmon', GENOME, 'repeats_salmon', 'txp2gene.tsv')
    params:
        path = op.join(BASE, 'indices', 'salmon', GENOME, 'repeats_salmon')
    shell:
        """
        mkdir -p {params.path}
        
        {PIGZ} --decompress -p {threads} -c {input.repeats_gtf} | grep transcript | \
        awk '{{print $12,$10}}' | sed -e 's|"||g' -e 's|;||g' | uniq > {output}
        """

                
## samon end


rule profile_featurecounts_run_repeats:
    input:        
        summary = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard',
                          "{multimappers}",
                          RUN_NAME + "_repeats.counts.summary")
    params:
        path = op.join(BASE, "runs", RUN_NAME, "count_repeats_on_cellranger_standard",
                       "{multimappers}"),
        script = FEATURECOUNTS_RSCRIPT,
        gtf = 'cellranger_repeats'
    output:
        png = op.join(BASE, "runs", RUN_NAME, "count_repeats_on_cellranger_standard",
                      "{multimappers}",
                      RUN_NAME + "_transcriptome_repeats.counts.summary.png")
    threads: 1
    shell:
       """
       cd {params.path}
       
       {Rscript} {params.script} --summary {input.summary} --output {output.png} \
           --identifier {params.gtf}
       """

## potentially broken, multimappers wildcard missing
rule profile_featurecounts_run_repeats_not_genes:
    input:        
        summary = op.join(BASE, "runs", RUN_NAME,
                          'count_repeats_on_cellranger_standard_not_overlapping_genes',
                          "{multimappers}",
                          RUN_NAME + "_repeats_not_overlapping_genes.counts.summary")
    params:
        path = op.join(BASE, "runs", RUN_NAME,                       
                       "count_repeats_on_cellranger_standard_not_overlapping_genes",
                       "{multimappers}"),
        script = FEATURECOUNTS_RSCRIPT,
        gtf = 'cellranger_repeats_not_genes'
    output:
        png = op.join(BASE, "runs", RUN_NAME,
                      "count_repeats_on_cellranger_standard_not_overlapping_genes",
                      "{multimappers}",
                      RUN_NAME + "_transcriptome_repeats_not_genes.counts.summary.png")
    threads: 1
    shell:
       """
       cd {params.path}
       
       {Rscript} {params.script} --summary {input.summary} --output {output.png} \
          --identifier {params.gtf}
       """    

       
# rule knit_report_alevin:
#     input:
#         genes =  op.join(BASE, 'runs', RUN_NAME, 'alevin', 'genes', 'alevin', 'quants_mat.gz'),
#         repeats = op.join(BASE, 'runs', RUN_NAME, 'alevin', 'repeats', 'alevin', 'quants_mat.gz')
#     params:
#         rmd = 'summarize_alevin_run_pbmcs.Rmd',
#         run_name = RUN_NAME
#     output:
#         html = op.join(BASE, 'runs', RUN_NAME, RUN_NAME + '_pbmc_alevin_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.html'),
#         rds = op.join(BASE, 'runs', RUN_NAME, RUN_NAME + '_pmbc_alevin_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.rds'),
#         aris = op.join(BASE, 'runs', RUN_NAME, RUN_NAME + '_aris_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.rds'),
#         markers = op.join(BASE, 'runs', RUN_NAME, RUN_NAME + '_markers_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.rds')    
#     log:
#         op.join(BASE, 'runs', RUN_NAME, RUN_NAME + 'summarize_alevin_run_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.log')
#     shell: """
#         {Rscript} -e 'rmarkdown::render(\"{params.rmd}\", 
#            output_file = \"{output.html}\", 
#            params = list(identifier = \"{params.run_name}\", 
#                          genes_alevin = \"{input.genes}\", 
#                          repeats_alevin = \"{input.repeats}\", 
#                          seurat_output = \"{output.rds}\", 
#                          aris_output = \"{output.aris}\", 
#                          markers_output = \"{output.markers}\", 
#                          regress_genes_nCount = \"{wildcards.regress_ncount}\", 
#                          regress_genes_nFeature = \"{wildcards.regress_nfeature}\"))' &> {log}
#         """




rule knit_report_chromium_agnostic:
    input:
        genes = op.join(BASE, 'runs', RUN_NAME, 'cellranger_standard', 'outs', 'filtered_feature_bc_matrix', 'barcodes.tsv.gz'),
        repeats = op.join(BASE, 'runs', RUN_NAME, 'cellranger_repeats', 'outs', 'filtered_feature_bc_matrix', 'barcodes.tsv.gz'),
        featurecounts_multi = op.join(BASE, "runs", RUN_NAME,
                                      'count_repeats_on_cellranger_standard',
                                      'multimappers',
                                      RUN_NAME + "_repeats.counts.gz"),
        featurecounts_unique = op.join(BASE, "runs", RUN_NAME,
                                      'count_repeats_on_cellranger_standard',
                                      'unique_reads',
                                      RUN_NAME + "_repeats.counts.gz"),
        repeats_only_featurecounts_control_multi = op.join(
            BASE, "runs", RUN_NAME,
            'count_repeats_on_cellranger_standard_not_overlapping_genes',
            'multimappers',
            RUN_NAME + "_repeats_not_overlapping_genes.counts.gz"),
        repeats_only_featurecounts_control_unique = op.join(
            BASE, "runs", RUN_NAME,
            'count_repeats_on_cellranger_standard_not_overlapping_genes',
            'unique_reads',
            RUN_NAME + "_repeats_not_overlapping_genes.counts.gz"),
        repeats_bowtie_multi = op.join(
            BASE, "runs", RUN_NAME,
            'bowtie_repeatome',
            'multimappers',
            'all_cells_repeats.counts.gz'),
        repeats_bowtie_unique = op.join(
            BASE, "runs", RUN_NAME,
            'bowtie_repeatome',
            'unique_reads',
            'all_cells_repeats.counts.gz'),
        genes_alevin = op.join(BASE, 'runs', RUN_NAME, 'alevin', 'genes', 'alevin',
                               'quants_mat.gz'),
        repeats_alevin = op.join(BASE, 'runs', RUN_NAME, 'alevin', 'repeats', 'alevin',
                                 'quants_mat.gz')
        
            
    params:
        rmd = 'summarize_chromium_run_markers_agnostic.Rmd',
        run_name = RUN_NAME
    output:
        html = op.join(BASE, 'runs', RUN_NAME, RUN_NAME + '_chromium_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.html'),
        rds = op.join(BASE, 'runs', RUN_NAME, RUN_NAME + '_chromium_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.rds'),
        aris = op.join(BASE, 'runs', RUN_NAME, RUN_NAME + '_aris_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.rds')
    log:
        op.join(BASE, 'runs', RUN_NAME, RUN_NAME + 'summarize_chromium_run_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.log')
    shell: """
        {Rscript} -e 'rmarkdown::render(\"{params.rmd}\", 
          output_file = \"{output.html}\", 
          params = list(identifier = \"{params.run_name}\", 
                     genes_cellranger = \"{input.genes}\", 
                     repeats_cellranger = \"{input.repeats}\", 
                     repeats_featurecounts_multi = \"{input.featurecounts_multi}\", 
                     repeats_featurecounts_unique = \"{input.featurecounts_unique}\",
                     repeats_only_featurecounts_control_multi = \"{input.repeats_only_featurecounts_control_multi}\", 
                     repeats_only_featurecounts_control_unique = \"{input.repeats_only_featurecounts_control_unique}\",
                     seurat_output = \"{output.rds}\", 
                     aris_output = \"{output.aris}\", 
                     regress_genes_nCount = \"{wildcards.regress_ncount}\", 
                     regress_genes_nFeature = \"{wildcards.regress_nfeature}\",
                     repeats_bowtie_multi = \"{input.repeats_bowtie_multi}\",
                     repeats_bowtie_unique = \"{input.repeats_bowtie_unique}\", 
                     genes_alevin = \"{input.genes_alevin}\",
                     repeats_alevin = \"{input.repeats_alevin}\"))' &> {log}
        """
    
rule knit_report_chromium:
    input:
        genes = op.join(BASE, 'runs', RUN_NAME, 'cellranger_standard', 'outs', 'filtered_feature_bc_matrix', 'barcodes.tsv.gz'),
        repeats = op.join(BASE, 'runs', RUN_NAME, 'cellranger_repeats', 'outs', 'filtered_feature_bc_matrix', 'barcodes.tsv.gz'),
        featurecounts_multi = op.join(BASE, "runs", RUN_NAME,
                                      'count_repeats_on_cellranger_standard',
                                      'multimappers',
                                      RUN_NAME + "_repeats.counts.gz"),
        featurecounts_unique = op.join(BASE, "runs", RUN_NAME,
                                      'count_repeats_on_cellranger_standard',
                                      'unique_reads',
                                      RUN_NAME + "_repeats.counts.gz"),
        repeats_only_featurecounts_control_multi = op.join(
            BASE, "runs", RUN_NAME,
            'count_repeats_on_cellranger_standard_not_overlapping_genes',
            'multimappers',
            RUN_NAME + "_repeats_not_overlapping_genes.counts.gz"),
        repeats_only_featurecounts_control_unique = op.join(
            BASE, "runs", RUN_NAME,
            'count_repeats_on_cellranger_standard_not_overlapping_genes',
            'unique_reads',
            RUN_NAME + "_repeats_not_overlapping_genes.counts.gz"),
        repeats_bowtie_multi = op.join(
            BASE, "runs", RUN_NAME,
            'bowtie_repeatome',
            'multimappers',
            'all_cells_repeats.counts.gz'),
        repeats_bowtie_unique = op.join(
            BASE, "runs", RUN_NAME,
            'bowtie_repeatome',
            'unique_reads',
            'all_cells_repeats.counts.gz'),
        genes_alevin = op.join(BASE, 'runs', RUN_NAME, 'alevin', 'genes', 'alevin',
                               'quants_mat.gz'),
        repeats_alevin = op.join(BASE, 'runs', RUN_NAME, 'alevin', 'repeats', 'alevin',
                                 'quants_mat.gz')
        
            
    params:
        rmd = 'summarize_chromium_run_pbmcs.Rmd',
        run_name = RUN_NAME
    output:
        html = op.join(BASE, 'runs', RUN_NAME, RUN_NAME + '_pbmc_chromium_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.html'),
        rds = op.join(BASE, 'runs', RUN_NAME, RUN_NAME + '_pmbc_chromium_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.rds'),
        aris = op.join(BASE, 'runs', RUN_NAME, RUN_NAME + '_aris_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.rds'),
        cobra = op.join(BASE, 'runs', RUN_NAME, RUN_NAME + '_cobra_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.rds'),
        markers = op.join(BASE, 'runs', RUN_NAME, RUN_NAME + '_markers_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.rds')
    log:
        op.join(BASE, 'runs', RUN_NAME, RUN_NAME + 'summarize_chromium_run_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.log')
    shell: """
        {Rscript} -e 'rmarkdown::render(\"{params.rmd}\", 
          output_file = \"{output.html}\", 
          params = list(identifier = \"{params.run_name}\", 
                     genes_cellranger = \"{input.genes}\", 
                     repeats_cellranger = \"{input.repeats}\", 
                     markers_output = \"{output.markers}\", 
                     repeats_featurecounts_multi = \"{input.featurecounts_multi}\", 
                     repeats_featurecounts_unique = \"{input.featurecounts_unique}\",
                     repeats_only_featurecounts_control_multi = \"{input.repeats_only_featurecounts_control_multi}\", 
                     repeats_only_featurecounts_control_unique = \"{input.repeats_only_featurecounts_control_unique}\",
                     seurat_output = \"{output.rds}\", 
                     aris_output = \"{output.aris}\", 
                     regress_genes_nCount = \"{wildcards.regress_ncount}\", 
                     regress_genes_nFeature = \"{wildcards.regress_nfeature}\",
                     repeats_bowtie_multi = \"{input.repeats_bowtie_multi}\",
                     repeats_bowtie_unique = \"{input.repeats_bowtie_unique}\", 
                     genes_alevin = \"{input.genes_alevin}\",
                     repeats_alevin = \"{input.repeats_alevin}\",
                     cobra_output = \"{output.cobra}\"))' &> {log}
        """

# rule knit_report_chromium_genes_regressed_out:
#     input:
#         genes = op.join(BASE, 'runs', RUN_NAME, 'cellranger_standard', 'outs', 'filtered_feature_bc_matrix', 'barcodes.tsv.gz'),
#         repeats = op.join(BASE, 'runs', RUN_NAME, 'cellranger_repeats', 'outs', 'filtered_feature_bc_matrix', 'barcodes.tsv.gz'),
#         featurecounts = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard',
#                                 RUN_NAME + "_repeats.counts.gz")
#     params:
#         rmd = 'summarize_cellranger_run_with_genes_regressed_out.Rmd',
#         run_name = RUN_NAME
#     output:
#         html = op.join(BASE, 'runs', RUN_NAME, 'summarize_cellranger_run_report_genes_regressed_out.html'),
#         rds = op.join(BASE, 'runs', RUN_NAME, 'summarize_cellranger_run_genes_regressed_out.rds'),
#         aris = op.join(BASE, 'runs', RUN_NAME, 'aris.rds')
#     log:
#         op.join(BASE, 'runs', RUN_NAME, 'knit_report_genes_regressed_out.log')
#     shell:
#         """
#         {Rscript} -e 'rmarkdown::render(\"{params.rmd}\", output_file = \"{output.html}\", params = list(identifier = \"{params.run_name}\", genes_cellranger = \"{input.genes}\", repeats_cellranger = \"{input.repeats}\", repeats_featurecounts = \"{input.featurecounts}\", seurat_output = \"{output.rds}\", aris_output = \"{output.aris}\"))' &> {log}
#         """

rule run_featurecounts_spawned_bams:
    input:
        flag = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'split.flag'),
        gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL))
    params:
        path = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'split')        
    output:
        counts  = temp(op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard',
                               '{multimappers}',
                               RUN_NAME + "_repeats.counts")),
        gz_counts = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard',
                            '{multimappers}',
                            RUN_NAME + "_repeats.counts.gz"),
        summary = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard',
                          '{multimappers}',
                            RUN_NAME + "_repeats.counts.summary")
    log :
        log = op.join(BASE, "runs",  RUN_NAME, 'count_repeats_on_cellranger_standard',
                      '{multimappers}',                      
                      'feature_counts.log'),
    threads:
        NTHREADS
    # shell: """
    # cd {params.path}

    # {FEATURECOUNTS} -T {threads} \
    # -t exon \
    # -g gene_id \
    # -a {input.gtf} \
    # -o  {output.counts} \
    # {params.path}/*bam  2>&1 > {log}

    # {PIGZ} --keep -p {threads} {output.counts}
    # """
    run:
        if wildcards.multimappers == 'multimappers':
            shell("""
            echo multimappers allowed

            cd {params.path}

            {FEATURECOUNTS} -T {threads} \
            -t exon \
            -g gene_id \
            -a {input.gtf} \
            -o  {output.counts} \
            -M \
            --fraction \
            {params.path}/*bam  2>&1 > {log}

            {PIGZ} -f --keep -p {threads} {output.counts} -c > {output.gz_counts}

            """)
        elif wildcards.multimappers == 'unique_reads':
            shell("""
            echo unique only

            cd {params.path}

            {FEATURECOUNTS} -T {threads} \
            -t exon \
            -g gene_id \
            -a {input.gtf} \
            -o  {output.counts} \
            {params.path}/*bam  2>&1 > {log}

            {PIGZ} -f --keep -p {threads} {output.counts} -c > {output.gz_counts}
            """)

rule run_feature_counts_repeats_not_overlapping_genes_spawned_bams:
    input:
        flag = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'split.flag'),
        gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL) + '_minus_' + op.basename(GENES_GTF_URL))
    params:
        path = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'split')
    output:
        counts  = temp(op.join(BASE, "runs", RUN_NAME,
                               'count_repeats_on_cellranger_standard_not_overlapping_genes',
                               '{multimappers}',
                               RUN_NAME + "_repeats_not_overlapping_genes.counts")),
        gz_counts = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard_not_overlapping_genes',
                            '{multimappers}',
                            RUN_NAME + "_repeats_not_overlapping_genes.counts.gz"),
        summary = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard_not_overlapping_genes',
                          '{multimappers}',
                           RUN_NAME + "_repeats_not_overlapping_genes.counts.summary")
    log :
        log = op.join(BASE, "runs",  RUN_NAME, 'count_repeats_on_cellranger_standard_not_overlapping_genes',
                      '{multimappers}'
                      'feature_counts_not_overlapping_genes.log'),
    threads:
        NTHREADS
    # shell: """
    # cd {params.path}

    # {FEATURECOUNTS} -T {threads} \
    # -t exon \
    # -g gene_id \
    # -a {input.gtf} \
    # -o  {output.counts} \
    # {params.path}/*bam  2>&1 > {log}

    # {PIGZ} --keep -p {threads} {output.counts}
    # """
    run:
        if wildcards.multimappers == 'multimappers':
            shell("""
            echo multimappers allowed

            cd {params.path}

            {FEATURECOUNTS} -T {threads} \
            -t exon \
            -g gene_id \
            -a {input.gtf} \
            -o  {output.counts} \
            -M \
            --fraction \
            {params.path}/*bam  2>&1 > {log}

            {PIGZ} -f --keep -p {threads} {output.counts} -c > {output.gz_counts}

            """)
        elif wildcards.multimappers == 'unique_reads':
            shell("""
            echo unique only

            cd {params.path}

            {FEATURECOUNTS} -T {threads} \
            -t exon \
            -g gene_id \
            -a {input.gtf} \
            -o  {output.counts} \
            {params.path}/*bam  2>&1 > {log}

            {PIGZ} -f --keep -p {threads} {output.counts} -c > {output.gz_counts}
            """)
        
    
## test run bowtie start
## to avoid explicitly handling the cell barcodes, we take the cellranger output as correct
##   (e.g. splitting the cells by CB from the cellranger standard output)
rule map_bowtie_by_cell:
    input:
        flag = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'split.flag')
    output:
        flag_map_bowtie =  op.join(BASE, "runs", RUN_NAME, 'bowtie_repeatome', 'split_bowtie.flag')
    params:
        split_bam_path = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'split'),
        split_fastq_path = op.join(BASE, "runs", RUN_NAME, 'bowtie_repeatome'),
        repeatome = op.join(BASE, 'indices', 'bowtie', GENOME, 'repeatome', op.splitext(op.basename(REP_GTF_URL))[0])
    threads:
        NTHREADS
    shell:
        """
        mkdir -p {params.split_fastq_path}
        cd {params.split_fastq_path}

        for fn in $(find {params.split_bam_path} -name "*bam")
        do
           echo "$fn"
           
           {BEDTOOLS} bamtofastq -i "$fn" -fq "$(basename $fn .bam).fastq"
        
           ( {BOWTIE} -q \
            -v 2 \
            --threads {threads} \
            -a -k 10 --best --strata \
            --sam \
            --chunkmbs 128 {params.repeatome} "$(basename $fn .bam).fastq" | \
              samtools view -@ {threads} -bS - > "$(basename $fn .bam)_bowtie.bam" ) 2> \
              "$(basename $fn .bam)_bowtie.log"

            ## removing the fastq
            rm "$fn"
        done

        touch {output.flag_map_bowtie}
        """


# rule featurecounts_bowtie_repeats_repeatome:
#     input:
#         # bam = op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome", "{fastq}.bam"),
#         flag_map_bowtie =  op.join(BASE, "runs", RUN_NAME, 'bowtie_repeatome', 'split_bowtie.flag'),
#         gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL)),
#         fake_repeatome_gtf = op.join(BASE, 'annotation', 'fake_repeatome_from_' + op.splitext(op.basename(REP_GTF_URL))[0]) + '.gtf.gz'
#     output:
#         counts  = temp(op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome", "{multimappers}",
#                                "all_cells_repeats.counts")),
#         gz_counts = op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome", "{multimappers}",
#                             "all_cells_repeats.counts.gz")
#     params:
#         bam_path = op.join(BASE, "runs", RUN_NAME, 'bowtie_repeatome'),
#         processing_path = op.join(BASE, "runs", RUN_NAME, "{multimappers}", 'bowtie_repeatome')
#     log :
#         op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome", "{multimappers}", "all_cell_featurecounts.log"),
#     threads:
#         NTHREADS
#     # shell:
#     #    """
#     #    ## note multimappers are counted

#     #    mkdir -p {params.processing_path}

#     #    cd {params.processing_path}
       
#     #    {FEATURECOUNTS} -T {threads} \
#     #    -t exon \
#     #    -g gene_id \
#     #    -a {input.fake_repeatome_gtf} \
#     #    -o  {output.counts} \
#     #    -M \
#     #    {params.bam_path}/*bam  &> {log}

#     #    {PIGZ} --keep  -p {threads} {output.counts}
#     #    """
#     run:
#         if wildcards.multimappers == 'multimappers':
#             shell("""
#             echo multimappers allowed

#             mkdir -p {params.processing_path}

#             cd {params.processing_path}
            
#             {FEATURECOUNTS} -T {threads} \
#             -t exon \
#             -g gene_id \
#             -a {input.fake_repeatome_gtf} \
#             -o  {output.counts} \
#             -M --fraction \
#             {params.bam_path}/*bam  &> {log}

#             {PIGZ} --keep  -p {threads} {output.counts}
#          """)
#         elif wildcards.multimappers == 'unique_reads':
#             shell("""
#             echo unique only

#             mkdir -p {params.processing_path}

#             cd {params.processing_path}
            
#             {FEATURECOUNTS} -T {threads} \
#             -t exon \
#             -g gene_id \
#             -a {input.fake_repeatome_gtf} \
#             -o  {output.counts} \
#             {params.bam_path}/*bam  &> {log}

#             {PIGZ} --keep  -p {threads} {output.counts}

#             """)


# def list_bowtie_bams(wildcards):
#     return expand(op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome", "{multimappers}",
#                           "{bam}.bam"),
#                   multimappers = wildcards.multimappers,
#                   bam = glob_wildcards(op.join(BASE, "runs", RUN_NAME,
#                                                "bowtie_repeatome", "{bam}.bam")))
#     # return glob(op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome","*.bam"))

# print(list_bowtie_bams(wildcards))

rule featurecounts_bowtie_repeats_repeatome_per_bam:
    input:
        # bam = op.join(BASE, "runs", RUN_NAME,
        #               "bowtie_repeatome",
        #                      "{bam}.bam"),
        # bam = "{bam}.bam",
        flag_map_bowtie =  op.join(BASE, "runs", RUN_NAME, 'bowtie_repeatome', 'split_bowtie.flag'),
        gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL)),
        fake_repeatome_gtf = op.join(BASE, 'annotation', 'fake_repeatome_from_' + op.splitext(op.basename(REP_GTF_URL))[0]) + '.gtf.gz'
    output:
        # counts  = temp(op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome", "{multimappers}",
        #                        "{bam}_repeats.counts")),
        # gz_counts = op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome", "{multimappers}",
        #                     "{bam}_repeats.counts.gz")
        flag_loop_featurecounts = op.join(BASE, "runs", RUN_NAME, 'bowtie_repeatome',
                                          "{multimappers}",
                                          'featurecounts_loop.flag')
    params:
        bam_path = op.join(BASE, "runs", RUN_NAME, 'bowtie_repeatome'),
        processing_path = op.join(BASE, "runs", RUN_NAME,  'bowtie_repeatome', "{multimappers}")
    log :
        op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome", "{multimappers}",
                "featurecounts_loop.log"),
    threads:
        NTHREADS
    run:
        if wildcards.multimappers == 'multimappers': 
           shell("""

            echo multimappers allowed

           for fn in $(find {params.bam_path} -name "*bam")
           do
              echo "$fn"

              mkdir -p {params.processing_path}

              cd {params.processing_path}
            
              {FEATURECOUNTS} -T {threads} \
              -t exon \
              -g gene_id \
              -a {input.fake_repeatome_gtf} \
              -o "$(basename $fn).counts"  \
              -M --fraction \
              {params.bam_path}/"$(basename $fn)"  &>> {log}

              {PIGZ} --keep  -p {threads} "$(basename $fn).counts"
           done
           
           touch {output.flag_loop_featurecounts}
            """)
        elif wildcards.multimappers == 'unique_reads':
            shell("""
            echo unique only
 
           for fn in $(find {params.bam_path} -name "*bam")
           do
              echo "$fn"
              mkdir -p {params.processing_path}

              cd {params.processing_path}
            
              {FEATURECOUNTS} -T {threads} \
              -t exon \
              -g gene_id \
              -a {input.fake_repeatome_gtf} \
              -o  "$(basename $fn).counts"  \
              {params.bam_path}/"$basename $fn"  &>> {log}
  
              {PIGZ} --keep  -p {threads} "$(basename $fn).counts" 
            done
           touch {output.flag_loop_featurecounts}
            """)


# def aggregate_bowtie_featurecounts(wildcards):
#     return expand(op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome", "{multimappers}",
#                                    "{bam}_repeats.counts.part.gz"),
#                   multimappers = wildcards.multimappers,
#                   bam = glob_wildcards(op.join(BASE, "runs", RUN_NAME,
#                                                 "bowtie_repeatome",
#                                                 "{bam}.bam")))
#     # return  glob(op.join(BASE, "runs", RUN_NAME,
#     #                                "bowtie_repeatome", "{wildcards.multimappers}",
#     #                                "*_repeats.counts.gz"))

rule aggregate_featurecounts_bowtie_repeats_repeatome:
    input:
        # # count_per_cell = aggregate_bowtie_featurecounts
        # expand(op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome", "{multimappers}",
        #                             "{bam}_repeats.counts.gz"),
        #            multimappers = ['multimappers', 'unique_reads'],
        #            bam = [op.splitext(op.basename(item))[0] for item in glob(op.join(BASE, "runs", RUN_NAME,
        #                                          "bowtie_repeatome",
        #                                          "*.bam"))])
        flag_loop_featurecounts = op.join(BASE, "runs", RUN_NAME, 'bowtie_repeatome',
                                          "multimappers",
                                          'featurecounts_loop.flag')
    output:
        counts  = temp(op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome", "{multimappers}",
                               "all_cells_repeats.counts")),
        gz_counts = op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome", "{multimappers}",
                            "all_cells_repeats.counts.gz")
    params:
        counts_path = op.join(BASE, "runs", RUN_NAME, 'bowtie_repeatome', "{multimappers}"),
        processing_path = op.join(BASE, "runs", RUN_NAME, 'bowtie_repeatome', "{multimappers}")
    log :
        op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome", "{multimappers}", "all_cell_featurecounts.log")
    run:
        if wildcards.multimappers == 'multimappers':
            shell("""
            echo multimappers allowed
            ls -1  {params.counts_path}.counts.txt.gz | parallel 'zcat {} | sed '1d' | cut -f7 {} > {/.}_clean.txt' 
            ls -1   {params.counts_path}.counts.txt.gz | zcat | head -1 | xargs cut -f1 > genes.txt
            paste genes.txt *_clean.txt > {output.counts}
            rm genes.txt
            rm *clean.txt

            {PIGZ} --keep  -p {threads} "$(basename $fn).counts"

            """)
        elif wildcards.multimappers == 'unique_reads':
            shell("""
            echo multimappers allowed
            ls -1  {params.counts_path}.counts.txt.gz | parallel 'zcat {} | sed '1d' | cut -f7 {} > {/.}_clean.txt' 
            ls -1   {params.counts_path}.counts.txt.gz | zcat | head -1 | xargs cut -f1 > genes.txt
            paste genes.txt *_clean.txt > {output.counts}
            rm genes.txt
            rm *clean.txt

            {PIGZ} --keep  -p {threads} "$(basename $fn).counts"
            """)

            
## test run bowtie end

rule spawn_cellranger_bam_file_by_cell:
    input:
        bam = op.join(BASE, 'runs', RUN_NAME, 'cellranger_standard', 'outs', 'possorted_genome_bam.bam'),
        barcodes = op.join(BASE, 'runs', RUN_NAME, 'cellranger_standard', 'outs', 'filtered_feature_bc_matrix', 'barcodes.tsv.gz')
    output:
        rgs = temp(op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'rgs.txt')),
        header = temp(op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'header.txt')),
        body = temp(op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'body.txt.gz')),
        shortened_bam = temp(op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'shortened.bam')),
        flag = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'split.flag'),
        path = directory(op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'split'))
    threads:
        NTHREADS
    params:
        barcodes_script = 'get_cell_barcodes.py',
        split_script = 'split_by_cell_barcode_in_sorted_bam.py',
        split_path = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'split')
    log:
        log1 = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'split_add_rg.log'),
        log2 = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'split_pick.log'),
    shell:
        """
        mkdir -p {output.path}
        
        # python3 {params.barcodes_script} {input.bam} | {PIGZ} -p {threads} > {output.rgs}

        python3 {params.barcodes_script} {input.bam}  > {output.rgs}

        samtools view -@ {threads} -H {input.bam} > {output.header}

        # ## buffer size in sort due to https://superuser.com/questions/938558/sort-parallel-isnt-parallelizing
        # ( samtools view -@ {threads} {input.bam} | cut -f 1-15 | \
        # paste - {output.rgs} | \
        #   sed 's/\t$//' | sort -S1G --parallel={threads} -k16 | {PIGZ} -p {threads} --keep --stdout > {output.body} ) &> {log.log1}
        ## updated 2 oct to handle SRR8847571
        ( samtools view -@ {threads} {input.bam} | cut -f 1-15 | \
        paste - {output.rgs} | \
          fgrep "RG:Z" | \
          sed 's/\t$//' | sort -S1G --parallel={threads} -k16 | {PIGZ} -p {threads} --keep --stdout > {output.body} ) &> {log.log1}


        {PIGZ} --decompress -p {threads} --keep --stdout {output.body} | cat {output.header} - | samtools view -@ {threads} -Sb - > {output.shortened_bam}
        
        python3 split_by_cell_barcode_in_sorted_bam.py {output.shortened_bam} -outdir {params.split_path} -barcodes {input.barcodes} &> {log.log2}

        touch {output.flag}

        """


# rule run_cellranger_standard:
#     input:
#         flag_fastq = op.join(BASE, 'data', RUN_NAME, 'read-RA_si-TATTGGTG_lane-004-chunk-002.fastq.gz'),
#         transcriptome = op.join(BASE, 'indices', 'cellranger', 'refdata-cellranger-GRCh38-3.0.0')
#     params:
#         fastqs_path = op.join(BASE, 'data', RUN_NAME),
#         sample_name = RUN_NAME,
#         local_mem_gb = LOCAL_MEM_GB,
#         processing_path = op.join(BASE, 'runs', RUN_NAME),
#         chemistry = CHEMISTRY
#     output:
#         op.join(BASE, 'runs', RUN_NAME, 'cellranger_standard', 'outs', 'web_summary.html'),
#         op.join(BASE, 'runs', RUN_NAME, 'cellranger_standard', 'outs', 'possorted_genome_bam.bam'),
#         op.join(BASE, 'runs', RUN_NAME, 'cellranger_standard', 'outs', 'filtered_feature_bc_matrix', 'barcodes.tsv.gz')
#     threads:
#         NTHREADS
#     log:
#         op.join(BASE, 'runs',  RUN_NAME, 'run_cellranger_standard.log')
#     run:
#         if DEMUX:
#             shell("""
#             mkdir -p {params.processing_path}
#             cd {params.processing_path}
#             rm -rf cellranger_standard

#             {CELLRANGER} count --id=cellranger_standard \
#             --fastqs={params.fastqs_path} \
#             --transcriptome={input.transcriptome} \
#             --jobmode=local \
#             --localcores={threads} \
#             --localmem={params.local_mem_gb} \
#             --chemistry={params.chemistry}
#             """)
#         else:
#             shell("""
#             mkdir -p {params.processing_path}
#             cd {params.processing_path}
#             rm -rf cellranger_standard

#             {CELLRANGER} count --id=cellranger_standard \
#             --fastqs={params.fastqs_path} \
#             --transcriptome={input.transcriptome} \
#             --jobmode=local \
#             --localcores={threads} \
#             --sample={params.sample_name} \
#             --localmem={params.local_mem_gb} \
#             --chemistry={params.chemistry}
#             """)
            

# rule run_cellranger_repeats:
#     input:
#         transcriptome = op.join(BASE, 'indices', 'cellranger', 'repeats_hg38', 'repeats_hg38')
#     params:
#         fastqs_path = op.join(BASE, 'data', RUN_NAME),
#         sample_name = RUN_NAME,
#         local_mem_gb = LOCAL_MEM_GB,
#         processing_path = op.join(BASE, 'runs', RUN_NAME),
#         chemistry = CHEMISTRY
#     output:
#         op.join(BASE, 'runs', RUN_NAME, 'cellranger_repeats', 'outs', 'web_summary.html'),
#         op.join(BASE, 'runs', RUN_NAME, 'cellranger_repeats', 'outs', 'filtered_feature_bc_matrix', 'barcodes.tsv.gz')
#     threads:
#         NTHREADS
#     log:
#         op.join(BASE, 'runs', RUN_NAME, 'run_cellranger_repeats.log')
#     run:
#         if DEMUX:
#             shell("""
#         mkdir -p {params.processing_path}
#         cd {params.processing_path}
#         rm -rf cellranger_repeats

#         {CELLRANGER} count --id=cellranger_repeats \
#           --fastqs={params.fastqs_path} \
#           --transcriptome={input.transcriptome} \
#           --jobmode=local \
#           --localcores={threads} \
#           --localmem={params.local_mem_gb} \
#           --chemistry={params.chemistry} \
#             """)
#         else:
#             shell("""
#         mkdir -p {params.processing_path}
#         cd {params.processing_path}
#         rm -rf cellranger_repeats

#         {CELLRANGER} count --id=cellranger_repeats \
#           --fastqs={params.fastqs_path} \
#           --transcriptome={input.transcriptome} \
#           --jobmode=local \
#           --localcores={threads} \
#           --sample={params.sample_name} \
#           --localmem={params.local_mem_gb} \
#           --chemistry={params.chemistry}
#         """)
        

## Indexing start ----------------------------------------------------------------------------- ##        

rule index_cellranger_repeats:
    input:
       compressed_fa = op.join(BASE, 'annotation', op.basename(GENOME_URL)),
       compressed_gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL))
    params:
       local_mem_gb = LOCAL_MEM_GB,
       path =  op.join(BASE, 'indices', 'cellranger', 'repeats_' + GENOME),
       genome = 'repeats_' + GENOME
    threads:
        NTHREADS
    output:
        uncompressed_gtf = temp(op.join(BASE, 'annotation', op.splitext(op.basename(REP_GTF_URL))[0])),
        flag = op.join(BASE, 'indices', 'cellranger', 'repeats_' + GENOME, 'Log.out'),
        uncompressed_fa = temp(op.join(BASE, 'annotation', op.splitext(op.basename(GENOME_URL))[0])),
        idx = op.join(BASE, 'indices', 'cellranger', 'repeats_' + GENOME,'repeats_' + GENOME)
    shell:
       """ 
       mkdir -p {params.path}
       cd {params.path}
 
       {PIGZ} --decompress  -p {threads} --keep -c {input.compressed_fa} > \
        {output.uncompressed_fa}

       {PIGZ} --decompress  -p {threads} --keep -c {input.compressed_gtf} > \
         {output.uncompressed_gtf}
       
       {CELLRANGER} mkref --genome {params.genome} \
       --fasta {output.uncompressed_fa} \
       --genes {output.uncompressed_gtf} \
       --nthreads {threads} \
       --memgb {params.local_mem_gb} 

       touch {output.flag}
       """

## use this! @todo
rule get_repeats_not_overlapping_genes_gtf:
    input:
        repeats_gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL)),
        genes_gtf =  op.join(BASE, 'annotation', op.basename(GENES_GTF_URL))
    output:
        gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL) + '_minus_' + op.basename(GENES_GTF_URL)),
        repeats_gtf_decomp = temp(op.join(BASE, 'annotation', op.basename(REP_GTF_URL)) + '.tmp.gtf'),
        genes_gtf_decomp =  temp(op.join(BASE, 'annotation', op.basename(GENES_GTF_URL)) + '.tmp.gtf'),
        genesbed = temp(op.join(BASE, 'annotation', op.basename(GENES_GTF_URL)) + '.tmp.bed')
    params:
        threads = NTHREADS,
        bedops_path='~/soft/bedops/bedops-2.4.39/bin/'
    shell:
        """
        ## this ends with a premature end of file (?)
        # {BEDOPS} --difference {input.repeats_gtf} {input.genes_gtf} > {output}


        ## this doesn't neither start

        {PIGZ} --decompress --keep --stdout  {input.repeats_gtf} | \
               sed 's/chr//g' > {output.repeats_gtf_decomp}
        {PIGZ} --decompress --keep  --stdout  {input.genes_gtf} | \
               sed 's/chr//g' > {output.genes_gtf_decomp}
               
        # {BEDOPS} --difference {output.repeats_gtf_decomp} {output.genes_gtf_decomp} | 
        #        {PIGZ} --stdout > {output.gtf}

        ## this doesn't neither end

        # let's transform genes in bed and then use bedtools
        export PATH={params.bedops_path}:$PATH

        awk '{{ if ($0 ~ "transcript_id") print $0; else print $0" transcript_id "";"; }}' \
           {output.genes_gtf_decomp} | gtf2bed - > {output.genesbed}

        {BEDTOOLS} intersect -a {output.repeats_gtf_decomp} \
          -b {output.genesbed} \
          -v | {PIGZ} --stdout > {output.gtf}
        """
        
rule extract_repeatome_from_gtf:
    priority: 100
    input:
        genome = op.join(BASE, 'annotation', op.basename(GENOME_URL)),
        gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL))
    output:
        genome_uncompressed = temp(op.join(BASE, 'annotation', op.splitext(op.basename(GENOME_URL))[0])) + '.temp_extract',
        fai = temp(op.join(BASE, 'annotation', op.splitext(op.basename(GENOME_URL))[0])) + '.temp_extract.fai',
        fasta = temp(op.join(BASE, 'annotation', 'repeatome_from_' + op.splitext(op.basename(REP_GTF_URL))[0]) + '.fa'),
        gtftemp = op.join(BASE, 'annotation', 'temp_' + op.basename(REP_GTF_URL)),
        fastagz = op.join(BASE, 'annotation', 'repeatome_from_' + op.splitext(op.basename(REP_GTF_URL))[0]) + '.fa.gz'
    params :
        rscript = GTF_PARSING_RSCRIPT
    threads:
        NTHREADS
    shell:
        """
        {PIGZ} --keep --decompress -p {threads} -c  {input.genome} > {output.genome_uncompressed}

        ## faking the GTF to describe the instance and not the 'exon'

        {Rscript} {params.rscript} -g {input.gtf} | {PIGZ} -c -p {threads} > \
          {output.gtftemp}
        
        # {BEDTOOLS} getfasta -name -s -fi {output.fasta} \
        #   -bed {output.gtftemp} -fo {output.fasta}

        {BEDTOOLS} getfasta -name -s -fi {output.genome_uncompressed} \
          -bed {output.gtftemp} -fo {output.fasta}

        ## remove the coordinates appended by bedtools!
        sed 's/:/ /g' {output.fasta} | cut -f1 -d" " | \
          {PIGZ}  -p {threads} -c > {output.fastagz}
        
        """

## hg38 hardcoded
rule get_genome_fasta:
    priority:
        100
    output:
        op.join(BASE, 'annotation', op.basename(GENOME_URL))
    params:
        url = GENOME_URL
    shell:
        """
        curl -s -L -C - {params.url} -o {output}
        """
      
rule get_repeats_gtf:
    priority:
        100
    params:
        url = REP_GTF_URL,
        genome_path = op.join(BASE, 'annotation')
    output:
        op.join(BASE, 'annotation', op.basename(REP_GTF_URL))
    shell:
        """        
        curl -s -L -C - {params.url} -o {output}
        """
        
rule get_genes_gtf:
    priority:
        100
    params:
        url = GENES_GTF_URL
    output:
        gtf = op.join(BASE, 'annotation', op.basename(GENES_GTF_URL))
    shell:
        """    
        curl -s -L -C - {params.url} -o {output.gtf}
        """

rule get_cellranger_data:
    priority:
        100
    params:
        url = CELLRANGER_DB_URL,
        path = op.join(BASE, 'indices', 'cellranger')
    output:
        cellranger_gz = op.join(BASE, 'indices', 'cellranger', op.basename(CELLRANGER_DB_URL)),
        uncomp = op.join(BASE, 'indices', 'cellranger', CELLRANGER_DB_ID, 'reference.json')
    shell:
        """
        mkdir -p {params.path}
        cd {params.path}

        curl -s -L -C - {params.url} -o {output.cellranger_gz}
        
        tar xzvf {output.cellranger_gz}
        """

        
# ## @todo move to indices retrieval
# rule get_cellranger_grch38_genome:
#     params:
#         url = 'http://cf.10xgenomics.com/supp/cell-exp/refdata-cellranger-GRCh38-3.0.0.tar.gz'
#     output:
#         path = op.join(BASE, 'indices', 'cellranger'),
#         fn = op.join(BASE, 'indices', 'cellranger', 'refdata-cellranger-GRCh38-3.0.0.tar.gz'),
#         uncompressed = op.join(BASE, 'indices', 'cellranger', 'refdata-cellranger-GRCh38-3.0.0', 'reference.json')
#     shell:
#         """    
#         mkdir -p {output.path}
#         cd {output.path}
#         curl -s -L -C - {params.url} -O {output.fn}
#         tar xzvf {output.fn}
#         """
 
# ## @todo move to indices retrieval
# rule get_cellranger_mm10_genome:
#     params:
#         url = 'https://cf.10xgenomics.com/supp/cell-exp/refdata-gex-mm10-2020-A.tar.gz'
#     output:
#         path = op.join(BASE, 'indices', 'cellranger'),
#         fn = op.join(BASE, 'indices', 'cellranger', 'refdata-gex-mm10-2020-A.tar.gz'),
#         uncompressed = op.join(BASE, 'indices', 'cellranger', 'refdata-gex-mm10-2020-A', 'reference.json')
#     shell:
#         """    
#         mkdir -p {output.path}
#         cd {output.path}
#         curl -s -L -C - {params.url} -O {output.fn}
#         tar xzvf {output.fn}
#         """



## Genome, transcriptome and repeatome retrieval end   ---------------------------------------- ##


       
rule fake_gtf_repeatome_in_repeats_coordinates:
    input:
        fa = op.join(BASE, 'annotation', 'repeatome_from_' + op.splitext(op.basename(REP_GTF_URL))[0] + '.fa.gz')
    output:
        fai = temp(op.join(BASE, 'annotation', 'repeatome_from_' + op.splitext(op.basename(REP_GTF_URL))[0] + '.fa.fai')),
        fauncomp = temp(op.join(BASE, 'annotation', 'repeatome_from_' + op.splitext(op.basename(REP_GTF_URL))[0] + '.fa')),
        fake_repeatome_gtf = op.join(BASE, 'annotation', 'fake_repeatome_from_' + op.splitext(op.basename(REP_GTF_URL))[0]) + '.gtf.gz'
    params:
        rscript = GTF_MAKING_SCRIPT,
        path = op.join(BASE, 'annotation')
    threads:
        NTHREADS
    shell:
        """
        cd {params.path}
        {PIGZ} -k --decompress -p {threads} {input.fa}

        samtools faidx {output.fauncomp}
        
        {Rscript} {params.rscript} -f {output.fai} | {PIGZ} -c -p {threads} > {output.fake_repeatome_gtf}
        
        """
