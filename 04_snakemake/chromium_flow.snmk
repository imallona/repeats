#!/usr/bin/env snakemake -s
## 
## Started 14th Jan 2020
##
## Izaskun Mallona
## GPLv3

import os.path as op
from glob import glob


## salmon start



# https://salmon.readthedocs.io/en/latest/alevin.html
# ./bin/salmon index -t transcripts.fa -i transcripts_index --decoys decoys.txt -k 31
## shall I use a decoy? https://github.com/COMBINE-lab/SalmonTools/README.md
# apparently not
# **NOTE:** Salmon version [v1.0](https://github.com/COMBINE-lab/salmon/releases/tag/v1.0.0) can directly index the genome and transcriptome and doesn't mandates to run the `generateDecoyTranscriptome` script, however it's still backward compatible. Please checkout [this](https://combine-lab.github.io/alevin-tutorial/2019/selective-alignment/) tutorial on how to run salmon with full genome + transcriptome without the annotation.
rule index_genes_salmon_no_decoy:
    input:
        transcripts = op.join(BASE, 'annotation', op.basename(TRANSCRIPTOME_URL))
    params:
        k = 31,
        path = op.join(BASE, 'indices', 'salmon', GENOME, 'genes_salmon')
    log:
        op.join(BASE, 'indices', 'salmon', GENOME, 'genes_salmon', 'genes_salmon_index.log')
    threads:
        NTHREADS
    output:
        op.join(BASE, 'indices', 'salmon', GENOME, 'genes_salmon', 'duplicate_clusters.tsv'),
        op.join(BASE, 'indices', 'salmon', GENOME, 'genes_salmon', 'complete_ref_lens.bin')
    shell:        
        """
        mkdir -p {params.path}
        
        ({SALMON} index --gencode -p {threads} index \
           -t {input.transcripts} -i {params.path} -k {params.k})  2> {log}

        touch -c {params.path}

        """
        
rule get_transcriptome_fasta:
    priority:
        100
    output:
        tmp = temp(op.join(BASE, 'annotation', op.basename(TRANSCRIPTOME_URL) + '_temp.fa.gz')),
        tx = temp(op.join(BASE, 'annotation', op.basename(TRANSCRIPTOME_URL)))
    params:
        url = TRANSCRIPTOME_URL
    threads:
        NTHREADS
    shell:
        """
        curl -s -L -C - {params.url} -o {output.tmp}

        ## to go from
        # >ENST00000456328.2|ENSG00000223972.5|OTTHUMG0000000096 (etc)
        # to
        # >ENST00000456328.2
        {PIGZ} -p {threads} --decompress --keep -c {output.tmp}  |  cut -d '|' -f1 | \
        {PIGZ} -p {threads} -c  > {output.tx}
        """


rule get_decoy:
    input:
        transcriptome = op.join(BASE, 'annotation', op.basename(TRANSCRIPTOME_URL))
    output:        
        decoys = op.join(BASE, 'annotation', op.splitext(op.basename(TRANSCRIPTOME_URL))[0] + '_transcriptome_decoys.txt')
    threads:
       NTHREADS
    shell:
        """
        {PIGZ} --decompress --keep --processes {threads} --to-stdout {input.transcriptome} |  grep ">" | \
        cut -d ">" -f 2 | cut -d "|" -f 1 > {output.decoys}
        """

rule index_repeats_salmon_repeats_with_decoy_transcriptome:
    input:
        repeats = op.join(BASE, 'annotation', 'repeatome_from_' + op.splitext(op.basename(REP_GTF_URL))[0] + '.fa.gz'),
        # genome =  op.join(BASE, 'annotation', op.basename(GENOME_URL)),
        transcriptome = op.join(BASE, 'annotation', op.basename(TRANSCRIPTOME_URL)),
        decoys =  op.join(BASE, 'annotation', op.splitext(op.basename(TRANSCRIPTOME_URL))[0] + '_transcriptome_decoys.txt')
    output:
        op.join(BASE, 'indices', 'salmon', GENOME, 'repeats_salmon', 'duplicate_clusters.tsv'),
        op.join(BASE, 'indices', 'salmon', GENOME, 'repeats_salmon', 'complete_ref_lens.bin')
    params:
        path = op.join(BASE, 'indices', 'salmon', GENOME, 'repeats_salmon'),
        k = 31
    threads:
        NTHREADS
    log:
        op.join(BASE, 'indices', 'salmon', GENOME, 'repeats_salmon_index.log')
    shell:
        """
        mkdir -p {params.path}
        
        ({SALMON} index -p {threads} \
          index -t <( zcat {input.repeats} {input.transcriptome}) -i {params.path} -k {params.k} \
          -d {input.decoys}) 2> {log}
        """

# rule map_salmon_repeats_chromium:
#     input:


# from https://gist.github.com/k3yavi/c501705ed2d29b12b0d10cf78b3ed001
## and https://github.com/COMBINE-lab/salmon/issues/336 to get the `attribute` instead of
##   the group
rule get_txp2gene_gene:
    input:
        genes_gtf = op.join(BASE, 'annotation', op.basename(GENES_GTF_URL))
    output:
        op.join(BASE, 'indices', 'salmon', GENOME, 'genes_salmon', 'txp2gene.tsv')
    shell:
         """
         {PIGZ} --decompress -p {threads} -c {input.genes_gtf} | \
           grep transcript | awk '{{print $12,$10}}' | sed -e 's|"||g' -e 's|;||g' | uniq > {output}
         """

## untested @todo check
rule get_txp2gene_repeat:
    input:
        repeats_gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL))
    output:
        op.join(BASE, 'indices', 'salmon', GENOME, 'repeats_salmon', 'txp2gene.tsv')
    params:
        path = op.join(BASE, 'indices', 'salmon', GENOME, 'repeats_salmon')
    shell:
        """
        mkdir -p {params.path}
        
        {PIGZ} --decompress -p {threads} -c {input.repeats_gtf} | grep transcript | \
        awk '{{print $12,$10}}' | sed -e 's|"||g' -e 's|;||g' | uniq > {output}
        """

rule map_salmon_repeats_chromium:
    input:        
        tgmap = op.join(BASE, 'indices', 'salmon', GENOME, 'repeats_salmon', 'txp2gene.tsv'),
        idx_tracker = op.join(BASE, 'indices', 'salmon', GENOME, 'repeats_salmon', 'duplicate_clusters.tsv'),
        cb = sorted(glob(op.join(BASE, 'data', RUN_NAME, RUN_NAME + '_fastqs/*R1*fastq.gz'))),
        r2 = sorted(glob(op.join(BASE, 'data', RUN_NAME, RUN_NAME + '_fastqs/*R2*fastq.gz')))        
    output:
        op.join(BASE, 'runs', RUN_NAME, 'alevin', 'repeats', 'quants_mat.gz')
    threads:
        NTHREADS
    params:
        fastqs_path = op.join(BASE, 'data', RUN_NAME),
        processing_path = op.join(BASE, 'runs', RUN_NAME),
        salmon_idx = op.join(BASE, 'indices', 'salmon', GENOME, 'repeats_salmon'),
        cb = ' '.join(sorted(glob(op.join(BASE, 'data', RUN_NAME, RUN_NAME + '_fastqs/*R1*fastq.gz')))),
        r2 = ' '.join(sorted(glob(op.join(BASE, 'data', RUN_NAME, RUN_NAME + '_fastqs/*R2*fastq.gz')))) 
    log:
        op.join(BASE, 'runs', RUN_NAME, 'run_salmon_repeats_chromium.log')
    shell:
        """
    mkdir -p {params.processing_path}
    cd {params.processing_path}

    ({SALMON} alevin \
    -l ISR \
    -1 {params.cb} \
    -2 {params.r2} \
    --chromiumV3  \
    -i {params.salmon_idx} \
    -p {threads} -o {params.processing_path} \
    --tgMap {input.tgmap} ) 2> {log}

    touch -c {output}
        """
    

        
## beware the cb path for pbmc5k, they shouldn't be there at `RUN_NAME + '_fastqs/` subfoder
rule map_salmon_genes_chromium:
    input:        
        tgmap = op.join(BASE, 'indices', 'salmon', GENOME, 'genes_salmon', 'txp2gene.tsv'),
        idx_tracker = op.join(BASE, 'indices', 'salmon', GENOME, 'genes_salmon', 'duplicate_clusters.tsv'),
        cb = sorted(glob(op.join(BASE, 'data', RUN_NAME, RUN_NAME + '_fastqs/*R1*fastq.gz'))),
        r2 = sorted(glob(op.join(BASE, 'data', RUN_NAME, RUN_NAME + '_fastqs/*R2*fastq.gz')))        
    output:
        op.join(BASE, 'runs', RUN_NAME, 'alevin', 'genes', 'quants_mat.gz')
    threads:
        NTHREADS
    params:
        fastqs_path = op.join(BASE, 'data', RUN_NAME),
        processing_path = op.join(BASE, 'runs', RUN_NAME),
        salmon_idx = op.join(BASE, 'indices', 'salmon', GENOME, 'genes_salmon'),
        cb = ' '.join(sorted(glob(op.join(BASE, 'data', RUN_NAME, RUN_NAME + '_fastqs/*R1*fastq.gz')))),
        r2 = ' '.join(sorted(glob(op.join(BASE, 'data', RUN_NAME, RUN_NAME + '_fastqs/*R2*fastq.gz')))) 
    log:
        op.join(BASE, 'runs', RUN_NAME, 'run_salmon_genes_chromium.log')
    shell:
        """
    mkdir -p {params.processing_path}
    cd {params.processing_path}

    ({SALMON} alevin \
    -l ISR \
    -1 {params.cb} \
    -2 {params.r2} \
    --chromiumV3  \
    -i {params.salmon_idx} \
    -p {threads} -o {params.processing_path} \
    --tgMap {input.tgmap} ) 2> {log}

    touch -c {output}
        """
                
## samon end



rule profile_featurecounts_run_repeats:
    input:        
        summary = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard',
                            RUN_NAME + "_repeats.counts.summary")
    params:
        path = op.join(BASE, "runs", RUN_NAME, "count_repeats_on_cellranger_standard"),
        script = FEATURECOUNTS_RSCRIPT,
        gtf = 'cellranger_repeats'
    output:
        png = op.join(BASE, "runs", RUN_NAME, "count_repeats_on_cellranger_standard",  RUN_NAME + "_transcriptome_repeats.counts.summary.png")
    threads: 1
    shell:
       """
       cd {params.path}
       
       {Rscript} {params.script} --summary {input.summary} --output {output.png} --identifier {params.gtf}
       """

rule profile_featurecounts_run_repeats_not_genes:
    input:        
        summary = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard_not_overlapping_genes', RUN_NAME + "_repeats_not_overlapping_genes.counts.summary")
    params:
        path = op.join(BASE, "runs", RUN_NAME, "count_repeats_on_cellranger_standard_not_overlapping_genes"),
        script = FEATURECOUNTS_RSCRIPT,
        gtf = 'cellranger_repeats_not_genes'
    output:
        png = op.join(BASE, "runs", RUN_NAME, "count_repeats_on_cellranger_standard_not_overlapping_genes",  RUN_NAME + "_transcriptome_repeats_not_genes.counts.summary.png")
    threads: 1
    shell:
       """
       cd {params.path}
       
       {Rscript} {params.script} --summary {input.summary} --output {output.png} --identifier {params.gtf}
       """    

rule knit_report_chromium:
    input:
        genes = op.join(BASE, 'runs', RUN_NAME, 'cellranger_standard', 'outs', 'filtered_feature_bc_matrix', 'barcodes.tsv.gz'),
        repeats = op.join(BASE, 'runs', RUN_NAME, 'cellranger_repeats', 'outs', 'filtered_feature_bc_matrix', 'barcodes.tsv.gz'),
        featurecounts = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard',
                                RUN_NAME + "_repeats.counts.gz"),
        repeats_only_featurecounts_control = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard_not_overlapping_genes', RUN_NAME + "_repeats_not_overlapping_genes.counts.gz")
    params:
        rmd = 'summarize_cellranger_run_pbmcs.Rmd',
        run_name = RUN_NAME
    output:
        html = op.join(BASE, 'runs', RUN_NAME, RUN_NAME + '_pbmc_cellranger_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.html'),
        rds = op.join(BASE, 'runs', RUN_NAME, RUN_NAME + '_pmbc_cellranger_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.rds'),
        aris = op.join(BASE, 'runs', RUN_NAME, RUN_NAME + '_aris_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.rds')
    log:
        op.join(BASE, 'runs', RUN_NAME, RUN_NAME + 'summarize_cellranger_run_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.log')
    shell: """
        {Rscript} -e 'rmarkdown::render(\"{params.rmd}\", output_file = \"{output.html}\", params = list(identifier = \"{params.run_name}\", genes_cellranger = \"{input.genes}\", repeats_cellranger = \"{input.repeats}\", repeats_featurecounts = \"{input.featurecounts}\", repeats_only_featurecounts_control = \"{input.repeats_only_featurecounts_control}\", seurat_output = \"{output.rds}\", aris_output = \"{output.aris}\", regress_genes_nCount = \"{wildcards.regress_ncount}\", regress_genes_nFeature = \"{wildcards.regress_nfeature}\"))' &> {log}
        """

# rule knit_report_chromium_genes_regressed_out:
#     input:
#         genes = op.join(BASE, 'runs', RUN_NAME, 'cellranger_standard', 'outs', 'filtered_feature_bc_matrix', 'barcodes.tsv.gz'),
#         repeats = op.join(BASE, 'runs', RUN_NAME, 'cellranger_repeats', 'outs', 'filtered_feature_bc_matrix', 'barcodes.tsv.gz'),
#         featurecounts = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard',
#                                 RUN_NAME + "_repeats.counts.gz")
#     params:
#         rmd = 'summarize_cellranger_run_with_genes_regressed_out.Rmd',
#         run_name = RUN_NAME
#     output:
#         html = op.join(BASE, 'runs', RUN_NAME, 'summarize_cellranger_run_report_genes_regressed_out.html'),
#         rds = op.join(BASE, 'runs', RUN_NAME, 'summarize_cellranger_run_genes_regressed_out.rds'),
#         aris = op.join(BASE, 'runs', RUN_NAME, 'aris.rds')
#     log:
#         op.join(BASE, 'runs', RUN_NAME, 'knit_report_genes_regressed_out.log')
#     shell:
#         """
#         {Rscript} -e 'rmarkdown::render(\"{params.rmd}\", output_file = \"{output.html}\", params = list(identifier = \"{params.run_name}\", genes_cellranger = \"{input.genes}\", repeats_cellranger = \"{input.repeats}\", repeats_featurecounts = \"{input.featurecounts}\", seurat_output = \"{output.rds}\", aris_output = \"{output.aris}\"))' &> {log}
#         """

rule run_feature_counts_spawned_bams:
    input:
        flag = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'split.flag'),
        gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL))
    params:
        path = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'split')
    output:
        counts  = temp(op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard',
                               RUN_NAME + "_repeats.counts")),
        gz_counts = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard',
                            RUN_NAME + "_repeats.counts.gz"),
        summary = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard',
                            RUN_NAME + "_repeats.counts.summary")
    log :
        log = op.join(BASE, "runs",  RUN_NAME, 'count_repeats_on_cellranger_standard','feature_counts.log'),
    threads:
        NTHREADS
    shell: """
    cd {params.path}

    {FEATURECOUNTS} -T {threads} \
    -t exon \
    -g gene_id \
    -a {input.gtf} \
    -o  {output.counts} \
    {params.path}/*bam  2>&1 > {log}

    {PIGZ} --keep -p {threads} {output.counts}
    """

rule run_feature_counts_repeats_not_overlapping_genes_spawned_bams:
    input:
        flag = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'split.flag'),
        gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL) + '_minus_' + op.basename(GENES_GTF_URL))
    params:
        path = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'split')
    output:
        counts  = temp(op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard_not_overlapping_genes', RUN_NAME + "_repeats_not_overlapping_genes.counts")),
        gz_counts = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard_not_overlapping_genes',
                            RUN_NAME + "_repeats_not_overlapping_genes.counts.gz"),
        summary = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard_not_overlapping_genes',
                           RUN_NAME + "_repeats_not_overlapping_genes.counts.summary")
    log :
        log = op.join(BASE, "runs",  RUN_NAME, 'count_repeats_on_cellranger_standard_not_overlapping_genes', 'feature_counts_not_overlapping_genes.log'),
    threads:
        NTHREADS
    shell: """
    cd {params.path}

    {FEATURECOUNTS} -T {threads} \
    -t exon \
    -g gene_id \
    -a {input.gtf} \
    -o  {output.counts} \
    {params.path}/*bam  2>&1 > {log}

    {PIGZ} --keep -p {threads} {output.counts}
    """
    
rule spawn_cellranger_bam_file_by_cell:
    input:
        bam = op.join(BASE, 'runs', RUN_NAME, 'cellranger_standard', 'outs', 'possorted_genome_bam.bam'),
        barcodes = op.join(BASE, 'runs', RUN_NAME, 'cellranger_standard', 'outs', 'filtered_feature_bc_matrix', 'barcodes.tsv.gz')
    output:
        rgs = temp(op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'rgs.txt')),
        header = temp(op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'header.txt')),
        body = temp(op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'body.txt.gz')),
        shortened_bam = temp(op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'shortened.bam')),
        flag = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'split.flag'),
        path = directory(op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'split'))
    threads:
        NTHREADS
    params:
        barcodes_script = 'get_cell_barcodes.py',
        split_script = 'split_by_cell_barcode_in_sorted_bam.py',
        split_path = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'split')
    log:
        log1 = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'split_add_rg.log'),
        log2 = op.join(BASE, "runs", RUN_NAME, 'count_repeats_on_cellranger_standard', 'split_pick.log'),
    shell:
        """
        mkdir -p {output.path}
        
        # python3 {params.barcodes_script} {input.bam} | {PIGZ} -p {threads} > {output.rgs}

        python3 {params.barcodes_script} {input.bam}  > {output.rgs}

        samtools view -@ {threads} -H {input.bam} > {output.header}

        ## buffer size in sort due to https://superuser.com/questions/938558/sort-parallel-isnt-parallelizing
        ( samtools view -@ {threads} {input.bam} | cut -f 1-15 | \
        paste - {output.rgs} | \
          sed 's/\t$//' | sort -S1G --parallel={threads} -k16 | {PIGZ} -p {threads} --keep --stdout > {output.body} ) &> {log.log1}
        
        {PIGZ} --decompress -p {threads} --keep --stdout {output.body} | cat {output.header} - | samtools view -@ {threads} -Sb - > {output.shortened_bam}
        
        python3 split_by_cell_barcode_in_sorted_bam.py {output.shortened_bam} -outdir {params.split_path} -barcodes {input.barcodes} &> {log.log2}

        touch {output.flag}

        """


# rule run_cellranger_standard:
#     input:
#         flag_fastq = op.join(BASE, 'data', RUN_NAME, 'read-RA_si-TATTGGTG_lane-004-chunk-002.fastq.gz'),
#         transcriptome = op.join(BASE, 'indices', 'cellranger', 'refdata-cellranger-GRCh38-3.0.0')
#     params:
#         fastqs_path = op.join(BASE, 'data', RUN_NAME),
#         sample_name = RUN_NAME,
#         local_mem_gb = LOCAL_MEM_GB,
#         processing_path = op.join(BASE, 'runs', RUN_NAME),
#         chemistry = CHEMISTRY
#     output:
#         op.join(BASE, 'runs', RUN_NAME, 'cellranger_standard', 'outs', 'web_summary.html'),
#         op.join(BASE, 'runs', RUN_NAME, 'cellranger_standard', 'outs', 'possorted_genome_bam.bam'),
#         op.join(BASE, 'runs', RUN_NAME, 'cellranger_standard', 'outs', 'filtered_feature_bc_matrix', 'barcodes.tsv.gz')
#     threads:
#         NTHREADS
#     log:
#         op.join(BASE, 'runs',  RUN_NAME, 'run_cellranger_standard.log')
#     run:
#         if DEMUX:
#             shell("""
#             mkdir -p {params.processing_path}
#             cd {params.processing_path}
#             rm -rf cellranger_standard

#             {CELLRANGER} count --id=cellranger_standard \
#             --fastqs={params.fastqs_path} \
#             --transcriptome={input.transcriptome} \
#             --jobmode=local \
#             --localcores={threads} \
#             --localmem={params.local_mem_gb} \
#             --chemistry={params.chemistry}
#             """)
#         else:
#             shell("""
#             mkdir -p {params.processing_path}
#             cd {params.processing_path}
#             rm -rf cellranger_standard

#             {CELLRANGER} count --id=cellranger_standard \
#             --fastqs={params.fastqs_path} \
#             --transcriptome={input.transcriptome} \
#             --jobmode=local \
#             --localcores={threads} \
#             --sample={params.sample_name} \
#             --localmem={params.local_mem_gb} \
#             --chemistry={params.chemistry}
#             """)
            

# rule run_cellranger_repeats:
#     input:
#         transcriptome = op.join(BASE, 'indices', 'cellranger', 'repeats_hg38', 'repeats_hg38')
#     params:
#         fastqs_path = op.join(BASE, 'data', RUN_NAME),
#         sample_name = RUN_NAME,
#         local_mem_gb = LOCAL_MEM_GB,
#         processing_path = op.join(BASE, 'runs', RUN_NAME),
#         chemistry = CHEMISTRY
#     output:
#         op.join(BASE, 'runs', RUN_NAME, 'cellranger_repeats', 'outs', 'web_summary.html'),
#         op.join(BASE, 'runs', RUN_NAME, 'cellranger_repeats', 'outs', 'filtered_feature_bc_matrix', 'barcodes.tsv.gz')
#     threads:
#         NTHREADS
#     log:
#         op.join(BASE, 'runs', RUN_NAME, 'run_cellranger_repeats.log')
#     run:
#         if DEMUX:
#             shell("""
#         mkdir -p {params.processing_path}
#         cd {params.processing_path}
#         rm -rf cellranger_repeats

#         {CELLRANGER} count --id=cellranger_repeats \
#           --fastqs={params.fastqs_path} \
#           --transcriptome={input.transcriptome} \
#           --jobmode=local \
#           --localcores={threads} \
#           --localmem={params.local_mem_gb} \
#           --chemistry={params.chemistry} \
#             """)
#         else:
#             shell("""
#         mkdir -p {params.processing_path}
#         cd {params.processing_path}
#         rm -rf cellranger_repeats

#         {CELLRANGER} count --id=cellranger_repeats \
#           --fastqs={params.fastqs_path} \
#           --transcriptome={input.transcriptome} \
#           --jobmode=local \
#           --localcores={threads} \
#           --sample={params.sample_name} \
#           --localmem={params.local_mem_gb} \
#           --chemistry={params.chemistry}
#         """)
        

## Indexing start ----------------------------------------------------------------------------- ##        

rule index_cellranger_repeats:
    input:
       compressed_fa = op.join(BASE, 'annotation', op.basename(GENOME_URL)),
       compressed_gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL))
    params:
       local_mem_gb = LOCAL_MEM_GB,
       path =  op.join(BASE, 'indices', 'cellranger', 'repeats_hg38'),
       genome = 'repeats_hg38'
    threads:
        NTHREADS
    output:
        uncompressed_gtf = temp(op.join(BASE, 'annotation', op.splitext(op.basename(REP_GTF_URL))[0])),
        flag = op.join(BASE, 'indices', 'cellranger', 'repeats_hg38', 'Log.out'),
        uncompressed_fa = temp(op.join(BASE, 'annotation', op.splitext(op.basename(GENOME_URL))[0]))
    shell:
       """ 
       mkdir -p {params.path}
       cd {params.path}
 
       {PIGZ} --decompress  -p {threads} --keep -c {input.compressed_fa} > \
        {output.uncompressed_fa}

       {PIGZ} --decompress  -p {threads} --keep -c {input.compressed_gtf} > \
         {output.uncompressed_gtf}
       
       {CELLRANGER} mkref --genome {params.genome} \
       --fasta {output.uncompressed_fa} \
       --genes {output.uncompressed_gtf} \
       --nthreads {threads} \
       --memgb {params.local_mem_gb} 

       touch {output.flag}
       """

## use this! @todo
rule get_repeats_not_overlapping_genes_gtf:
    input:
        repeats_gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL)),
        genes_gtf =  op.join(BASE, 'annotation', op.basename(GENES_GTF_URL))
    output:
        gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL) + '_minus_' + op.basename(GENES_GTF_URL)),
        repeats_gtf_decomp = temp(op.join(BASE, 'annotation', op.basename(REP_GTF_URL)) + '.tmp.gtf'),
        genes_gtf_decomp =  temp(op.join(BASE, 'annotation', op.basename(GENES_GTF_URL)) + '.tmp.gtf'),
        genesbed = temp(op.join(BASE, 'annotation', op.basename(GENES_GTF_URL)) + '.tmp.bed')
    params:
        threads = NTHREADS,
        bedops_path='~/soft/bedops/bedops-2.4.39/bin/'
    shell:
        """
        ## this ends with a premature end of file (?)
        # {BEDOPS} --difference {input.repeats_gtf} {input.genes_gtf} > {output}


        ## this doesn't neither start

        {PIGZ} --decompress --keep --stdout  {input.repeats_gtf} | \
               sed 's/chr//g' > {output.repeats_gtf_decomp}
        {PIGZ} --decompress --keep  --stdout  {input.genes_gtf} | \
               sed 's/chr//g' > {output.genes_gtf_decomp}
               
        # {BEDOPS} --difference {output.repeats_gtf_decomp} {output.genes_gtf_decomp} | 
        #        {PIGZ} --stdout > {output.gtf}

        ## this doesn't neither end

        # let's transform genes in bed and then use bedtools
        export PATH={params.bedops_path}:$PATH

        awk '{{ if ($0 ~ "transcript_id") print $0; else print $0" transcript_id "";"; }}' \
           {output.genes_gtf_decomp} | gtf2bed - > {output.genesbed}

        {BEDTOOLS} intersect -a {output.repeats_gtf_decomp} \
          -b {output.genesbed} \
          -v | {PIGZ} --stdout > {output.gtf}
        """
        
rule extract_repeatome_from_gtf:
    priority: 100
    input:
        genome = op.join(BASE, 'annotation', op.basename(GENOME_URL)),
        gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL))
    output:
        genome_uncompressed = temp(op.join(BASE, 'annotation', op.splitext(op.basename(GENOME_URL))[0])) + '.temp_extract',
        fai = temp(op.join(BASE, 'annotation', op.splitext(op.basename(GENOME_URL))[0])) + '.temp_extract.fai',
        fasta = temp(op.join(BASE, 'annotation', 'repeatome_from_' + op.splitext(op.basename(REP_GTF_URL))[0]) + '.fa'),
        gtftemp = op.join(BASE, 'annotation', 'temp_' + op.basename(REP_GTF_URL)),
        fastagz = op.join(BASE, 'annotation', 'repeatome_from_' + op.splitext(op.basename(REP_GTF_URL))[0]) + '.fa.gz'
    params :
        rscript = GTF_PARSING_RSCRIPT
    threads:
        NTHREADS
    shell:
        """
        {PIGZ} --keep --decompress -p {threads} -c  {input.genome} > {output.genome_uncompressed}

        ## faking the GTF to describe the instance and not the 'exon'

        {Rscript} {params.rscript} -g {input.gtf} | {PIGZ} -c -p {threads} > \
          {output.gtftemp}
        
        # {BEDTOOLS} getfasta -name -s -fi {output.fasta} \
        #   -bed {output.gtftemp} -fo {output.fasta}

        {BEDTOOLS} getfasta -name -s -fi {output.genome_uncompressed} \
          -bed {output.gtftemp} -fo {output.fasta}

        ## remove the coordinates appended by bedtools!
        sed 's/:/ /g' {output.fasta} | cut -f1 -d" " | \
          {PIGZ}  -p {threads} -c > {output.fastagz}
        
        """

## hg38 hardcoded
rule get_genome_fasta:
    priority:
        100
    output:
        op.join(BASE, 'annotation', op.basename(GENOME_URL))
    params:
        url = GENOME_URL
    shell:
        """
        curl -s -L -C - {params.url} -o {output}
        """
      
rule get_repeats_gtf:
    priority:
        100
    params:
        url = REP_GTF_URL,
        genome_path = op.join(BASE, 'annotation')
    output:
        op.join(BASE, 'annotation', op.basename(REP_GTF_URL))
    shell:
        """        
        curl -s -L -C - {params.url} -o {output}
        """
        
rule get_genes_gtf:
    priority:
        100
    params:
        url = GENES_GTF_URL
    output:
        gtf = op.join(BASE, 'annotation', op.basename(GENES_GTF_URL))
    shell:
        """    
        curl -s -L -C - {params.url} -o {output.gtf}
        """

rule get_cellranger_data:
    priority:
        100
    params:
        url = CELLRANGER_HG38_URL,
        path = op.join(BASE, 'indices', 'cellranger')
    output:
        cellranger_gz = op.join(BASE, 'indices', 'cellranger', op.basename(CELLRANGER_HG38_URL)),
        uncomp = op.join(BASE, 'indices', 'cellranger', 'refdata-cellranger-GRCh38-3.0.0', 'reference.json')
    shell:
        """
        mkdir -p {params.path}
        cd {params.path}

        curl -s -L -C - {params.url} -o {output.gtf}
        
        tar xzvf {output.cellranger_gz}
        """

        
## @todo move to indices retrieval
rule get_cellranger_grch38_genome:
    params:
        url = 'http://cf.10xgenomics.com/supp/cell-exp/refdata-cellranger-GRCh38-3.0.0.tar.gz'
    output:
        path = op.join(BASE, 'indices', 'cellranger'),
        fn = op.join(BASE, 'indices', 'cellranger', 'refdata-cellranger-GRCh38-3.0.0.tar.gz'),
        uncompressed = op.join(BASE, 'indices', 'cellranger', 'refdata-cellranger-GRCh38-3.0.0', 'reference.json')
    shell:
        """    
        mkdir -p {output.path}
        cd {output.path}
        curl -s -L -C - {params.url} -O {output.fn}
        tar xzvf {output.fn}
        """
 


## Genome, transcriptome and repeatome retrieval end   ---------------------------------------- ##
