#!/usr/bin/env snakemake -s
## 
## Started 14th Jan 2020
##
## Izaskun Mallona
## GPLv3

import os.path as op
from glob import glob

print("""
Folder structure

.. config
.. annotation
.. indices
.... bowtie
...... repeatome (bowtie)
.... star
...... repeatome (star)
...... transcriptome
.... salmon
...... transcriptome (salmon)
...... repeatome (salmon)
.... cellranger
.. conda
.. runs
.... run_name
...... fastq
...... align
...... counts
""")



#@FIXME to be moved to config, not hardcoded!
BASE = op.join('/home', 'imallona', 'repeats_sc')
NTHREADS = 20
LOCAL_MEM_GB = 100


## @FIXME to be moved to config
GENOME_URL = 'ftp://ftp.ensembl.org/pub/release-98/fasta/homo_sapiens/dna/Homo_sapiens.GRCh38.dna.primary_assembly.fa.gz'
GENES_GTF_URL =  'ftp://ftp.ensembl.org/pub/release-98/gtf/homo_sapiens/Homo_sapiens.GRCh38.98.gtf.gz'
REP_GTF_URL = 'http://labshare.cshl.edu/shares/mhammelllab/www-data/TEtranscripts/TE_GTF/GRCh38_rmsk_TE.gtf.gz'
DFAM_EMBL_URL = 'https://www.dfam.org/releases/current/families/Dfam.embl.gz'
TRANSCRIPTOME_URL= 'ftp://ftp.ensembl.org/pub/release-98/fasta/homo_sapiens/cdna/Homo_sapiens.GRCh38.cdna.all.fa.gz'

## @FIXME to be moved to config

# ## EMBOSS:6.6.0.0
# SEQRET = '/usr/bin/seqret'

# ./bowtie-build --version
# bowtie-build version 1.2.3
# 64-bit
# Built on imlsportmacquarie
# Tue Jan 14 15:41:37 CET 2020
# Compiler: gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.12) 
# Options: -O3 -m64  -Wl,--hash-style=both -DWITH_TBB -DPOPCNT_CAPABILITY  
# Sizeof {int, long, long long, void*, size_t, off_t}: {4, 8, 8, 8, 8, 8}
BOWTIE_BUILD = '/home/imallona/soft/bowtie/bowtie-1.2.3/bowtie-build'

##pigz 2.3.1
PIGZ = '/usr/bin/pigz'
BIOPYTHON_CONVERT='biopython.convert'
STAR = '~/soft/star/STAR-2.7.3a/source/STAR'
FEATURECOUNTS = '~/soft/subread/subread-2.0.0-source/bin/featureCounts'
SALMON = '~/soft/salmon/salmon-1.1.0_linux_x86_64/bin/salmon'
CELLRANGER = '~/soft/cellranger/cellranger-3.1.0/cellranger'

## Folder structure start --------------------------------------------------------------------- ##

try:
   if not op.exists(op.dirname(op.join(BASE, 'annotation'))):
      os.makedirs(op.join(BASE, 'annotation'))
except OSError as err:
   print(err)
      
for item in ['bowtie', 'star', 'salmon']:
   try:
      if not op.exists(op.dirname(op.join(BASE, 'indices', item))):
         os.makedirs(op.join(BASE, 'indices', item))
   except OSError as err:
      print(err)


# op.join(BASE, 'indices', 'salmon', 'genes_salmon'),
# op.join(BASE, 'indices', 'salmon', 'repeats_salmon'),
# op.join(BASE, 'indices', 'star', 'transcriptome'),
# op.join(BASE, 'indices', 'star', 'repeatome'),
# op.join(BASE, 'indices', 'bowtie', 'repeatome'),
      
      

## Folder structure end ----------------------------------------------------------------------- ##
      
# remember to create output paths   


# workdir: BASE
         
rule all:
    input:
        op.join(BASE, 'indices', 'bowtie', 'repeatome',
                op.splitext(op.basename(DFAM_EMBL_URL))[0]) + '.1.ebwt',
        op.join(BASE, 'indices', 'salmon', 'genes_salmon', 'ref_k31_fixed.fa'),
        op.join(BASE, 'indices', 'salmon', 'repeats_salmon', 'ref_k31_fixed.fa'),
        op.join(BASE, 'indices', 'star', 'repeatome', 'chrName.txt'),
        op.join(BASE, 'indices', 'star', 'transcriptome', 'chrName.txt')#,
        # op.join(BASE, 'runs', '5k_pbmc_v3_cellranger', 'outs', 'web_summary.html')

# # remeber the readgroup thing!
# #@untested @todo
# rule featurecounts_repeats_genome:
#     input:
#         bam = 'todo',
#         gtf = 'todo'
#     output:
#         counts  = 'todo'
#     log : 'd'
#     shell: """
#     {FEATURECOUNTS} -T {threads} \
#      -t exon \
#      -g gene_id \
#      --byReadGroup \
#      -a "$GTF" \
#      -o  {output.counts}
#      {bam}  2>&1 > {log}
#     """

    
## Mapping start ------------------------------------------------------------------------------ ##

# rule map_star_naive:

# rule map_alevin:

# #@untested @todo
# ## fix to take into account the different indices to map against
# rule map_star_se:
#     input:
#         index = 'todo',
#         fastq = 'todo'
#     output:
#         op.join(BASE, "run/{sample}/{sample}_Aligned.sortedByCoord.out.bam")
#     threads:
#         NTHREADS
#     log:
#         op.join(BASE, 'run/{sample}/{sample}_star.log')
#     benchmark:
#         op.join(BASE, 'run/{sample}/{sample}_star_benchmark.txt')
#     params:
#         path = op.join(BASE, 'run', "{sample}")
#     shell:
#         """
#         {STAR} --genomeDir {params.index} \
#         --readFilesIn {input.fastq} \
#         --runThreadN {threads} \
#         --outFileNamePrefix {params.path} \
#         --outSAMtype BAM SortedByCoordinate \
#         --readFilesCommand {PIGZ} -c"    
#         """

#@untested @todo
rule run_cell_ranger:
    input:
        fastqs_path = op.join(BASE, 'data', 'pbmc_v3', '5k_pbmc_v3_fastqs'),
        transcriptome = op.join(BASE, 'indices', 'cellranger',
                                'refdata-cellranger-GRCh38-3.0.0')
    params:
        sample_name = '5k_pbmc_v3',
        local_mem_gb = LOCAL_MEM_GB,
        processing_path = op.join(BASE, 'runs')
    output:
        op.join(BASE, 'runs', '5k_pbmc_v3_cellranger', 'outs', 'web_summary.html')
    threads:
        NTHREADS
    log:
        op.join(BASE, 'runs', '5k_pbmc_v3_cellranger', 'run.log')
    shell:
        """
        mkdir -p {params.processing_path}
        cd {params.processing_path}
        
        {CELLRANGER} count --id={params.sample_name}_cellranger \
          --fastqs={input.fastqs_path} \
          --transcriptome={input.transcriptome} \
          --jobmode=local \
          --localcores={threads} \
          --sample={params.sample_name} \
          --localmem={params.local_mem_gb} \
          --expect-cells=5000
        """
        
# #@untested @todo
# # -l ISR for both Drop-seq and 10x-v2 chemistry
# # https://salmon.readthedocs.io/en/latest/alevin.html#description-of-important-options
# # tech is either --dropseq / --chromium / --chromiumV3
# # beware of the -keepduplicates
# rule run_salmon_chromium:
#     input:
#         cb_fastq = 'todo',
#         salmon_idx = 'todo',
#         tgmap = 'todo'
#     output:
#         'todo'
#     params:
#         'todo'
#     shell:
#         """
#         {SALMON} alevin \
#          -l ISR \
#          -1 {input.cb_fastq} \
#          -2 {input.reads_fastq} \
#          --chromium  \
#          -i {input.salmon_index} \
#          -p 10 -o {threads} \
#          --tgMap {input.tgmap}
#         """

## Mapping end -------------------------------------------------------------------------------- ##


## Data retrieval start ----------------------------------------------------------------------- ##

## @todo move to indices retrieval
rule get_cellranger_grch38_genome:
    params:
        url = 'http://cf.10xgenomics.com/supp/cell-exp/refdata-cellranger-GRCh38-3.0.0.tar.gz'
    output:
        path = op.join(BASE, 'indices', 'cellranger'),
        fn = op.join(BASE, 'indices', 'cellranger', 'refdata-cellranger-GRCh38-3.0.0.tar.gz'),
        uncompressed = op.join(BASE, 'indices', 'cellranger',
                               'refdata-cellranger-GRCh38-3.0.0', 'reference.json')
    shell:
        """    
        mkdir -p {output.path}
        cd {output.path}
        curl -s -L -C - {params.url} -O {output.fn}
        tar xzvf {output.fn}
        """
        
## check if untar is needed @todo
rule get_pbmc_v3:
    params:
        url = 'http://s3-us-west-2.amazonaws.com/10x.files/samples/cell-exp/3.0.2/5k_pbmc_v3/5k_pbmc_v3_fastqs.tar'
    output:
        path = op.join(BASE, 'data', 'pbmc_v3'),
        fn = op.join(BASE, 'data', 'pbmc_v3', '5k_pbmc_v3_fastqs.tar'),
        uncompressed =  op.join(BASE, 'data', 'pbmc_v3', '5k_pbmc_v3_fastqs',
                                '5k_pbmc_v3_S1_L001_I1_001.fastq.gz')
    shell:
        """    
        mkdir -p {output.path}
        cd {output.path}
        curl -s -L -C - {params.url} -O {output.fn}
        tar xvf {output.fn}
        """
        


## chromium example (from preliminary data)


## Data retrieval end ------------------------------------------------------------------------- ##


## Indexing start ----------------------------------------------------------------------------- ##

# rule retrieve_pre_indexed_cell_ranger:
#     #todo

rule index_repeats_salmon_no_decoy:
    input:
        repeats = op.join(BASE, 'annotation',
                          op.splitext(op.basename(DFAM_EMBL_URL))[0] + '.fa')
    output:
        op.join(BASE, 'indices', 'salmon', 'repeats_salmon', 'duplicate_clusters.tsv'),
        op.join(BASE, 'indices', 'salmon', 'repeats_salmon', 'ref_k31_fixed.fa'),
        op.join(BASE, 'indices', 'salmon', 'repeats_salmon', 'complete_ref_lens.bin')
    params:
        path = op.join(BASE, 'indices', 'salmon', 'repeats_salmon'),
        k = 31
    threads:
        NTHREADS
    log:
        op.join(BASE, 'indices', 'salmon', 'repeats_salmon_index.log')
    shell:
        """
        mkdir -p {params.path}
        
        ({SALMON} -p {threads} \
          index -t {input.repeats} -i {params.path} -k {params.k}) 2> {log}
        """


# https://salmon.readthedocs.io/en/latest/alevin.html
# ./bin/salmon index -t transcripts.fa -i transcripts_index --decoys decoys.txt -k 31
## shall I use a decoy? https://github.com/COMBINE-lab/SalmonTools/README.md
# apparently not
# **NOTE:** Salmon version [v1.0](https://github.com/COMBINE-lab/salmon/releases/tag/v1.0.0) can directly index the genome and transcriptome and doesn't mandates to run the `generateDecoyTranscriptome` script, however it's still backward compatible. Please checkout [this](https://combine-lab.github.io/alevin-tutorial/2019/selective-alignment/) tutorial on how to run salmon with full genome + transcriptome without the annotation.
rule index_genes_salmon_no_decoy:
    input:
        transcripts = op.join(BASE, 'annotations', op.basename(TRANSCRIPTOME_URL))
    params:
        k = 31,
        path = op.join(BASE, 'indices', 'salmon', 'genes_salmon')
    log:
        op.join(BASE, 'indices', 'salmon', 'genes_salmon', 'genes_salmon_index.log')
    threads:
        NTHREADS
    output:
        op.join(BASE, 'indices', 'salmon', 'genes_salmon', 'duplicate_clusters.tsv'),
        op.join(BASE, 'indices', 'salmon', 'genes_salmon', 'ref_k31_fixed.fa'),
        op.join(BASE, 'indices', 'salmon', 'genes_salmon', 'complete_ref_lens.bin')
    shell:        
        """
        mkdir -p {params.path}
        
        ({SALMON} -p {threads} index \
           -t {input.transcripts} -i {params.path} -k {params.k})  2> {log}

        """

rule index_repeats_genome_star:
    params:
        genome_dir = op.join(BASE, 'indices', 'star', 'repeatome'),
    input:
        fa = op.join(BASE, 'annotation', op.splitext(op.basename(GENOME_URL))[0]),
        gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL))
    log:
        op.join(BASE, 'indices', 'star', 'repeatome', 'repeats_star_index.log')
    threads:
        NTHREADS
    output:
        op.join(BASE, 'indices', 'star', 'repeatome', 'chrName.txt'),
        op.join(BASE, 'indices', 'star', 'repeatome', 'chrStart.txt'),
        op.join(BASE, 'indices', 'star', 'repeatome', 'chrNameLength.txt')
    shell:
        """
        mkdir -p {params.genome_dir}
        
        ({STAR}  \
        --runMode genomeGenerate \
        --runThreadN {threads} \
        --sjdbGTFfile {input.gtf} \
        --genomeDir {params.genome_dir} \
        --genomeFastaFiles {input.fa}) 2> {log}

        touch {output}
        """

rule index_genes_genome_star:
    params:
        genome_dir = op.join(BASE, 'indices', 'star', 'transcriptome'),
    input:
        fa = op.join(BASE, 'annotation', op.splitext(op.basename(GENOME_URL))[0]),
        gtf = op.join(BASE, 'annotation', op.basename(GENES_GTF_URL))
    output:    
        op.join(BASE, 'indices', 'star', 'transcriptome', 'chrName.txt'),
        op.join(BASE, 'indices', 'star', 'transcriptome', 'chrStart.txt'),
        op.join(BASE, 'indices', 'star', 'transcriptome', 'chrNameLength.txt')
    log:
        op.join(BASE, 'indices', 'star', 'transcriptome', 'genes_star_index.log')
    threads:
        NTHREADS
    shell:
        """
        mkdir -p {params.genome_dir}

        ({STAR}  \
        --runMode genomeGenerate \
        --runThreadN {threads} \
        --sjdbGTFfile {input.gtf} \
        --genomeDir {params.genome_dir} \
        --genomeFastaFiles {input.fa}) 2> {log}

        touch {output}
        """
        
rule bowtie_index_repeatome_bowtie:
    input:
        fa =  op.join(BASE, 'annotation',
                      op.splitext(op.basename(DFAM_EMBL_URL))[0] + '.fa.gz')
    threads: NTHREADS
    params:
        label = op.join(BASE, 'indices', 'bowtie', 'repeatome',
                        op.splitext(op.basename(DFAM_EMBL_URL))[0]),
        path =  op.join(BASE, 'indices', 'bowtie', 'repeatome')
    log:
        op.join(BASE, 'indices', 'bowtie', 'repeatome', 'bowtie_repeatome.log')
    output:
        o1 = op.join(BASE, 'indices', 'bowtie', 'repeatome',
                     op.splitext(op.basename(DFAM_EMBL_URL))[0]) + '.1.ebwt',
        o2 = op.join(BASE, 'indices', 'bowtie', 'repeatome',
                     op.splitext(op.basename(DFAM_EMBL_URL))[0]) + '.2.ebwt',
        o3 = op.join(BASE, 'indices', 'bowtie', 'repeatome',
                     op.splitext(op.basename(DFAM_EMBL_URL))[0]) + '.3.ebwt',
        o4 = op.join(BASE, 'indices', 'bowtie', 'repeatome',
                     op.splitext(op.basename(DFAM_EMBL_URL))[0]) + '.4.ebwt',
        o1rev = op.join(BASE, 'indices', 'bowtie', 'repeatome',
                        op.splitext(op.basename(DFAM_EMBL_URL))[0]) + '.rev.1.ebwt',
        o2rev = op.join(BASE, 'indices', 'bowtie', 'repeatome',
                        op.splitext(op.basename(DFAM_EMBL_URL))[0]) + '.rev.2.ebwt'
    shell:
        """
        mkdir -p {params.path}
        
        ({BOWTIE_BUILD} {input.fa} {params.label} --threads {threads}) 2> {log}
        """
        
## Indexing end ------------------------------------------------------------------------------- ##

## Genome, transcriptome and repeatome retrieval start ---------------------------------------- ##

rule uncompress_genome:
    params:
        genome_dir = op.join(BASE, 'annotation'),
    input:
        fagz = op.join(BASE, 'annotation', op.basename(GENOME_URL))
    output:
        temp(op.join(BASE, 'annotation', op.splitext(op.basename(GENOME_URL))[0]))
    shell:
        """
        {PIGZ} --decompress -p {threads}  {input.fagz}
        """
        
rule compress_repeatome_fasta:
    input:
        op.join(BASE, 'annotation',
                op.splitext(op.basename(DFAM_EMBL_URL))[0] + '.fa')
    output:
        op.join(BASE, 'annotation',
                op.splitext(op.basename(DFAM_EMBL_URL))[0] + '.fa.gz')
    threads: NTHREADS
    shell:
        """
        {PIGZ} -p {threads} {input}
        """

rule get_transcriptome_cdna:
    params:
        url = TRANSCRIPTOME_URL
    output:
        fa = op.join(BASE, 'annotations', op.basename(TRANSCRIPTOME_URL))
    shell:
        """    
        curl -s -L -C - {params.url} -o {output.fa}
        """   
rule get_repeatome_fasta:
    input:
        # op.join(BASE, 'indices', op.basename(DFAM_EMBL_URL))
        # HTTP.remote(DFAM_EMBL_URL, keep_local=True)
        op.join(BASE, 'annotation', op.splitext(op.basename(DFAM_EMBL_URL))[0])
    output:
        temp(op.join(BASE, 'annotation',
                     op.splitext(op.basename(DFAM_EMBL_URL))[0] + '.fa'))
    # conda:
    #     "envs/repeats_env.yaml"
    shell:
        """
        {BIOPYTHON_CONVERT} {input} embl {output} fasta
        """

rule uncompress_repeatome:
    input:
        op.join(BASE, 'annotation', op.basename(DFAM_EMBL_URL))
    output:
        temp(op.join(BASE, 'annotation', op.splitext(op.basename(DFAM_EMBL_URL))[0]))
    threads: NTHREADS
    shell:
        """
        {PIGZ} --decompress -p {threads} {input}
        """
    
rule get_repeatome_embl:
    params:
        url = DFAM_EMBL_URL
    output:
        temp(op.join(BASE, 'annotation', op.basename(DFAM_EMBL_URL)))
    shell:
        """
        curl -s -L -C - {params.url} -o {output}
        """

## hg38 hardcoded
rule get_genome_fasta:
    output:
        op.join(BASE, 'annotation', op.basename(GENOME_URL))
    params:
        url = GENOME_URL
    shell:
        """
        curl -s -L -C - {params.url} -o {output}
        """
      
rule get_repeats_gtf:
    params:
        url = REP_GTF_URL,
        genome_path = op.join(BASE, 'annotation')
    output:
        op.join(BASE, 'annotation', op.basename(REP_GTF_URL))
    shell:
        """        
        curl -s -L -C - {params.url} -o {output}
        """
        
rule get_genes_gtf:
    params:
        url = GENES_GTF_URL
    output:
        gtf = op.join(BASE, 'annotation', op.basename(GENES_GTF_URL))
    shell:
        """    
        curl -s -L -C - {params.url} -o {output.gtf}
        """
      
## Genome, transcriptome and repeatome retrieval end   ---------------------------------------- ##
