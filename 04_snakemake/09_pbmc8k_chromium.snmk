#!/usr/bin/env snakemake -s
## 
## Started 10 June
## This is chromium v2 https://support.10xgenomics.com/single-cell-gene-expression/datasets/2.1.0/pbmc8k
## pbmcs from a healthy donnor
##
## Izaskun Mallona
## GPLv3

import os.path as op
from glob import glob

configfile: op.join('config', 'config_09_pbmc8k_chromium.yaml')

try:
   if not op.exists(op.dirname(op.join(config["base"], 'annotation'))):
      os.makedirs(op.join(config["base"], 'annotation'))
except OSError as err:
   print(err)
      
for item in ['bowtie', 'star', 'salmon']:
   try:
      if not op.exists(op.dirname(op.join(config["base"], 'indices', item))):
         os.makedirs(op.join(config["base"], 'indices', item))
   except OSError as err:
      print(err)
      
## Folder structure end ----------------------------------------------------------------------- ##

include: "/home/imallona/src/repeats_sc/04_snakemake/chromium_flow_with_config.snmk"

## num of bams processed at once in a featurecounts run; equal cells
NUM_BAMS = 40

    
# rule all:
#     input:
#         op.join(config["base"], 'runs', config["run_name"], 'cellranger_repeats', 'run.log'),
#         op.join(config["base"], 'runs', config["run_name"], 'cellranger_standard', 'outs',  'web_summary.html'),
#         op.join(config["base"], 'runs', config["run_name"], 'cellranger_repeats', 'outs', 'web_summary.html'),
#         expand(op.join(config["base"], 'runs', config["run_name"], config["run_name"] + '_pbmc_chromium_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.html'),
#                regress_ncount = ['TRUE', 'FALSE'],
#                regress_nfeature = ['TRUE', 'FALSE']),
#         op.join(config["base"], "runs", config["run_name"], 'count_repeats_on_cellranger_standard_not_overlapping_genes',
#                 config["run_name"] + "_repeats_not_overlapping_genes.counts.gz"),
#         expand(op.join(config["base"], "runs", config["run_name"],
#                         "count_repeats_on_cellranger_standard",
#                         "{multimappers}",
#                         config["run_name"] + "_transcriptome_repeats.counts.summary.png"),
#                 multimappers = ['multimappers', 'unique_reads']),
#         expand(op.join(config["base"], "runs", config["run_name"],
#                         "count_repeats_on_cellranger_standard_not_overlapping_genes",
#                         "{multimappers}",
#                         config["run_name"] + "_transcriptome_repeats_not_genes.counts.summary.png"),
#                  multimappers = ['multimappers', 'unique_reads']),
#         op.join(config["base"], 'runs', config["run_name"], 'alevin', 'genes', 'alevin', 'quants_mat.gz'),
#         op.join(config["base"], 'runs', config["run_name"], 'alevin', 'repeats', 'alevin', 'quants_mat.gz'),
#                regress_ncount = ['TRUE', 'FALSE'],
#                regress_nfeature = ['TRUE', 'FALSE']),
#         expand(op.join(config["base"], "runs", config["run_name"], 'bowtie_repeatome',
#                        '{multimappers}',
#                        "all_cells_repeats.counts.gz"),
#                multimappers = ['unique_reads'])
  
rule all:
    input:
        expand(op.join(config["base"], 'runs', config["run_name"], config["run_name"] + '_pbmc_chromium_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.html'),
               regress_ncount = ['FALSE'],
               regress_nfeature = ['FALSE']),
        expand(op.join(config['base'], "runs", config['run_name'],
                '{task}',
                '{multimappers}',
                       config['run_name'] + "_repeats.counts.gz"),
               multimappers = ['multimappers', 'unique_reads'],
               task = ['count_repeats_on_cellranger_standard',
                       'count_repeats_on_cellranger_standard_not_overlapping_genes']),
        expand(op.join(config['base'], "runs", config['run_name'],
                '{task}',
                '{multimappers}',
                       config['run_name'] + "_repeats.counts.gz"),
               multimappers = ['unique_reads'],
               task = ['bowtie_repeatome'])
               
# rule knit_pbmc8:
#     input:
#         genes = op.join(config['base'], 'runs', config['run_name'],
#                         'cellranger_standard', 'outs',
#                         'filtered_feature_bc_matrix', 'barcodes.tsv.gz'),
#         repeats = op.join(config['base'], 'runs', config['run_name'],
#                           'cellranger_repeats', 'outs', 'filtered_feature_bc_matrix',
#                           'barcodes.tsv.gz'),
#         featurecounts_multi = op.join(config['base'], "runs", config['run_name'],
#                                       'count_repeats_on_cellranger_standard',
#                                       'multimappers',
#                                       config['run_name'] + "_repeats.counts.gz"),
#         featurecounts_unique = op.join(config['base'], "runs", config['run_name'],
#                                       'count_repeats_on_cellranger_standard',
#                                       'unique_reads',
#                                       config['run_name'] + "_repeats.counts.gz"),
#         repeats_only_featurecounts_control_multi = op.join(
#             config['base'], "runs", config['run_name'],
#             'count_repeats_on_cellranger_standard_not_overlapping_genes',
#             'multimappers',
#             config['run_name'] + "_repeats_not_overlapping_genes.counts.gz"),
#         repeats_only_featurecounts_control_unique = op.join(
#             config['base'], "runs", config['run_name'],
#             'count_repeats_on_cellranger_standard_not_overlapping_genes',
#             'unique_reads',
#             config['run_name'] + "_repeats_not_overlapping_genes.counts.gz"),
#         # repeats_bowtie_multi = op.join(
#         #     config['base'], "runs", config['run_name'],
#         #     'bowtie_repeatome',
#         #     'multimappers',
#         #     'all_cells_repeats.counts.gz'),
#         repeats_bowtie_unique = op.join(
#             config['base'], "runs", config['run_name'],
#             'bowtie_repeatome',
#             'unique_reads',
#             'all_cells_repeats.counts.gz'),
#         genes_alevin = op.join(config['base'], 'runs', config['run_name'], 'alevin',
#                                'genes', 'alevin',
#                                'quants_mat.gz'),
#         repeats_alevin = op.join(config['base'], 'runs', config['run_name'], 'alevin',
#                                  'repeats', 'alevin',
#                                  'quants_mat.gz')
        
            
#     params:
#         rmd = op.join('scripts', 'summarize_chromium_run_pbmcs.Rmd'),
#         run_name = config['run_name'],
#         Rscript = config['software']['Rscript'],
#         aris = op.join(config['base'], 'runs', config['run_name'], config['run_name'] + '_aris_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.rds'),
#     output:
#         html = op.join(config['base'], 'runs', config['run_name'], config['run_name'] + '_pbmc_chromium_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.html'),
#         rds = op.join(config['base'], 'runs', config['run_name'], config['run_name'] + '_pmbc_chromium_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.rds'),
#         # aris = op.join(config['base'], 'runs', config['run_name'], config['run_name'] + '_aris_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.rds'),
#         cobra = op.join(config['base'], 'runs', config['run_name'], config['run_name'] + '_cobra_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.rds'),
#         markers = op.join(config['base'], 'runs', config['run_name'], config['run_name'] + '_markers_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.rds')
#     log:
#         op.join(config['base'], 'runs', config['run_name'], config['run_name'] + 'summarize_chromium_run_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.log')
#     shell:
#         """
#         {params.Rscript} -e 'rmarkdown::render(\"{params.rmd}\", 
#           output_file = \"{output.html}\", 
#           params = list(identifier = \"{params.run_name}\", 
#                      genes_cellranger = \"{input.genes}\", 
#                      repeats_cellranger = \"{input.repeats}\", 
#                      markers_output = \"{output.markers}\", 
#                      repeats_featurecounts_multi = \"{input.featurecounts_multi}\", 
#                      repeats_featurecounts_unique = \"{input.featurecounts_unique}\",
#                      repeats_only_featurecounts_control_multi = \"{input.repeats_only_featurecounts_control_multi}\", 
#                      repeats_only_featurecounts_control_unique = \"{input.repeats_only_featurecounts_control_unique}\",
#                      seurat_output = \"{output.rds}\", 
#                      aris_output = \"{params.aris}\", 
#                      regress_genes_nCount = \"{wildcards.regress_ncount}\", 
#                      regress_genes_nFeature = \"{wildcards.regress_nfeature}\",
#                      repeats_bowtie_unique = \"None\", 
#                      genes_alevin = \"{input.genes_alevin}\",
#                      repeats_alevin = \"{input.repeats_alevin}\",
#                      cobra_output = \"{output.cobra}\"))' &> {log}
#         """
        
rule get_pbmc_8k:
    priority: 100
    params:
        url = 'http://s3-us-west-2.amazonaws.com/10x.files/samples/cell-exp/2.1.0/pbmc8k/pbmc8k_fastqs.tar',
        path = op.join(config["base"], 'data', config["run_name"]),
    output:
        fn = temp(op.join(config["base"], 'data', config["run_name"], 'pbmc8k_fastqs.tar')),
        uncompressed =  op.join(config["base"], 'data', config["run_name"], 'pbmc8k_S1_L007_I1_001.fastq.gz')
    shell:
        """    
        mkdir -p {params.path}
        cd {params.path}
        curl -s -L -C - {params.url} -O {output.fn}
        tar xvf {output.fn}
        mv fastqs/*fastq.gz .
        """

rule run_cellranger_repeats:
    input:
        flag = op.join(config["base"], 'data', config["run_name"], 'pbmc8k_S1_L007_I1_001.fastq.gz'),
        transcriptome_flag = op.join(config["base"], 'indices', 'cellranger',
                                     'repeats_' + config["genome"],
                                     'repeats_' + config["genome"], 'reference.json')
    params:
        fastqs_path = op.join(config["base"], 'data', config["run_name"]),
        sample_name = config["run_name"],
        local_mem_gb = config["params"]["local_mem_gb"],
        processing_path = op.join(config["base"], 'runs', config["run_name"]),
        transcriptome = op.join(config["base"], 'indices', 'cellranger', 'repeats_' + config["genome"], 'repeats_' + config["genome"]),
        cellranger = config['software']['cellranger'],
        
    output:
        op.join(config["base"], 'runs', config["run_name"], 'cellranger_repeats', 'outs', 'web_summary.html'),
        op.join(config["base"], 'runs', config["run_name"], 'cellranger_repeats', 'outs', 'filtered_feature_bc_matrix', 'barcodes.tsv.gz')
    threads:
        config["params"]["nthreads"]
    log:
        op.join(config["base"], 'runs', config["run_name"], 'cellranger_repeats', 'run.log')
    shell:
        """
        mkdir -p {params.processing_path}
        cd {params.processing_path}
        rm -rf cellranger_repeats
        
        {params.cellranger} count --id=cellranger_repeats \
          --fastqs={params.fastqs_path} \
          --transcriptome={params.transcriptome} \
          --jobmode=local \
          --localcores={threads} \
          --sample={params.sample_name} \
          --localmem={params.local_mem_gb}
        """


rule run_cellranger_standard:
    params:
        fastqs_path = op.join(config["base"], 'data', config["run_name"]),
        sample_name = config["run_name"],
        local_mem_gb = config["params"]["local_mem_gb"],
        processing_path = op.join(config["base"], 'runs', config["run_name"]),
        cellranger = config['software']['cellranger']
    input:
        flag = op.join(config["base"], 'data', config["run_name"],
                       'pbmc8k_S1_L007_I1_001.fastq.gz'),
        transcriptome = op.join(config["base"], 'indices', 'cellranger',
                                'refdata-cellranger-GRCh38-3.0.0')
    output:
        op.join(config["base"], 'runs', config["run_name"], 'cellranger_standard',
                'outs', 'web_summary.html'),
        op.join(config["base"], 'runs', config["run_name"], 'cellranger_standard',
                'outs', 'filtered_feature_bc_matrix', 'barcodes.tsv.gz'),
        op.join(config["base"], 'runs', config["run_name"], 'cellranger_standard',
                'outs', 'possorted_genome_bam.bam')
    threads:
        config["params"]["nthreads"]
    log:
        op.join(config["base"], 'runs',  config["run_name"], 'cellranger_standard', 'run.log')
    shell:
        """
        mkdir -p {params.processing_path}
        cd {params.processing_path}
        rm -rf cellranger_standard
        
        {params.cellranger} count --id=cellranger_standard \
          --fastqs={params.fastqs_path} \
          --transcriptome={input.transcriptome} \
          --jobmode=local \
          --localcores={threads} \
          --sample={params.sample_name} \
          --localmem={params.local_mem_gb}
        """
 
rule map_salmon_repeats_chromium:
    input:        
        tgmap = op.join(config["base"], 'indices', 'salmon', config["genome"], 'repeats_salmon', 'txp2gene.tsv'),
        idx_tracker = op.join(config["base"], 'indices', 'salmon', config["genome"], 'repeats_salmon', 'duplicate_clusters.tsv'),
        cb = sorted(glob(op.join(config["base"], 'data', config["run_name"], '*R1*fastq.gz'))),
        r2 = sorted(glob(op.join(config["base"], 'data', config["run_name"], '*R2*fastq.gz')))        
    output:
        op.join(config["base"], 'runs', config["run_name"], 'alevin', 'repeats', 'alevin', 'quants_mat.gz')
    threads:
        config["params"]["nthreads"]
    params:
        fastqs_path = op.join(config["base"], 'data', config["run_name"]),
        processing_path = op.join(config["base"], 'runs', config["run_name"], 'alevin', 'repeats'),
        salmon_idx = op.join(config["base"], 'indices', 'salmon', config["genome"], 'repeats_salmon'),
        cb = ' '.join(sorted(glob(op.join(config["base"], 'data', config["run_name"], '*R1*fastq.gz')))),
        r2 = ' '.join(sorted(glob(op.join(config["base"], 'data', config["run_name"], '*R2*fastq.gz')))),
         salmon = config["software"]["salmon"]
    log:
        op.join(config["base"], 'runs', config["run_name"], 'run_salmon_repeats_chromium.log')
    shell:
        """
    mkdir -p {params.processing_path}
    cd {params.processing_path}

    ({params.salmon} alevin \
    -l ISR \
    -1 {params.cb} \
    -2 {params.r2} \
    --chromium  \
    -i {params.salmon_idx} \
    -p {threads} -o {params.processing_path} \
    --tgMap {input.tgmap} ) 2> {log}

    touch -c {output}
        """
    
 
## beware the cb path for pbmc5k, they shouldn't be there at `config["run_name"] + '_fastqs/` subfoder
rule map_salmon_genes_chromium:
    input:        
        tgmap = op.join(config["base"], 'indices', 'salmon', config["genome"], 'genes_salmon', 'txp2gene.tsv'),
        idx_tracker = op.join(config["base"], 'indices', 'salmon', config["genome"], 'genes_salmon', 'duplicate_clusters.tsv'),
        cb = sorted(glob(op.join(config["base"], 'data', config["run_name"], '*R1*fastq.gz'))),
        r2 = sorted(glob(op.join(config["base"], 'data', config["run_name"], '*R2*fastq.gz')))        
    output:
        op.join(config["base"], 'runs', config["run_name"], 'alevin', 'genes', 'alevin', 'quants_mat.gz')
    threads:
        config["params"]["nthreads"]
    params:
        fastqs_path = op.join(config["base"], 'data', config["run_name"]),
        processing_path = op.join(config["base"], 'runs', config["run_name"], 'alevin', 'genes'),
        salmon_idx = op.join(config["base"], 'indices', 'salmon', config["genome"], 'genes_salmon'),
        cb = ' '.join(sorted(glob(op.join(config["base"], 'data', config["run_name"], '*R1*fastq.gz')))),
        r2 = ' '.join(sorted(glob(op.join(config["base"], 'data', config["run_name"], '*R2*fastq.gz')))),
        salmon = config["software"]["salmon"]
    log:
        op.join(config["base"], 'runs', config["run_name"], 'run_salmon_genes_chromium.log')
    shell:
        """
    mkdir -p {params.processing_path}
    cd {params.processing_path}

    ({params.salmon} alevin \
    -l ISR \
    -1 {params.cb} \
    -2 {params.r2} \
    --chromium  \
    -i {params.salmon_idx} \
    -p {threads} -o {params.processing_path} \
    --tgMap {input.tgmap} ) 2> {log}

    touch -c {output}
        """
