#!/usr/bin/env snakemake -s
## 
## Started 12 May
##
## Warning fastqs are misannotated in GEO
## https://trace.ncbi.nlm.nih.gov/Traces/sra/?run=SRR9169209
# https://trace.ncbi.nlm.nih.gov/Traces/sra/?run=SRR9169439 . 
# one has three reads 31, 50 and 8 in length
# the other one has 50, 50 and 10 nt

##
## Izaskun Mallona
## GPLv3


print('caution for some steps report only takes one SRR! @todo check')
import os
import os.path as op
from glob import glob
import re

# import pandas as pd

print('This is human')
print('Cel-seq2')
print('this comes from https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE132044')

## Folder structure start --------------------------------------------------------------------- ##


## config file start ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# configfile: "config.yaml"
# validate(config, "schemas/config.schema.yaml")

# samples = pd.read_csv(config["samples"], sep = '\t').set_index("id", drop=False)
#@FIXME to be moved to config, not hardcoded!
BASE = op.join('/home', 'imallona', 'repeats_sc')
NTHREADS = 10
LOCAL_MEM_GB = 100

RUN_NAME  = 'ding_celseq2'
RUN_TECH = 'celseq2'
GENOME = 'GRCh38'

CONF =  op.join(BASE, "data", RUN_NAME, 'celseq2_ding.conf')

GENOME_URL = 'ftp://ftp.ensembl.org/pub/release-98/fasta/homo_sapiens/dna/Homo_sapiens.GRCh38.dna.primary_assembly.fa.gz'
GENES_GTF_URL = 'ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_33/gencode.v33.primary_assembly.annotation.gtf.gz'
REP_GTF_URL = 'http://labshare.cshl.edu/shares/mhammelllab/www-data/TEtranscripts/TE_GTF/GRCh38_rmsk_TE.gtf.gz'

GTF_MAKING_SCRIPT = '~/src/repeats_sc/04_snakemake/gtf_maker.R'
GTF_PARSING_RSCRIPT = '~/src/repeats_sc/04_snakemake/gtf_parser.R'
FEATURECOUNTS_RSCRIPT= '~/src/repeats_sc/04_snakemake/plot_featurecounts_profile.R'

BOWTIE_BUILD = '/home/imallona/soft/bowtie/bowtie-1.2.3/bowtie-build'
BOWTIE = '/home/imallona/soft/bowtie/bowtie-1.2.3/bowtie'

##pigz 2.3.1
PIGZ = '/usr/bin/pigz'
BIOPYTHON_CONVERT='biopython.convert'
STAR = '~/soft/star/STAR-2.7.3a/source/STAR'
FEATURECOUNTS = '~/soft/subread/subread-2.0.0-source/bin/featureCounts'
# SALMON = '~/soft/salmon/salmon-1.1.0_linux_x86_64/bin/salmon'
SALMON='~/soft/salmon/salmon-1.2.1/bin/salmon'
CELLRANGER = '~/soft/cellranger/cellranger-3.1.0/cellranger'
BIOAWK = '~/soft/bioawk/bioawk'
BEDTOOLS = '~/soft/bedtools/bedtools-2.29.2/bin/bedtools'
Rscript = '/usr/local/R/R-3.6.1/bin/Rscript'
FASTQDUMP= '~/soft/sra-toools/sratoolkit.2.10.4-ubuntu64/bin/fastq-dump' # fastq-dump : 2.10.4
PREFETCH= '~/soft/sra-toools/sratoolkit.2.10.4-ubuntu64/bin/prefetch' # fastq-dump : 2.10.4
VDBVALIDATE= '~/soft/sra-toools/sratoolkit.2.10.4-ubuntu64/bin/vdb-validate' # fastq-dump : 2.10.4
# FASTQDUMP= '~/soft/sra-toools/sratoolkit.2.10.5-ubuntu64/bin/fastq-dump' #
# FASTERQDUMP= '~/soft/sra-toools/sratoolkit.2.10.5-ubuntu64/bin/fasterq-dump' #
# VDB_VALIDATE = '~/soft/sra-toools/sratoolkit.2.10.5-ubuntu64/bin/vdb-validate'
BEDOPS = '~/soft/bedops/bedops-2.4.39/bin/'
## FASTQS, = glob_wildcards(op.join(BASE, "data", RUN_NAME, "{sample}.fastq.gz"))


## include: "/home/imallona/src/repeats_sc/04_snakemake/rnaseq_like_human_paired_end.snmk"

try:
   if not op.exists(op.dirname(op.join(BASE, 'annotation'))):
      os.makedirs(op.join(BASE, 'annotation'))
except OSError as err:
   print(err)
      
for item in ['bowtie', 'star', 'salmon']:
   try:
      if not op.exists(op.dirname(op.join(BASE, 'indices', item))):
         os.makedirs(op.join(BASE, 'indices', item))
   except OSError as err:
      print(err)


def write_config(conf):
        path = op.join(BASE, "data", RUN_NAME)
        if not op.exists(path):
           os.makedirs(path)
        
        with open(conf, "w+") as fh:
           fh.writelines("""SRR9169442,RNA-Seq,89,406444488,PRJNA545730,SAMN11914621,254766791,GEO,public,"fastq,sra","gs,ncbi,s3","gs.US,ncbi.public,s3.us-east-1",SRX5943797,Illumina HiSeq 2500,PAIRED,cDNA,TRANSCRIPTOMIC,Homo sapiens,ILLUMINA,2019-06-05T00:00:00Z,GSM3837177,SRP200058,GSM3837177,CEL-Seq2,female,Peripheral blood mononuclear cell,,
SRR9169443,RNA-Seq,89,4636831826,PRJNA545730,SAMN11914620,2933786676,GEO,public,"fastq,sra","gs,ncbi,s3","gs.US,ncbi.public,s3.us-east-1",SRX5943798,Illumina HiSeq 2500,PAIRED,cDNA,TRANSCRIPTOMIC,Homo sapiens,ILLUMINA,2019-06-05T00:00:00Z,GSM3837178,SRP200058,GSM3837178,Drop-seq,female,Peripheral blood mononuclear cell,,
SRR9169439,RNA-Seq,89,1040755142,PRJNA545730,SAMN11914624,649516457,GEO,public,"fastq,sra","gs,ncbi,s3","gs.US,ncbi.public,s3.us-east-1",SRX5943794,Illumina HiSeq 2500,PAIRED,cDNA,TRANSCRIPTOMIC,Homo sapiens,ILLUMINA,2019-06-05T00:00:00Z,GSM3837174,SRP200058,GSM3837174,CEL-Seq2,female,Peripheral blood mononuclear cell,,
SRR9169441,RNA-Seq,89,1094064184,PRJNA545730,SAMN11914622,682967510,GEO,public,"fastq,sra","gs,ncbi,s3","gs.US,ncbi.public,s3.us-east-1",SRX5943796,Illumina HiSeq 2500,PAIRED,cDNA,TRANSCRIPTOMIC,Homo sapiens,ILLUMINA,2019-06-05T00:00:00Z,GSM3837176,SRP200058,GSM3837176,CEL-Seq2,female,Peripheral blood mononuclear cell,,""")

           

def get_samples(fn):
    # samples = pd.read_table(fn)
   write_config(fn)
   samples = []
   with open(fn) as fh:
    for line in fh: 
        samples.append(line.split(',')[0].strip())
    return(samples)

rule all:
    input:
        expand(op.join(BASE, "data", RUN_NAME, "{srr}_1.fastq.gz"),
               srr = get_samples(op.join(BASE, 'data', RUN_NAME, 'celseq2_ding.conf'))),
        expand(op.join(BASE, "runs", RUN_NAME, 'star_transcriptome', "{srr}_Aligned.sortedByCoord.out.bam"),  srr = get_samples(op.join(BASE, 'data', RUN_NAME, 'celseq2_ding.conf'))),
        expand(op.join(BASE, "runs", RUN_NAME, "star_transcriptome", 'repeats_no_overlap', "{srr}_Aligned.sortedByCoord.out.bam.featureCounts.gz"),
               srr = get_samples(op.join(BASE, 'data', RUN_NAME, 'celseq2_ding.conf'))),
        # expand(op.join(BASE, "runs", RUN_NAME, "star_transcriptome", 'repeats', "{srr}_Aligned.sortedByCoord.out.bam.featureCounts.gz"), srr = get_samples(op.join(BASE, 'data', RUN_NAME, 'celseq2_ding.conf'))),
        # expand(op.join(BASE, "runs", RUN_NAME, "star_transcriptome", 'genes', "{srr}_Aligned.sortedByCoord.out.bam.featureCounts.gz"), srr = get_samples(op.join(BASE, 'data', RUN_NAME, 'celseq2_ding.conf'))),        
        expand(op.join(BASE, "runs", RUN_NAME, "star_transcriptome", 'genes', "{srr}_star_transcriptome_genes.counts.summary.png"), 
               srr = get_samples(op.join(BASE, 'data', RUN_NAME, 'celseq2_ding.conf'))),
        expand(op.join(BASE, "runs", RUN_NAME, "star_transcriptome", 'repeats', "{srr}_Aligned.sortedByCoord.out.bam.counts.summary"), 
               srr = get_samples(op.join(BASE, 'data', RUN_NAME, 'celseq2_ding.conf'))),
        expand(op.join(BASE, "runs", RUN_NAME, "star_transcriptome", 'repeats', "{srr}_star_transcriptome_repeats.counts.summary.png"), 
               srr = get_samples(op.join(BASE, 'data', RUN_NAME, 'celseq2_ding.conf'))),
        expand(op.join(BASE, "runs", RUN_NAME, "star_transcriptome", 'repeats_no_overlap',
                       "{srr}_repeats_no_overlap.counts.summary.png"), 
               srr = get_samples(op.join(BASE, 'data', RUN_NAME, 'celseq2_ding.conf'))),
        expand(op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome", "{srr}_bowtie_repeats.counts.summary.png"),
               srr = get_samples(op.join(BASE, 'data', RUN_NAME, 'celseq2_ding.conf'))),
        expand(op.join(BASE, 'runs', RUN_NAME, RUN_NAME + '_pbmc_celseq2_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.html'),
               regress_ncount = ['TRUE', 'FALSE'],
               regress_nfeature = ['TRUE', 'FALSE']),
        expand(op.join(BASE, 'runs', RUN_NAME, 'alevin', 'genes', 'alevin',
                       'quants_mat.gz')),
        expand(op.join(BASE, 'runs', RUN_NAME, 'alevin', 'repeats', 'alevin',
                       'quants_mat.gz')),
        expand( op.join(BASE, 'runs', RUN_NAME, RUN_NAME + '_pbmc_celseq2_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.html'),
                regress_ncount = ['TRUE', 'FALSE'],
                regress_nfeature = ['TRUE', 'FALSE']),
        # op.join(BASE, "runs", RUN_NAME, "star_transcriptome", 'genes', RUN_NAME + "_star_genes.counts.gz"),
        # expand(op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome", RUN_NAME + "{srr}_bowtie_repeats.counts.gz"), srr = get_samples(op.join(BASE, 'data', RUN_NAME, 'celseq2_ding.conf')))
        # op.join(BASE, "runs",RUN_NAME, "star_transcriptome", 'repeats', RUN_NAME + '_star_transcriptome_repeats.counts.gz'),
        # op.join(BASE, "runs", RUN_NAME, 'star_transcriptome', 'repeats', RUN_NAME + "_repeats_not_overlapping_genes.counts.gz"),
        # expand(op.join(BASE, 'runs', RUN_NAME, RUN_NAME + '_pbmc_smartseq2_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.html'),
        #        regress_ncount = ['TRUE', 'FALSE'],
        #        regress_nfeature = ['TRUE', 'FALSE'])
      

ruleorder: deal_with_umis_r1 > deal_with_umis_r2 > get_data



rule knit_report_celseq_ad_hoc_ding:
    input:
        # genes_star = op.join(BASE, 'runs', RUN_NAME, 'star_transcriptome', 'genes', RUN_NAME + '_star_genes.counts.gz'),
        # repeats_star = op.join(BASE, 'runs', RUN_NAME, 'star_transcriptome', 'repeats', RUN_NAME + '_star_transcriptome_repeats.counts.gz'),
        # repeats_bowtie = op.join(BASE, 'runs', RUN_NAME, 'bowtie_repeatome', RUN_NAME + '_bowtie_repeats.counts.gz'),
        # repeats_no_overlap_star = op.join(BASE, "runs", RUN_NAME, 'star_transcriptome', 'repeats_no_overlap', RUN_NAME + "_repeats_not_overlapping_genes.counts.gz")
        # repeats_no_overlap_star = op.join(BASE, "runs", RUN_NAME, 'star_transcriptome/repeats_no_overlap/SRR9169209_repeats_no_overlap.counts.gz'),
        # genes_star = op.join(BASE, "runs", RUN_NAME, 'star_transcriptome', 'genes', 'SRR9169209_Aligned.sortedByCoord.out.bam.counts.gz'),
        # repeats_star = op.join(BASE, "runs", RUN_NAME, 'star_transcriptome/repeats/SRR9169209_Aligned.sortedByCoord.out.bam.counts.gz'),
        # repeats_bowtie =  op.join(BASE, "runs", RUN_NAME, 'bowtie_repeatome/SRR9169209_bowtie_repeats.counts.gz')
        # genes_alevin1 = op.join(BASE, 'runs', RUN_NAME, 'alevin', 'genes',  "male", 'alevin', 'quants_mat.gz'),
        genes_alevin2 = op.join(BASE, 'runs', RUN_NAME, 'alevin', 'genes', 'alevin', 'quants_mat.gz'),
        # repeats_alevin1 = op.join(BASE, 'runs', RUN_NAME, 'alevin', 'repeats',  "male", 'alevin', 'quants_mat.gz'),
        repeats_alevin2 = op.join(BASE, 'runs', RUN_NAME, 'alevin', 'repeats',  'alevin', 'quants_mat.gz')
    params:
        rmd = 'summarize_celseq_run_pbmcs.Rmd',
        run_name = RUN_NAME
    output:
        html = op.join(BASE, 'runs', RUN_NAME, RUN_NAME + '_pbmc_celseq2_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.html'),
        rds = op.join(BASE, 'runs', RUN_NAME, RUN_NAME + '_pmbc_celseq2_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.rds'),
        aris = op.join(BASE, 'runs', RUN_NAME, RUN_NAME + '_aris_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.rds')
    log:
        op.join(BASE, 'runs', RUN_NAME, RUN_NAME + 'summarize_celseq2_run_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.log')
    shell:
        """
        {Rscript} -e 'rmarkdown::render(\"{params.rmd}\", 
          output_file = \"{output.html}\", 
          params = list(identifier = \"{params.run_name}\", 
          genes_alevin2 = \"{input.genes_alevin2}\",
          repeats_alevin2 = \"{input.repeats_alevin2}\",
          seurat_output = \"{output.rds}\", 
          aris_output = \"{output.aris}\", 
          regress_genes_nCount = \"{wildcards.regress_ncount}\", \
          regress_genes_nFeature = \"{wildcards.regress_nfeature}\"))' &> {log}
        """

"""
564 cells to be expected! treat runs separately
https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE132044
https://www.ncbi.nlm.nih.gov/Traces/study/?acc=PRJNA545730&o=acc_s%3Aa

[imallona@neutral Downloads]$ less GSE132044_pbmc_hg38_cell.tsv | grep CEL  | grep PBM  | wc -l
564

[imallona@neutral Downloads]$ less GSE132044_pbmc_hg38_cell.tsv | grep CEL  | grep PBM | cut -f2 -d"-" | sort | uniq -c
    139 Seq2.1
    147 Seq2.2
    144 Seq2.3
    134 Seq2.4

[imallona@neutral Downloads]$ less GSE132044_pbmc_hg38_cell.tsv | grep CEL  | grep PBM | cut -f1 -d"-" | sort | uniq -c
    257 PBMC1.CEL
    307 PBMC2.CEL
"""

print('reduced and duplicated the srr to the one with 31 nt in read 1!')


def list_cbs(wildcards):
   fastqs_path = op.join(BASE, 'data', RUN_NAME)
   # fns = sorted(filter(re.compile('SR.*[0-9]_1.fastq.gz').match, os.listdir(fastqs_path)))
   fns = [x + '_1.fastq.gz' for x in get_samples(CONF)]
   return([op.join(fastqs_path, x) for x in fns])


def list_r2s(wildcards):
   # fns = sorted(filter(re.compile('SR.*[0-9]_2.fastq.gz').match, os.listdir(fastqs_path)))
   fastqs_path = op.join(BASE, 'data', RUN_NAME)
   fns = [x + '_2.fastq.gz' for x in get_samples(CONF)]
   return([op.join(fastqs_path, x) for x in fns])




rule run_alevin_celseq2_repeats:
    input:        
        tgmap = op.join(BASE, 'indices', 'salmon', GENOME, 'repeats_salmon', 'txp2gene.tsv'),
        idx_tracker = op.join(BASE, 'indices', 'salmon', GENOME, 'repeats_salmon', 'duplicate_clusters.tsv'),
        cb = list_cbs,
        r2 = list_r2s
        
    output:
        op.join(BASE, 'runs', RUN_NAME, 'alevin', 'repeats',   'alevin', 'quants_mat.gz')
    threads:
        NTHREADS
    params:
        fastqs_path = op.join(BASE, 'data', RUN_NAME),
        processing_path = op.join(BASE, 'runs', RUN_NAME, 'alevin', 'repeats'),
        salmon_idx = op.join(BASE, 'indices', 'salmon', GENOME, 'repeats_salmon'),
        cb = list_cbs,
        r2 = list_r2s
    log:
        op.join(BASE, 'runs', RUN_NAME, 'run_salmon_repeats_chromium.log')
    shell:
        """
    mkdir -p {params.processing_path}
    cd {params.processing_path}

    ({SALMON} alevin \
    -l ISR \
    -1 {params.cb} \
    -2 {params.r2} \
    --celseq2 \
    --dumpFeatures \
    -i {params.salmon_idx} \
    -p {threads} -o {params.processing_path} \
    --tgMap {input.tgmap} ) 2> {log}

    touch -c {output}
        """


rule run_alevin_celseq2_genes:
    input:        
        tgmap = op.join(BASE, 'indices', 'salmon', GENOME, 'genes_salmon', 'txp2gene.tsv'),
        idx_tracker = op.join(BASE, 'indices', 'salmon', GENOME, 'genes_salmon', 'duplicate_clusters.tsv'),
        cb = list_cbs,
        r2 = list_r2s
        
    output:
        op.join(BASE, 'runs', RUN_NAME, 'alevin', 'genes',  'alevin',  'quants_mat.gz')
    threads:
        NTHREADS
    params:
        fastqs_path = op.join(BASE, 'data', RUN_NAME),
        processing_path = op.join(BASE, 'runs', RUN_NAME, 'alevin', 'genes'),
        salmon_idx = op.join(BASE, 'indices', 'salmon', GENOME, 'genes_salmon'),
        cb = list_cbs,
        r2 = list_r2s
    log:
        op.join(BASE, 'runs', RUN_NAME, 'run_salmon_genes_chromium.log')
    shell:
        """
    mkdir -p {params.processing_path}
    cd {params.processing_path}

    ({SALMON} alevin \
    -l ISR \
    -1 {params.cb} \
    -2 {params.r2} \
    --celseq2 \
    --dumpFeatures \
    -i {params.salmon_idx} \
    -p {threads} -o {params.processing_path} \
    --tgMap {input.tgmap} ) 2> {log}

    touch -c {output}
        """



      
rule profile_featurecounts_run_bowtie:
    input:        
        summary = op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome",
                          "{srr}_bowtie_repeats.counts.summary")
    params:
        path = op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome"),
        script = FEATURECOUNTS_RSCRIPT,
        gtf = 'bowtie_repeatome'
    output:
        png = op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome",
                      "{srr}_bowtie_repeats.counts.summary.png")
    threads: 1
    shell:
       """
       cd {params.path}
       
       {Rscript} {params.script} --summary {input.summary} --output {output.png} --identifier {params.gtf}
       """

rule profile_featurecounts_run_genes:
    input:        
        summary = op.join(BASE, "runs", RUN_NAME, "star_transcriptome", "genes",  "{srr}_Aligned.sortedByCoord.out.bam.counts.summary")
    params:
        path = op.join(BASE, "runs", RUN_NAME, "star_transcriptome"),
        script = FEATURECOUNTS_RSCRIPT,
        gtf = 'star_transcriptome_genes'
    output:
        png = op.join(BASE, "runs", RUN_NAME, "star_transcriptome",  "genes", "{srr}_star_transcriptome_genes.counts.summary.png")
    threads: 1
    shell:
       """
       cd {params.path}
       
       {Rscript} {params.script} --summary {input.summary} --output {output.png} --identifier {params.gtf}
       """

       
rule profile_featurecounts_run_repeats_on_transcriptome:
    input:        
        summary = op.join(BASE, "runs", RUN_NAME, "star_transcriptome", 'repeats', "{srr}_Aligned.sortedByCoord.out.bam.counts.summary")
    params:
        path = op.join(BASE, "runs", RUN_NAME, "star_transcriptome"),
        script = FEATURECOUNTS_RSCRIPT,
        gtf = 'star_transcriptome_repeats'
    output:
        png = op.join(BASE, "runs", RUN_NAME, "star_transcriptome", 'repeats',  "{srr}_star_transcriptome_repeats.counts.summary.png")
    threads: 1
    shell:
       """
       cd {params.path}
       
       {Rscript} {params.script} --summary {input.summary} --output {output.png} --identifier {params.gtf}
       """

       
       
rule profile_featurecounts_run_repeats_no_overlap_on_transcriptome:
    input:        
        summary = op.join(BASE, "runs", RUN_NAME, "star_transcriptome", 'repeats_no_overlap',
                          "{srr}_repeats_no_overlap.counts.summary")
    params:
        path = op.join(BASE, "runs", RUN_NAME, "star_transcriptome", 'repeats_no_overlap'),
        script = FEATURECOUNTS_RSCRIPT,
        gtf = 'star_transcriptome_repeats_no_overlap'
    output:
        png = op.join(BASE, "runs", RUN_NAME, "star_transcriptome", 'repeats_no_overlap',
                     "{srr}_repeats_no_overlap.counts.summary.png")
    threads: 1
    shell:
       """
       cd {params.path}
       
       {Rscript} {params.script} --summary {input.summary} --output {output.png} --identifier {params.gtf}
       """
       
# rule profile_featurecounts_run:
#     input:        
#         summary = op.join(BASE, "runs", RUN_NAME, "{flavour}",
#                           "{srr}_{flavour}.counts.summary")
#     params:
#         path = op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome"),
#         script = FEATURECOUNTS_RSCRIPT,
#         flavour = "{flavour}"
#     output:
#         png = op.join(BASE, "runs", RUN_NAME, "{flavour}",
#                       "{srr}_{flavour}.counts.summary.png")
#     threads: 1
#     shell:
#        """
#        cd {params.path}
       
#        {Rscript} {params.script} --summary {input.summary} --output {output.png} --identifier {params.flavour}
#        """
            
# @todo NOTE THE MULTIMAPPING ALLOWED!
rule featurecounts_repeats_repeatome_bowtie:
    input:
        bam = op.join(BASE, "runs", RUN_NAME, 'bowtie_repeatome', "{srr}.bam"),
        gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL)),
        fake_repeatome_gtf = op.join(BASE, 'annotation', 'fake_repeatome_from_' + op.splitext(op.basename(REP_GTF_URL))[0]) + '.gtf.gz'
    output:
        counts  = temp(op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome",  "{srr}_bowtie_repeats.counts")),
        gz_counts = op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome",  "{srr}_bowtie_repeats.counts.gz"),
        detailed = temp(op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome", "{srr}.bam.featureCounts")),
        gz_detailed = op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome", "{srr}.bam.featureCounts.gz"),
        summary = op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome",  "{srr}_bowtie_repeats.counts.summary")
    params:
        path = op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome")
    log :
        op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome", "{srr}_bowtie_repeats_featurecounts.log"),
    threads:
        NTHREADS
    shell:
       """
       ## note multimappers are counted
       {FEATURECOUNTS} -T {threads} \
       -p \
       -t exon \
       -g gene_id \
       -a {input.fake_repeatome_gtf} \
       -o  {output.counts} \
       -M \
       -R CORE \
       --Rpath {params.path} \
       {input.bam}  &> {log}

       ## any CB:UMI pair that was seen is removed from the output (awk array)
       grep 'Assigned' {output.detailed} | \
         awk -F'[_.]' '!x[$3$4];{{x[$3$4]++}}' | \
         sed 's/_/\t/g' | {PIGZ} --keep  -p {threads} --stdout > {output.gz_detailed}

       {PIGZ} --keep  -p {threads} {output.counts}       
       """

       # star_transcriptome_repeats.counts.summary
rule feature_counts_repeats_not_overlapping_genes:
    input:        
        bam=op.join(BASE, "runs", RUN_NAME, 'star_transcriptome', "{srr}_Aligned.sortedByCoord.out.bam"),
        gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL) + '_minus_' + op.basename(GENES_GTF_URL))
    params:
        path = op.join(BASE, "runs", RUN_NAME, 'star_transcriptome'),
        subpath = 'repeats_no_overlap'
    output:
        counts  = temp(op.join(BASE, "runs", RUN_NAME, 'star_transcriptome', 'repeats_no_overlap',  "{srr}_repeats_no_overlap.counts")),
        gz_counts = op.join(BASE, "runs", RUN_NAME, 'star_transcriptome', 'repeats_no_overlap', "{srr}_repeats_no_overlap.counts.gz"),
        detailed = temp(op.join(BASE, "runs", RUN_NAME, "star_transcriptome", 'repeats_no_overlap',"{srr}_Aligned.sortedByCoord.out.bam.featureCounts")),
        gz_detailed = op.join(BASE, "runs", RUN_NAME, "star_transcriptome", 'repeats_no_overlap',"{srr}_Aligned.sortedByCoord.out.bam.featureCounts.gz"),
        summary = op.join(BASE, "runs", RUN_NAME, "star_transcriptome", 'repeats_no_overlap',  "{srr}_repeats_no_overlap.counts.summary")
        
    log :
        log = op.join(BASE, "runs",  RUN_NAME, 'star_transcriptome', 'repeats_no_overlap', '{srr}_feature_counts_not_overlapping_genes.log'),
    threads:
        NTHREADS
    shell: """
    cd {params.path}

    {FEATURECOUNTS} -T {threads} \
    -t exon \
    -g gene_id \
    -a {input.gtf} \
    -o  {output.counts} \
    -R CORE \
    --Rpath {params.path}/{params.subpath} \
    {input.bam} 2>&1 > {log} 

    ## any CB:UMI pair that was seen is removed from the output (awk array)
    grep 'Assigned' {output.detailed} | \
      awk -F'[_.]' '!x[$3$4];{{x[$3$4]++}}' | {PIGZ} --keep  -p {threads} --stdout > {output.gz_detailed}

    {PIGZ} --keep -p {threads} {output.counts}
    """

    
# rule featurecounts_repeats_transcriptome_pe:
#     input:
#         bam = op.join(BASE, "runs", RUN_NAME, 'star_transcriptome', "{srr}_Aligned.sortedByCoord.out.bam"),
#         # expand(op.join(BASE, "runs", RUN_NAME, 'star_transcriptome', "{srr}_Aligned.sortedByCoord.out.bam"), srr = get_samples(op.join(BASE, 'data', RUN_NAME, 'celseq2_ding.conf'))),
#         gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL))
#     output:
#         counts  = temp(op.join(BASE, "runs",RUN_NAME, "star_transcriptome", 'repeats',  '{srr}_star_transcriptome_repeats.counts')),
#         gz_counts = op.join(BASE, "runs",RUN_NAME, "star_transcriptome", 'repeats', '{srr}_star_transcriptome_repeats.counts.gz'),
#         detailed = temp(op.join(BASE, "runs", RUN_NAME, "star_transcriptome", 'repeats', "{srr}_star_transcriptome_repeats.featureCounts")),
#         gz_detailed = op.join(BASE, "runs", RUN_NAME, "star_transcriptome", 'repeats', "{srr}_star_transcriptome_repeats.featureCounts.gz"),
#         summary = op.join(BASE, "runs", RUN_NAME, "star_transcriptome",  'repeats', "{srr}_Aligned.sortedByCoord.out.bam.counts.summary")
#     params:
#         path = op.join(BASE, "runs", RUN_NAME, 'star_transcriptome'),
#         subpath = 'repeats'
#     log :
#         op.join(BASE, "runs", RUN_NAME, "star_transcriptome", 'repeats', "{srr}_star_repeats_featurecounts.log"),
#     threads:
#         NTHREADS
#     shell:
#        """
#        {FEATURECOUNTS} -T {threads} \
#        -t exon \
#        -g gene_id \
#        -a {input.gtf} \
#        -o  {output.counts} \
#        -R CORE \
#        --Rpath {params.path}/{params.subpath} \
#        {input.bam}  &> {log}
 
#        ## any CB:UMI pair that was seen is removed from the output (awk array)
#        grep 'Assigned' {output.detailed} | \
#        awk -F'[_.]' '!x[$3$4];{{x[$3$4]++}}'  | {PIGZ} --keep  -p {threads} --stdout > {output.gz_detailed}

#        {PIGZ} --keep -p {threads} {output.counts}
       
#        """

rule featurecounts_genes:
    input:
        bam = op.join(BASE, "runs", RUN_NAME, 'star_transcriptome', "{srr}_Aligned.sortedByCoord.out.bam"),
        # expand(op.join(BASE, "runs", RUN_NAME, 'star_transcriptome', "{srr}_Aligned.sortedByCoord.out.bam"), srr = get_samples(op.join(BASE, 'data', RUN_NAME, 'celseq2_ding.conf'))),
        gtf = op.join(BASE, 'annotation', op.basename(GENES_GTF_URL))
    output:
        genes_counts  = temp(op.join(BASE, "runs",RUN_NAME, "star_transcriptome", 'genes', '{srr}_Aligned.sortedByCoord.out.bam.counts')),
        genes_gz_counts = op.join(BASE, "runs",RUN_NAME, "star_transcriptome", 'genes', '{srr}_Aligned.sortedByCoord.out.bam.counts.gz'),
        genes_detailed = temp(op.join(BASE, "runs", RUN_NAME, "star_transcriptome", 'genes', "{srr}_Aligned.sortedByCoord.out.bam.featureCounts")),
        genes_gz_detailed = op.join(BASE, "runs", RUN_NAME, "star_transcriptome", 'genes', "{srr}_Aligned.sortedByCoord.out.bam.featureCounts.gz"),
        genes_summary = op.join(BASE, "runs", RUN_NAME, "star_transcriptome",  "genes", "{srr}_Aligned.sortedByCoord.out.bam.counts.summary")
    params:
        path = op.join(BASE, "runs", RUN_NAME, 'star_transcriptome'),
        subpath = 'genes'
    log :
        op.join(BASE, "runs", RUN_NAME, "star_transcriptome", 'genes', "{srr}_star_genes_featurecounts.log"),
    threads:
        NTHREADS
    shell:
       """
       {FEATURECOUNTS} -T {threads} \
       -t exon \
       -g gene_id \
       -a {input.gtf} \
       -o  {output.genes_counts} \
       -R CORE \
       --Rpath {params.path}/{params.subpath} \
       {input.bam}  &> {log}
 
       ## any CB:UMI pair that was seen is removed from the output (awk array)
       grep 'Assigned' {output.genes_detailed} | \
       awk -F'[_.]' '!x[$3$4];{{x[$3$4]++}}' | \
       {PIGZ} --keep  -p {threads} --stdout > {output.genes_gz_detailed}

       {PIGZ} --keep -p {threads} {output.genes_counts}
       
       """


rule featurecounts_repeats:
    input:
        bam = op.join(BASE, "runs", RUN_NAME, 'star_transcriptome', "{srr}_Aligned.sortedByCoord.out.bam"),
        gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL))
    output:
        counts  = temp(op.join(BASE, "runs",RUN_NAME, "star_transcriptome", 'repeats', '{srr}_Aligned.sortedByCoord.out.bam.counts')),
        gz_counts = op.join(BASE, "runs",RUN_NAME, "star_transcriptome", 'repeats', '{srr}_Aligned.sortedByCoord.out.bam.counts.gz'),
        detailed = temp(op.join(BASE, "runs", RUN_NAME, "star_transcriptome", 'repeats', "{srr}_Aligned.sortedByCoord.out.bam.featureCounts")),
        gz_detailed = op.join(BASE, "runs", RUN_NAME, "star_transcriptome", 'repeats', "{srr}_Aligned.sortedByCoord.out.bam.featureCounts.gz"),
        summary = op.join(BASE, "runs", RUN_NAME, "star_transcriptome",  "repeats", "{srr}_Aligned.sortedByCoord.out.bam.counts.summary")
    params:
        path = op.join(BASE, "runs", RUN_NAME, 'star_transcriptome'),
        subpath = 'repeats'
    log :
        op.join(BASE, "runs", RUN_NAME, "star_transcriptome", 'repeats', "{srr}_star_repeats_featurecounts.log"),
    threads:
        NTHREADS
    shell:
       """
       {FEATURECOUNTS} -T {threads} \
       -t exon \
       -g gene_id \
       -a {input.gtf} \
       -o  {output.counts} \
       -R CORE \
       --Rpath {params.path}/{params.subpath} \
       {input.bam}  &> {log}
 
       ## any CB:UMI pair that was seen is removed from the output (awk array)
       grep 'Assigned' {output.detailed} | \
       awk -F'[_.]' '!x[$3$4];{{x[$3$4]++}}' | \
       {PIGZ} --keep  -p {threads} --stdout > {output.gz_detailed}

       {PIGZ} --keep -p {threads} {output.counts}
       
       """
       
## use this! @todo
rule get_repeats_not_overlapping_genes_gtf:
    input:
        repeats_gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL)),
        genes_gtf =  op.join(BASE, 'annotation', op.basename(GENES_GTF_URL))
    output:
        gtf = op.join(BASE, 'annotation', op.basename(REP_GTF_URL) + '_minus_' + op.basename(GENES_GTF_URL)),
        repeats_gtf_decomp = temp(op.join(BASE, 'annotation', op.basename(REP_GTF_URL)) + '.tmp.gtf'),
        genes_gtf_decomp =  temp(op.join(BASE, 'annotation', op.basename(GENES_GTF_URL)) + '.tmp.gtf'),
        genesbed = temp(op.join(BASE, 'annotation', op.basename(GENES_GTF_URL)) + '.tmp.bed')
    params:
        threads = NTHREADS,
        bedops_path= BEDOPS
    shell:
        """
        ## this doesn't neither start

        {PIGZ} --decompress --keep --stdout  {input.repeats_gtf} | \
               sed 's/chr//g' > {output.repeats_gtf_decomp}
        {PIGZ} --decompress --keep  --stdout  {input.genes_gtf} | \
               sed 's/chr//g' > {output.genes_gtf_decomp}

        # let's transform genes in bed and then use bedtools
        export PATH={params.bedops_path}:$PATH

        awk '{{ if ($0 ~ "transcript_id") print $0; else print $0" transcript_id "";"; }}' \
           {output.genes_gtf_decomp} | gtf2bed - > {output.genesbed}

        {BEDTOOLS} intersect -a {output.repeats_gtf_decomp} \
          -b {output.genesbed} \
          -v | {PIGZ} --stdout > {output.gtf}
        """

 
rule map_bowtie_repeatome_pe:
    params:
        repeatome = op.join(BASE, 'indices', 'bowtie', GENOME, 'repeatome', op.splitext(op.basename(REP_GTF_URL))[0]),
        sample = RUN_NAME,
        path = op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome")
    input:
        fastq1 = op.join(BASE, "data", RUN_NAME, "{fastq}_umi_1.fastq.gz"),
        fastq2 = op.join(BASE, "data", RUN_NAME, "{fastq}_umi_2.fastq.gz"),
        repeatome_tag_file = op.join(BASE, 'indices', 'bowtie', GENOME, 'repeatome', op.splitext(op.basename(REP_GTF_URL))[0] + '.1.ebwt')
    output:
        op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome", "{fastq}.bam")
    log:
        op.join(BASE, "runs", RUN_NAME, "bowtie_repeatome", "{fastq}_bowtie_repeatome.log")
    threads :
        NTHREADS
    shell:
        """
        mkdir -p {params.path}

        ( {BOWTIE} -q \
        -1 <( {PIGZ} --keep --processes {threads} --to-stdout --decompress {input.fastq1} ) \
        -2 <( {PIGZ} --keep --processes {threads} --to-stdout --decompress {input.fastq2} ) \
        -v 2 \
        --threads {threads} \
        -k 2 --best --strata \
        --sam \
        --chunkmbs 128 {params.repeatome} |  samtools view -@ {threads} -bS - > {output} ) 2> {log}
        """
        
# #@untested @todo @current
# ## fix to take into account the different indices to map against
# ## fix the cutadapt sickle thing
rule map_star_transcriptome_pe:
    input:
        star_index_flag = op.join(BASE, 'indices', 'star', GENOME, 'transcriptome', 'chrName.txt'), 
        fastq1 = op.join(BASE, "data", RUN_NAME, "{fastq}_umi_1.fastq.gz"),
        fastq2 = op.join(BASE, "data", RUN_NAME,  "{fastq}_umi_2.fastq.gz"),
    params:
        star_index = op.join(BASE, 'indices', 'star', GENOME, 'transcriptome'),
        path = op.join(BASE, "runs", RUN_NAME, 'star_transcriptome'),
        prefix = op.join(BASE, "runs", RUN_NAME, 'star_transcriptome', "{fastq}_")
    output:
        bam = op.join(BASE, "runs", RUN_NAME, 'star_transcriptome', "{fastq}_Aligned.sortedByCoord.out.bam"),
        star_tmp = temp(directory(op.join(BASE, 'runs', 'star_transcriptome', "{fastq}_STARtmp")))
    threads:
        NTHREADS
    log:
        op.join(BASE, "runs", RUN_NAME, 'star_transcriptome', "{fastq}_star.log")
    # benchmark:
    #     op.join(BASE, 'run/{sample}/{sample}_star_benchmark.txt')
    shell:
        """
        mkdir -p {params.path}
        cd {params.path}
        
        {STAR} --genomeDir {params.star_index} \
        --readFilesIn {input.fastq1} {input.fastq2} \
        --runThreadN {threads} \
        --outFileNamePrefix {params.prefix} \
        --outSAMtype BAM SortedByCoordinate \
        --readFilesCommand zcat  2> {log}

        ## in case STAR managed to delete its own folder (doesn't always happen)
        mkdir -p {output.star_tmp}
        """


        
# ## we assume the first 12 reads from read1 are the umis + CB
# rule deal_with_umis_r2:
#     input:
#         r1 = op.join(BASE, "data", RUN_NAME, "{srr}_1.fastq.gz"),
#         r2 = op.join(BASE, "data", RUN_NAME, "{srr}_2.fastq.gz")
#     output:
#         r2_umi = op.join(BASE, "data", RUN_NAME, "{srr}_umi_2.fastq.gz")
#     threads:
#         1
#     shell: """
#     join <(zcat {input.r2} | sed 's/.2 / /g' | awk '{{OFS=FS=" "; print $1}}' | nl)  \
#        <(zcat {input.r1} | awk '{{OFS=FS=" "; print $1}}' | nl ) | \
#        awk '(NR%4==1){{a=$2;}}(NR%4==2){{umi=substr($3,0,12); b=$2}}(NR%4==3){{c=$2}}(NR%4==0){{d=$2;print a"_"umi".2\\n"b"\\n+\\n"d;}}' | {PIGZ} -p {threads} --stdout > {output.r2_umi}

#     """


        
## we assume the first 12 reads from read1 are the umis + CB
rule deal_with_umis_r2:
    input:
        r1 = op.join(BASE, "data", RUN_NAME, "{srr}_1.fastq.gz"),
        r2 = op.join(BASE, "data", RUN_NAME, "{srr}_2.fastq.gz")
    output:
        r2_umi = op.join(BASE, "data", RUN_NAME, "{srr}_umi_2.fastq.gz")
    threads:
        1
    shell: """
    join <(zcat {input.r2} | sed 's/.2 / /g' | awk '{{OFS=FS=" "; print $1}}' | nl)  \
       <(zcat {input.r1} | awk '{{OFS=FS=" "; print $1}}' | nl ) | \
       awk '(NR%4==1){{a=$2;}}(NR%4==2){{cb=substr($3,0,6);umi=substr($3,7,6); b=$2}}(NR%4==3){{c=$2}}(NR%4==0){{d=$2;print a"_"cb"_"umi".2\\n"b"\\n+\\n"d;}}' | {PIGZ} -p {threads} --stdout > {output.r2_umi}

    """


# ## we assume the first 12 reads from read1 are the umis + CB
# rule deal_with_umis_r1:
#     input:
#         r1 = op.join(BASE, "data", RUN_NAME, "{srr}_1.fastq.gz")
#     output:
#         r1_umi = op.join(BASE, "data", RUN_NAME, "{srr}_umi_1.fastq.gz")
#     threads:
#         1
#     shell:  """
#     {PIGZ} -p {threads} --decompress --stdout {input.r1} | sed 's/.1 / /g' | \
#       awk 'NR%4==1{{a=$1;}} 
#       NR%4==2{{umi=substr($0,0,12);b_without=substr($0,13)}} 
#       NR%4==3{{c=$0}} 
#       NR%4==0{{d=substr($0,13); print a"_"umi".1\\n"b_without"\\n+\\n"d;}}' | {PIGZ} -p {threads} --stdout > {output.r1_umi}

#     """

## we assume the first 12 reads from read1 are the umis + CB
rule deal_with_umis_r1:
    input:
        r1 = op.join(BASE, "data", RUN_NAME, "{srr}_1.fastq.gz")
    output:
        r1_umi = op.join(BASE, "data", RUN_NAME, "{srr}_umi_1.fastq.gz")
    threads:
        1
    shell:  """
    {PIGZ} -p {threads} --decompress --stdout {input.r1} | sed 's/.1 / /g' | \
      awk 'NR%4==1{{a=$1;}} 
      NR%4==2{{cb=substr($0,0,6);umi=substr($0,7,6);b_without=substr($0,13)}} 
      NR%4==3{{c=$0}} 
      NR%4==0{{d=substr($0,13); print a"_"cb"_"umi".1\\n"b_without"\\n+\\n"d;}}' | {PIGZ} -p {threads} --stdout > {output.r1_umi}

    """

rule get_data:
    input:
        conf = op.join(BASE, "data", RUN_NAME, 'celseq2_ding.conf')
    output:
        # r1_uncomp = temp(op.join(BASE, "data", RUN_NAME, "{srr}_1.fastq")),
        # r2_uncomp = temp(op.join(BASE, "data", RUN_NAME, "{srr}_2.fastq")),
        r1 = op.join(BASE, "data", RUN_NAME, "{srr}_1.fastq.gz"),
        r2 = op.join(BASE, "data", RUN_NAME, "{srr}_2.fastq.gz"),
        r3 = op.join(BASE, "data", RUN_NAME, "{srr}_3.fastq.gz")
    params:
        path = op.join(BASE, "data", RUN_NAME)
    threads:
        1
    shell:
        """
        mkdir -p {params.path}
        cd {params.path}

        # {FASTQDUMP} -I --gzip --split-files {wildcards.srr}
        
        {PREFETCH} {wildcards.srr} --output-file {wildcards.srr}.sra &> \
               {wildcards.srr}_prefetch.log

        {VDBVALIDATE} {wildcards.srr}.sra &> {wildcards.srr}_vdbvalidation.log
            
        {FASTQDUMP}  --gzip --split-files  {wildcards.srr}.sra

        """

## runme first!

# rule get_srr_identifiers:
#     priority:
#         100
#     output:
#         conf = op.join(BASE, "data", RUN_NAME, 'celseq2_ding.conf')
#     params:
#         path = op.join(BASE, "data", RUN_NAME)
#     shell:
#         """
#         ## from https://www.ncbi.nlm.nih.gov/Traces/study/?acc=PRJNA545730&o=acc_s%3Aa
#         ## esearch -db sra -q 'PRJNA545730' | efetch -format runinfo

#         mkdir -p {params.path}
#         cd {params.path}

#         cat << EOF >> {output.conf}
# SRR9169176,RNA-Seq,110,11582704980,PRJNA545730,SAMN11914031,6482204508,GEO,public,"sra,fastq","ncbi,s3,gs","ncbi.public,s3.us-east-1,gs.US",SRX5943295,Illumina HiSeq 2500,PAIRED,cDNA,TRANSCRIPTOMIC,Homo sapiens,ILLUMINA,2019-06-05T00:00:00Z,GSM3836747,SRP200058,GSM3836747,CEL-Seq2,male,Peripheral blood mononuclear cell,,
# SRR9169177,RNA-Seq,110,11177876710,PRJNA545730,SAMN11914030,6265372740,GEO,public,"fastq,sra","gs,ncbi,s3","ncbi.public,s3.us-east-1,gs.US",SRX5943296,Illumina HiSeq 2500,PAIRED,cDNA,TRANSCRIPTOMIC,Homo sapiens,ILLUMINA,2019-06-05T00:00:00Z,GSM3836748,SRP200058,GSM3836748,CEL-Seq2,male,Peripheral blood mononuclear cell,,
# SRR9169178,RNA-Seq,110,9510936380,PRJNA545730,SAMN11914029,5330011518,GEO,public,"sra,fastq","gs,s3,ncbi","ncbi.public,gs.US,s3.us-east-1",SRX5943297,Illumina HiSeq 2500,PAIRED,cDNA,TRANSCRIPTOMIC,Homo sapiens,ILLUMINA,2019-06-05T00:00:00Z,GSM3836749,SRP200058,GSM3836749,CEL-Seq2,male,Peripheral blood mononuclear cell,,
# SRR9169179,RNA-Seq,110,10050127010,PRJNA545730,SAMN11914028,5629020517,GEO,public,"sra,fastq","s3,gs,ncbi","ncbi.public,s3.us-east-1,gs.US",SRX5943298,Illumina HiSeq 2500,PAIRED,cDNA,TRANSCRIPTOMIC,Homo sapiens,ILLUMINA,2019-06-05T00:00:00Z,GSM3836750,SRP200058,GSM3836750,CEL-Seq2,male,Peripheral blood mononuclear cell,,
# SRR9169206,RNA-Seq,110,6805595170,PRJNA545730,SAMN11915422,3943989627,GEO,public,"sra,fastq","gs,s3,ncbi","s3.us-east-1,gs.US,ncbi.public",SRX5943564,Illumina HiSeq 2500,PAIRED,cDNA,TRANSCRIPTOMIC,Homo sapiens,ILLUMINA,2019-06-05T00:00:00Z,GSM3837160,SRP200058,GSM3837160,CEL-Seq2,female,Peripheral blood mononuclear cell,,
# SRR9169207,RNA-Seq,110,5795080830,PRJNA545730,SAMN11915421,3372693142,GEO,public,"fastq,sra","s3,ncbi,gs","s3.us-east-1,ncbi.public,gs.US",SRX5943565,Illumina HiSeq 2500,PAIRED,cDNA,TRANSCRIPTOMIC,Homo sapiens,ILLUMINA,2019-06-05T00:00:00Z,GSM3837161,SRP200058,GSM3837161,CEL-Seq2,female,Peripheral blood mononuclear cell,,
# SRR9169208,RNA-Seq,110,7223219080,PRJNA545730,SAMN11915420,4177497322,GEO,public,"sra,fastq","gs,s3,ncbi","ncbi.public,s3.us-east-1,gs.US",SRX5943782,Illumina HiSeq 2500,PAIRED,cDNA,TRANSCRIPTOMIC,Homo sapiens,ILLUMINA,2019-06-05T00:00:00Z,GSM3837162,SRP200058,GSM3837162,CEL-Seq2,female,Peripheral blood mononuclear cell,,
# SRR9169209,RNA-Seq,110,6537207160,PRJNA545730,SAMN11915424,3788826571,GEO,public,"sra,fastq","ncbi,s3,gs","gs.US,s3.us-east-1,ncbi.public",SRX5943783,Illumina HiSeq 2500,PAIRED,cDNA,TRANSCRIPTOMIC,Homo sapiens,ILLUMINA,2019-06-05T00:00:00Z,GSM3837163,SRP200058,GSM3837163,CEL-Seq2,female,Peripheral blood mononuclear cell,,
# EOF

#         """
