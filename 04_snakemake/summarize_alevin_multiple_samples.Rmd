---
title: "Within (multiple) sample report: PBMC, multiple SRRs in alevin"
author: "Izaskun Mallona at Robinsonlab"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
    code_download: true
    number_sections: true
    df_print: kable
    theme: lumen
params:
  identifier: ""   
  genes_alevin: ""
  repeats_alevin: ""
  repeats_star_unique: ""
  repeats_star_multi: ""
  repeats_bowtie_unique: ""
  repeats_bowtie_multi: ""
  repeats_only_unique: ""
  repeats_only_multi: ""
  genes_featurecounts: ""               
  seurat_output: ""
  aris_output: ""
  cobra_output: ""
  markers_output: ""
  regress_genes_nCount: ""
  regress_genes_nFeature: ""
---


# Config

## Parameters

Rendered for sample:

```{r}
print(params)
```

## Libraries

```{r}
suppressPackageStartupMessages({
library(Matrix)

library(knitr)
library(Seurat)
library(dplyr)
## library(scater)
library(dplyr)
library(data.table)
library(RColorBrewer)
## library(SingleCellExperiment)
## library(scran)
## library(org.Mm.eg.db)
## suppressPackageStartupMessages(library(dplyr))
## suppressPackageStartupMessages(library(DT))
## library(pheatmap)
## library(Cairo)
## library(RColorBrewer)
## library(corrplot)
library(ggplot2)
library(reshape2)
## library(xtable)
library(mclust)
library(pheatmap)
library(SCINA)
library(DT)
library(tximeta)
library(SummarizedExperiment)
})
```

```{r}
opts_chunk$set(fig.width = 5,
               fig.height = 5,
               dev = 'png',
               cache = FALSE,
               include = TRUE,
               cache.lazy = FALSE,
               warning = TRUE,
               echo = TRUE,
               message = FALSE,
               knitr.table.format = "html")


options(bitmapType='cairo')
getOption('bitmapType')
```


## Functions

```{r functions}
## add alpha
ac <- function(col, alpha=1){
  apply(sapply(col, col2rgb)/255, 2, 
                     function(x) 
                       rgb(x[1], x[2], x[3], alpha=alpha))  
}

coef_var <- function(x){
        (sd(x)/mean(x))*100
}

```

# Data load

```{r justfordebugging, eval = FALSE}

params <- list(identifier = "celseq2",
               seurat_output = "/home/imallona/tmp/test.rds",
               repeats_alevin = '/home/imallona/repeats_sc/runs/ding_celseq2/alevin/repeats/alevin/quants_mat.gz',
               genes_alevin = '/home/imallona/repeats_sc/runs/ding_celseq2/alevin/genes/alevin/quants_mat.gz',
               repeats_star_unique = "/home/imallona/repeats_sc/runs/ding_celseq2/star_transcriptome/repeats/unique_reads", 
               repeats_star_multi = "/home/imallona/repeats_sc/runs/ding_celseq2/star_transcriptome/repeats/multimappers", 
               repeats_bowtie_unique = "/home/imallona/repeats_sc/runs/ding_celseq2/bowtie_repeatome/unique_reads", 
               repeats_bowtie_multi = "/home/imallona/repeats_sc/runs/ding_celseq2/bowtie_repeatome/multimappers", 
               repeats_only_unique = "/home/imallona/repeats_sc/runs/ding_celseq2/star_transcriptome/repeats_no_overlap/unique_reads",
               repeats_only_multi = "/home/imallona/repeats_sc/runs/ding_celseq2/star_transcriptome/repeats_no_overlap/multimappers",
               genes_featurecounts = "/home/imallona/repeats_sc/runs/ding_celseq2/star_transcriptome/genes",
               regress_genes_nCount = FALSE,
               regress_genes_nFeatures = FALSE)

params <- list(identifier = "seqwell",
               seurat_output = "/home/imallona/tmp/test.rds",
               repeats_alevin = '/home/imallona/repeats_sc/runs/ding_seqwell/alevin/repeats/alevin/quants_mat.gz',
               genes_alevin = '/home/imallona/repeats_sc/runs/ding_seqwell/alevin/genes/alevin/quants_mat.gz',
               repeats_star_unique = "/home/imallona/repeats_sc/runs/ding_seqwell/star_transcriptome/repeats/unique_reads", 
               repeats_star_multi = "/home/imallona/repeats_sc/runs/ding_seqwell/star_transcriptome/repeats/multimappers", 
               repeats_bowtie_unique = "/home/imallona/repeats_sc/runs/ding_seqwell/bowtie_repeatome/unique_reads", 
               repeats_bowtie_multi = "/home/imallona/repeats_sc/runs/ding_seqwell/bowtie_repeatome/multimappers", 
               repeats_only_unique = "/home/imallona/repeats_sc/runs/ding_seqwell/star_transcriptome/repeats_no_overlap/unique_reads",
               repeats_only_multi = "/home/imallona/repeats_sc/runs/ding_seqwell/star_transcriptome/repeats_no_overlap/multimappers",
               genes_featurecounts = "/home/imallona/repeats_sc/runs/ding_seqwell/star_transcriptome/genes",
               regress_genes_nCount = FALSE,
               regress_genes_nFeatures = FALSE)



```

```{r start}
d <- list()
```

List samples

```{r}

counts <- as.data.frame(assays(tximeta::tximeta(coldata = data.frame(
                               names = "genes",
                               files = params$genes_alevin,
                               stringsAsFactors = FALSE), type = "alevin"))$counts)
```

Annotate genes

```{r annotate}


annot <- list()

annot$ids <- rownames(counts)

annot$filters = "ensembl_gene_id_version"
annot$attributes = c(annot$filters, "external_gene_name", "chromosome_name", 
                     "gene_biotype", "start_position", "end_position")
annot$biomart = "ENSEMBL_MART_ENSEMBL" 
annot$dataset = "hsapiens_gene_ensembl"
annot$host = "ensembl.org"

## biomartCacheClear()

annot$bmart <- biomaRt::useMart(biomart = annot$biomart, dataset = annot$dataset, 
                                host = annot$host)

feature_info <- biomaRt::getBM(attributes = annot$attributes,
                               filters = annot$filters, 
                               values = annot$ids, mart = annot$bmart,
                               useCache = FALSE)


tmp <- merge(data.frame(ensembl_gene_id_version = rownames(counts)),
             by = 'ensembl_gene_id_version', feature_info, all.x = TRUE)

rownames(tmp) <- tmp$ensembl_gene_id_version
tmp <- tmp[rownames(counts),]

stopifnot(rownames(counts) == tmp$ensembl_gene_id_version)

rownames(counts) <- sprintf('%s_%s', tmp$ensembl_gene_id_version, tmp$external_gene_name)


d$genes_alevin <- CreateSeuratObject(counts =  counts,
                                     project = 'genes_alevin',
                                     assay = "RNA",
                                     min.cells = 0,
                                     min.features = 0,
                                     names.field = 1,
                                     names.delim = "_",
                                     meta.data = NULL)

rm(tmp, counts)

grep('-MT-', rownames(d$genes_alevin), value = TRUE)

```


Repeats alevin

```{r multiplealevin, eval = FALSE}

counts <- list()

repeats_fns <- list.files(params$repeats_alevin, pattern = 'quants_mat.gz',
                                  recursive = TRUE)

for (run in repeats_fns) {
    counts[[run]] <- tximeta::tximeta(coldata = data.frame(
                                names = "repeats",
                                files = file.path(params$repeats_alevin, run),
                                stringsAsFactors = FALSE
                                ), type = "alevin")

    counts[[run]] <-  as.data.frame(assays(counts[[run]])$counts)
    colnames(counts[[run]]) <- paste(gsub('/alevin', '', dirname(run)), colnames(counts[[run]]),
                                     sep = "_")

    genes <- rownames(counts[[run]])

    ## counts[[run]] <- counts[[run]][,setdiff(colnames(counts[[run]]), 'gene')]

}

counts <- do.call(cbind.data.frame, counts)
## str(counts)
rownames(counts) <- genes

colnames(counts) <- gsub('quants_mat.gz.', '', basename(colnames(counts)))

counts[1:3, 1:3]
```


```{r, eval = TRUE}
counts <- as.data.frame(assays(tximeta::tximeta(coldata = data.frame(
                                names = "repeats",
                                files = params$repeats_alevin,
                                stringsAsFactors = FALSE
                                ), type = "alevin"))$counts)

```


```{r}

d$repeats_alevin <- CreateSeuratObject(counts =  counts,
                                       project = 'repeats_alevin',
                                       assay = "RNA",
                                       min.cells = 0,
                                       min.features = 0,
                                       names.field = 1,
                                       names.delim = "_",
                                       meta.data = NULL)

rm(counts)



```


## Other modalities

```{r}

process_featurecounts_grouped_by_cb_umi <- function(fn, id = "",
                                                    annotate_genes = FALSE,
                                                    accepted_barcodes = 'all') {
     ## Featurecounts-based repeats
    counts <- data.table::fread(fn, header = FALSE)
    ## cb first, umi second

    ## print(head(counts))
    tryCatch({
        colnames(counts) <- c('cb', 'umi', 'gene')
    }, error = function(x) print(paste(head(counts, 1), collapse = ";")))


    ## counts$cb <- paste(id, counts$cb, sep = "_") # not needed

    if (length(accepted_barcodes) > 1) {
        counts2 <- counts[counts$cb %in% accepted_barcodes,]
        if (nrow(counts2) < 1) stop(sprintf('item %s\n%s\nacceptedbarcode: %s\nbarcode in count table: %s',
                                           'something went wrong with the barcodes subsetting',
                                           item,
                                           accepted_barcodes[1],
                                           counts$cb[1]))
        counts <- counts2
        rm(counts2)
    }
    wide <- reshape2::dcast(counts  %>% 
                            group_by(cb, gene) %>%
                            summarise(count = length(unique(umi))),
                            gene ~ cb, value.var="count")
    rownames(wide) <- wide$gene
    wide <- wide[,-1]
    rm(counts)

    ## add missing accepted barcodes with 0 values for all genes/repeats
    missing <- setdiff(accepted_barcodes, colnames(wide))
    wide[,missing] <- 0

    ## ordering
    wide <- wide[,accepted_barcodes] 
                                    
    ## annotation needed if yes
    if (annotate_genes) {
        
        annot <- list()

        annot$ids <- unique(rownames(wide))

        annot$filters = "ensembl_gene_id" # not ensembl_gene_id_version
        annot$attributes = c(annot$filters, "external_gene_name", "chromosome_name", 
                             "gene_biotype", "start_position", "end_position")
        annot$biomart = "ENSEMBL_MART_ENSEMBL" 
        annot$dataset = "hsapiens_gene_ensembl"
        annot$host = "ensembl.org"

        ## biomartCacheClear()

        annot$bmart <- biomaRt::useMart(biomart = annot$biomart, dataset = annot$dataset, 
                                        host = annot$host)

        feature_info <- biomaRt::getBM(attributes = annot$attributes,
                                       filters = annot$filters, 
                                       values = annot$ids, mart = annot$bmart,
                                       useCache = FALSE)


        tmp <- merge(data.frame(ensembl_gene_id = rownames(wide)),
                     by = 'ensembl_gene_id', feature_info, all.x = TRUE)

        rownames(tmp) <- tmp$ensembl_gene_id
        tmp <- tmp[rownames(wide),]

        stopifnot(rownames(wide) == tmp$ensembl_gene_id)

        rownames(wide) <- sprintf('%s_%s', tmp$ensembl_gene_id, tmp$external_gene_name)

    }

    return(wide)
}
```


```{r}

for (item in grep('repeats|genes',
                  grep('alevin|regress', names(params), invert = TRUE, value = TRUE),
                  value = TRUE)) {
    fns <- list.files(params[[item]], pattern = '*featureCounts.gz',
                                  recursive = TRUE)
    d[[item]] <- list()
    tmp <- list()
    for (fn in fns) {
        id <- sapply(strsplit(basename(fn), '[\\._]'), function(x) return(x[1]))

        ## stop(head(gsub(paste0(id, '_'), '', colnames(d$genes_alevin))))
        
        ## try({
        ##     tmp[[id]] <- process_featurecounts_grouped_by_cb_umi(
        ##         file.path(params[[item]], fn),
        ##         annotate_genes = grepl('genes', item),
        ##         accepted_barcodes = gsub(paste0(id, '_'), '', colnames(d$genes_alevin)))
            
        ##     colnames(tmp[[id]]) <- paste(id, colnames(tmp[[id]]), sep = '_')
        ## })

        ## let's try again, just in case, with the same cellbarcodes as in alevin
        
        tmp[[id]] <- process_featurecounts_grouped_by_cb_umi(
            file.path(params[[item]], fn),
            ## annotate_genes = grepl('genes', item),
            annotate_genes = FALSE,
            accepted_barcodes = colnames(d$genes_alevin),
            id = id)
        
        ## colnames(tmp[[id]]) <- paste(id, colnames(tmp[[id]]), sep = '_')
        
    }
    ## ## merge them
    ## d[[item]]  <- Reduce(
    ##     function(x, y) merge(x, y, by = "id", all = TRUE),
    ##     lapply(tmp, function(x) { x$id <- rownames(x); x }))

    ## rather than merge them, sum them
    genenames <-  rownames(tmp[[1]])
    cbs <- colnames(d$genes_alevin)
    d[[item]] <- data.frame(matrix(0,
                                   nrow = length(genenames),
                                   ncol = length(cbs)),
                            row.names = genenames)
    colnames(d[[item]]) <- cbs
    for (id in names(tmp)) {
        d[[item]] <- d[[item]] + tmp[[id]][genenames, cbs]
    }

    d[[item]][is.na(d[[item]])] <- 0

    rownames(d[[item]]) <- genenames
    
    d[[item]] <- CreateSeuratObject(
        d[[item]],
        project = item,
        assay = "RNA",
        min.cells = 0,
        min.features = 0,
        names.field = 1,
        names.delim = "_",
        meta.data = NULL)
    
    rm(tmp)
    
}

```

```{r}
d
```


```{r}
GetAssayData(d$repeats_alevin)[1:3, 1:3]
GetAssayData(d$genes_alevin)[1:3, 1:3]
GetAssayData(d$genes_featurecounts)[1:3, 1:3]
GetAssayData(d$repeats_star_unique)[1:30, 1:3]

```

# Basic Seurat processing

## Basic stats

## QC before filtering {.tabset}

```{r, results = 'asis', fig.width = 8, fig.height = 4}
for (item in names(d)) {
    cat("### ", item, "\n\n")
    ## stop(grep("^MT-", rownames(d[[item]]), value = TRUE))
    if (item == 'genes_alevin') {
        d[[item]][["percent.mt"]] <- PercentageFeatureSet(d[[item]],
                                                          pattern = "ENS.*[0-9]+-MT-.*")
        print(FeatureScatter(d[[item]], feature1 = "nCount_RNA", feature2 = "percent.mt"))
        print(VlnPlot(d[[item]], features = c("nFeature_RNA", "nCount_RNA", "percent.mt"),
                      ncol = 3))

    } else {
        print(VlnPlot(d[[item]], features = c("nFeature_RNA", "nCount_RNA"), ncol = 2))
    
    }
    print(FeatureScatter(d[[item]], feature1 = "nCount_RNA", feature2 = "nFeature_RNA"))
    cat('\n\n')
}

```

## Basic stats pre-QC

```{r}
summarized <- list()
## summarized[['header']] <- c('dataset','filter', 'ncells',
##                             'ncount mean', 'ncount sd', 'nfeature mean', 'nfeature sd')
    
for (item in names(d)) {
    summarized[[item]] <- c(
        item, 'unfiltered', nrow(d[[item]]@meta.data),
        mean(d[[item]]@meta.data$nCount_RNA), sd(d[[item]]@meta.data$nCount_RNA),
        mean(d[[item]]@meta.data$nFeature_RNA), sd(d[[item]]@meta.data$nFeature_RNA))

    if ('pct_mt_mean' %in% colnames(d[[item]]@meta.data)) {
        summarized[[item]] <- c(summarized[[item]],
                                mean(d[[item]]@meta.data@percent.mt, na.rm = TRUE))
    }
    else {
        summarized[[item]] <- c(summarized[[item]], NA)
        
    }
}

summarized <- as.data.frame(do.call(rbind.data.frame, summarized))
colnames(summarized) <- c('dataset','filter', 'ncells',
                          'ncount_mean', 'ncount_sd', 'nfeature_mean', 'nfeature_sd',
                          'percent.mt')
print(summarized)
```

## QC after filtering {.tabset}

Filtering out cells according to the repeats expression, and forwarding the selection to other layers

```{r subset}
d$genes_alevin <- subset(d$genes_alevin, subset = percent.mt < 18| is.na(percent.mt))

selected_cells <- colnames(d$genes_alevin)
length(selected_cells)

for (item in names(d)) {
    d[[item]] <- subset(d[[item]], cells = selected_cells)
}


```

```{r, results = 'asis', fig.width = 8, fig.height = 4}
for (item in names(d)) {
    cat("### ", item, "\n\n")
    ## stop(grep("^MT-", rownames(d[[item]]), value = TRUE))
    if (item == 'genes_alevin') {
        d[[item]][["percent.mt"]] <- PercentageFeatureSet(d[[item]],
                                                          pattern = "ENS.*[0-9]+-MT-.*")
        print(FeatureScatter(d[[item]], feature1 = "nCount_RNA", feature2 = "percent.mt"))
        print(VlnPlot(d[[item]], features = c("nFeature_RNA", "nCount_RNA", "percent.mt"),
                      ncol = 3))

    } else {
        print(VlnPlot(d[[item]], features = c("nFeature_RNA", "nCount_RNA"), ncol = 2))
    
    }
    print(FeatureScatter(d[[item]], feature1 = "nCount_RNA", feature2 = "nFeature_RNA"))
    cat('\n\n')
}




```

## Basic stats post-QC

```{r}
summarized <- list()
## summarized[['header']] <- c('dataset','filter', 'ncells',
##                             'ncount mean', 'ncount sd', 'nfeature mean', 'nfeature sd')
    
for (item in names(d)) {
    summarized[[item]] <- c(
        item, 'filtered', nrow(d[[item]]@meta.data),
        mean(d[[item]]@meta.data$nCount_RNA), sd(d[[item]]@meta.data$nCount_RNA),
        mean(d[[item]]@meta.data$nFeature_RNA), sd(d[[item]]@meta.data$nFeature_RNA))

    if ('pct_mt_mean' %in% colnames(d[[item]]@meta.data)) {
        summarized[[item]] <- c(summarized[[item]],
                                mean(d[[item]]@meta.data@percent.mt, na.rm = TRUE))
    }
    else {
        summarized[[item]] <- c(summarized[[item]], NA)
        
    }
}

summarized <- as.data.frame(do.call(rbind.data.frame, summarized))
colnames(summarized) <- c('dataset','filter', 'ncells',
                          'ncount_mean', 'ncount_sd', 'nfeature_mean', 'nfeature_sd',
                          'percent.mt')
print(summarized)

```



## Variable features {.tabset}

```{r, message = FALSE, fig.width =8, fig.height = 4, results= 'asis'}
for (item in names(d)) {
    cat("### ", item, "\n\n")

    d[[item]] <- NormalizeData(object = d[[item]],
                               normalization.method = "LogNormalize",
                               scale.factor = 10000)
    
    d[[item]] <- FindVariableFeatures(d[[item]], selection.method = "vst", nfeatures = 2000)

    ## Identify the 10 most highly variable genes
    top10 <- head(VariableFeatures(d[[item]]), 10)

    ## plot variable features with and without labels
    plot1 <- VariableFeaturePlot(d[[item]])
    plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
    print(plot2 + ggtitle(item))
    cat('\n\n')
}


```

## Dimred PCA {.tabset}


```{r debug}
saveRDS(object =d, file = params$seurat_output) # todo remove

```

```{r, message = FALSE, results ='asis'}



NUM_PCS <- 1:20
for (item in names(d)) {
    cat("### ", item, "\n\n")

    to_regress <- NULL
    if (as.logical(params$regress_genes_nCount)) {
        to_regress <- c(to_regress, 'nCount_RNA')
    }
    if (as.logical(params$regress_genes_nFeature)) {
        to_regress <- c(to_regress, 'nFeature_RNA')
        
    }
    
    if (item == 'genes_alevin') {
        d[[item]] <- ScaleData(d[[item]], vars.to.regress = to_regress)
    } else {
        ## in this case, the variables to regress come from the genes!
        ## e.g. is the genes library size the one to normalize the repets'
        tmp <- d$genes_alevin@meta.data
        tmp$cell <- rownames(tmp)
        d[[item]]@meta.data$cell <- rownames(d[[item]]@meta.data)
        d[[item]]@meta.data <- merge(d[[item]]@meta.data, tmp, by = 'cell',
                                     suffixes = c('', '_genes'))
        rownames(d[[item]]@meta.data) <- d[[item]]@meta.data$cell


        d[[item]] <- ScaleData(d[[item]],
                               vars.to.regress = if(is.null(to_regress)) NULL else paste0(to_regress, '_genes'))
        
        rm(tmp) 
    }
    
    d[[item]] <- RunPCA(d[[item]], features = VariableFeatures(object = d[[item]]))
    
    print(DimPlot(d[[item]], reduction = "pca"))
    
    print(ElbowPlot(d[[item]]) + ggtitle(item))


    cat('\n\n')
}


```

```{r, message = FALSE, results = 'asis'}
for (item in names(d)) {

    d[[item]] <- FindNeighbors(d[[item]], dims = NUM_PCS)
    for (res in seq(0.2, 2, by = 0.2)) {
        d[[item]] <- FindClusters(d[[item]], resolution = res, verbose = FALSE)

    }

    d[[item]] <- RunUMAP(d[[item]], dims = NUM_PCS)
        
    d[[item]] <- RunTSNE(d[[item]], dims = NUM_PCS, check_duplicates = FALSE)
}

## stop('check here')

```


## Dimred UMAP and tSNE {.tabset}

```{r, eval = FALSE}
item <- 'repeats_alevin'

print(DimPlot(d[[item]], reduction = "umap", group.by = 'orig.ident'))
print(DimPlot(d[[item]], reduction = "umap", group.by = 'RNA_snn_res.2'))

```

```{r, eval = FALSE}
item <- 'genes_alevin'

print(DimPlot(d[[item]], reduction = "umap", group.by = 'orig.ident'))
print(DimPlot(d[[item]], reduction = "umap", group.by = 'RNA_snn_res.2'))

```

```{r fig.width = 8, fig.height = 5, results = 'asis', cache = FALSE, warning = FALSE}
for (item in names(d)) {
    cat("### ", item, "\n\n")

    
    print(DimPlot(d[[item]], reduction = "umap", group.by = 'RNA_snn_res.2'))
    print(DimPlot(d[[item]], reduction = "tsne", group.by = 'RNA_snn_res.2'))

    cat('\n\n')

}
```


# SCINA-based PBMC annotations

Markers from supplementary table s10 from [here](https://www.biorxiv.org/content/10.1101/632216v1.supplementary-material?versioned=true) [supp data](https://static-content.springer.com/esm/art%3A10.1038%2Fs41587-020-0465-8/MediaObjects/41587_2020_465_MOESM3_ESM.xlsx)


```{r}
markers2 <- read.table(text = 'cell_type	gene	sign
CD4+_T_cell	CD3D	+
CD4+_T_cell	CD3E	+
CD4+_T_cell	CD3G	+
CD4+_T_cell	TRAC	+
CD4+_T_cell	CD4	+
CD4+_T_cell	TCF7	+
CD4+_T_cell	CD27	+
CD4+_T_cell	IL7R	+
CD4+_T_cell	CD8A	-
CD4+_T_cell	CD8B	-
CD4+_T_cell	GNLY	-
CD4+_T_cell	NKG7	-
CD4+_T_cell	CST7	-
Cytotoxic_T_cell	CD3D	+
Cytotoxic_T_cell	CD3E	+
Cytotoxic_T_cell	CD3G	+
Cytotoxic_T_cell	TRAC	+
Cytotoxic_T_cell	CD8A	+
Cytotoxic_T_cell	CD8B	+
Cytotoxic_T_cell	GZMK	+
Cytotoxic_T_cell	CCL5	+
Cytotoxic_T_cell	NKG7	+
Cytotoxic_T_cell	CD4	-
Cytotoxic_T_cell	FCER1G	-
B_cell	CD19	+
B_cell	MS4A1	+
B_cell	CD79A	+
B_cell	CD79B	+
B_cell	MZB1	+
B_cell	IGHD	+
B_cell	IGHM	+
Natural_killer_cell	NCAM1	+
Natural_killer_cell	NKG7	+
Natural_killer_cell	KLRB1	+
Natural_killer_cell	KLRD1	+
Natural_killer_cell	KLRF1	+
Natural_killer_cell	KLRC1	+
Natural_killer_cell	KLRC2	+
Natural_killer_cell	KLRC3	+
Natural_killer_cell	KLRC4	+
Natural_killer_cell	CD3D	-
Natural_killer_cell	CD3E	-
Natural_killer_cell	CD3G	-
Natural_killer_cell	CD14	-
Natural_killer_cell	FCGR3A	+
Natural_killer_cell	FCGR3B	+
Natural_killer_cell	ITGAL	+
Natural_killer_cell	ITGAM	+
Natural_killer_cell	FCER1G	+
Natural_killer_cell	TRAC	-
CD14+_monocyte	VCAN	+
CD14+_monocyte	FCN1	+
CD14+_monocyte	S100A8	+
CD14+_monocyte	S100A9	+
CD14+_monocyte	CD14	+
CD14+_monocyte	ITGAL	+
CD14+_monocyte	ITGAM	+
CD14+_monocyte	CSF3R	+
CD14+_monocyte	CSF1R	+
CD14+_monocyte	CX3CR1	+
CD14+_monocyte	FCGR3A	-
CD14+_monocyte	FCGR3B	-
CD14+_monocyte	TYROBP	+
CD14+_monocyte	LYZ	+
CD14+_monocyte	S100A12	+
CD14+_monocyte	CD3D	-
CD14+_monocyte	CD3E	-
CD14+_monocyte	CD3G	-
CD14+_monocyte	TRAC	-
CD14+_monocyte	NKG7	-
CD14+_monocyte	KLRB1	-
CD14+_monocyte	KLRD1	-
CD16+_monocyte	FCN1	+
CD16+_monocyte	FCGR3A	+
CD16+_monocyte	FCGR3B	+
CD16+_monocyte	ITGAL	+
CD16+_monocyte	ITGAM	+
CD16+_monocyte	CSF3R	+
CD16+_monocyte	CSF1R	+
CD16+_monocyte	CX3CR1	+
CD16+_monocyte	CDKN1C	+
CD16+_monocyte	MS4A7	+
CD16+_monocyte	S100A8	-
CD16+_monocyte	S100A9	-
CD16+_monocyte	S100A12	-
CD16+_monocyte	CD14	-
CD16+_monocyte	CD3D	-
CD16+_monocyte	CD3E	-
CD16+_monocyte	CD3G	-
CD16+_monocyte	TRAC	-
CD16+_monocyte	NKG7	-
CD16+_monocyte	KLRB1	-
CD16+_monocyte	KLRD1	-
Dendritic_cell	HLA-DPB1	+
Dendritic_cell	HLA-DPA1	+
Dendritic_cell	HLA-DQA1	+
Dendritic_cell	ITGAX	+
Dendritic_cell	CD3D	-
Dendritic_cell	CD3E	-
Dendritic_cell	CD3G	-
Dendritic_cell	NCAM1	-
Dendritic_cell	CD19	-
Dendritic_cell	CD14	-
Dendritic_cell	CD1C	+
Dendritic_cell	CD1E	+
Dendritic_cell	FCER1A	+
Dendritic_cell	CLEC10A	+
Dendritic_cell	FCGR2B	+
Dendritic_cell	MS4A1	-
Dendritic_cell	CD79A	-
Dendritic_cell	CD79B	-
Plasmacytoid_dendritic_cell	IL3RA	+
Plasmacytoid_dendritic_cell	GZMB	+
Plasmacytoid_dendritic_cell	JCHAIN	+
Plasmacytoid_dendritic_cell	IRF7	+
Plasmacytoid_dendritic_cell	TCF4	+
Plasmacytoid_dendritic_cell	LILRA4	+
Plasmacytoid_dendritic_cell	CLEC4C	+
Plasmacytoid_dendritic_cell	ITGAX	-
Plasmacytoid_dendritic_cell	CD3D	-
Plasmacytoid_dendritic_cell	CD3E	-
Plasmacytoid_dendritic_cell	CD3G	-
Plasmacytoid_dendritic_cell	NCAM1	-
Plasmacytoid_dendritic_cell	CD19	-
Plasmacytoid_dendritic_cell	CD14	-
Plasmacytoid_dendritic_cell	MS4A1	-
Plasmacytoid_dendritic_cell	CD79A	-
Plasmacytoid_dendritic_cell	CD79B	-
Plasma_cell	CD38	+
Plasma_cell	XBP1	+
Plasma_cell	CD27	+
Plasma_cell	SLAMF7	+
Plasma_cell	CD19	-
Plasma_cell	MS4A1	-
Plasma_cell	CD3D	-
Plasma_cell	CD3E	-
Plasma_cell	CD3G	-
Plasma_cell	IGHA1	+
Plasma_cell	IGHA2	+
Plasma_cell	IGHG1	+
Plasma_cell	IGHG2	+
Plasma_cell	IGHG3	+
Plasma_cell	IGHG4	+
Platelet	PF4	+
Platelet	PPBP	+
Platelet	GP5	+
Platelet	ITGA2B	+
Platelet	NRGN	+
Platelet	TUBB1	+
Platelet	SPARC	+
Platelet	RGS18	+
Platelet	MYL9	+
Platelet	GNG11	+', header = TRUE, sep = '\t', stringsAsFactors = FALSE)

```

```{r}
pal <- read.table(text = 'identity,color
CD4+_T_cell,"#A6CEE3"
Cytotoxic_T_cell,"#1F78B4"
B_cell,"#B2DF8A"
Natural_killer_cell,"#33A02C"
CD14+_monocyte,"#FB9A99"
CD16+_monocyte,"#E31A1C"
Dendritic_cell,"#FDBF6F"
Plasmacytoid_dendritic_cell,"#FF7F00"
Plasma_cell,"#CAB2D6"
Platelet,"#6A3D9A"
unknown,"#C0C0C0"', header = TRUE, sep = ',', stringsAsFactors = FALSE)

rownames(pal) <- pal$identity
```

```{r palette}
pos_markers2_tmp <- markers2[markers2$sign == '+',]
pos_markers2 <-  list()
pos_markers_compound <- list()

for (ct in unique(pos_markers2_tmp$cell_type)) {
    pos_markers2[[ct]] <- pos_markers2_tmp[pos_markers2_tmp$cell_type ==ct, 'gene']
    mapping <- data.frame(
        id = rownames(d$genes_alevin),
        symbol = sapply(strsplit(rownames(d$genes_alevin), '-'), function(x) return (x[2])),
        ensg = sapply(strsplit(rownames(d$genes_alevin), '-'), function(x) return (x[1])),
        stringsAsFactors = FALSE)
    
    head(mapping)

    pos_markers_compound[[ct]] <- mapping[mapping$symbol %in% pos_markers2[[ct]], 'id']
}


```

```{r}
named <-  SCINA(GetAssayData(d$genes_alevin, slot = 'data'),
                signatures = pos_markers_compound,
                max_iter = 200,
                convergence_n = 20, 
                convergence_rate = 0.999, sensitivity_cutoff = 0.8)

table(named$cell_labels)
## plotheat.SCINA(exp = GetAssayData(d$genes_alevin, slot = 'data'),
                ## signatures = pos_markers_compound, results = named)
```




## Confusion matrices with clustering results {.tabset}

First, add the SCINA outputs to the different SO objects

```{r, cache = FALSE}

## save(file = paste0(params$seurat_output, '_debug'), list = c('d', 'named'))
labelling <- data.frame(cell = colnames(d$genes_alevin),
                        scina = named$cell_labels,
                        stringsAsFactors = FALSE)



rownames(labelling) <- labelling$cell

d$genes_alevin@meta.data$cell <- rownames(d$genes_alevin@meta.data)
d$genes_alevin@meta.data <- merge(d$genes_alevin@meta.data, labelling, by = 'cell', all.x = TRUE)
rownames(d$genes_alevin@meta.data) <- d$genes_alevin@meta.data$cell

## still, the annotation can also be transfered to repeats/featurecounts

for (item in setdiff(names(d), 'genes_alevin')) {

    d[[item]]@meta.data$cell <-  rownames(d[[item]]@meta.data)
    ## head(d[[item]]@meta.data)
    
    tmp <- merge(data.frame(cell = d[[item]]@meta.data$cell),
                 labelling, all.x = TRUE)

    rownames(tmp) <- tmp$cell

    
    d[[item]] <- AddMetaData(object = d[[item]],
                             metadata = tmp['scina'],
                             col.name = 'scina')
    rownames(d[[item]]@meta.data) <- d[[item]]@meta.data$cell
}

rm(labelling, tmp)

```



# Repeats and genes expression profiles by SCINA annotation {.tabset}

tSNEs/UMAPs

```{r, fig.width = 7, fig.height = 4, results = 'asis', cache = FALSE}
for (item in names(d)) {
    cat("## ", item, "\n\n")
    ## d[[item]]@meta.data$scina <- as.factor(d[[item]]@meta.data$scina)
    ## Idents(d[[item]]) <- 'scina'
    print(DimPlot(d[[item]], reduction = "umap", group.by = 'scina',
                  cols = setNames(pal$color, pal$identity)) +
          ggtitle(item))

    print(DimPlot(d[[item]], reduction = "tsne", group.by = 'scina', 
                  cols = setNames(pal$color, pal$identity)) +
                  ggtitle(item))
    
    

    ## print(CombinePlots(plots = list(p1, p2)) + ggtitle(item))
    cat('\n\n')

}
```

<!-- # boxplots by identity {.tabset} -->

<!-- ```{r fig.height = 6, fig.width = 16, results = 'asis'} -->
<!-- ## selected <- c('AluY', 'AluSx', 'MER49', 'MIR', 'L2a', 'L2b', 'L1PA11') -->
<!-- for (slot in grep('repeats', names(d), value = TRUE)) { -->
<!--     cat("## ", slot, "\n\n") -->

<!--     ## this is idiotic @todo add variable feature selection -->
<!--     ## selected <- c(names(head(sort(apply(GetAssayData(d[[slot]]),1, coef_var), -->
<!--                                   ## decreasing = TRUE), -->
<!--                              ## 5)), -->
<!--                   ## c('AluY', 'AluSx', 'L1PA11', 'MIR', 'L2a')) -->

<!--     selected <- head(VariableFeatures(d[[slot]]), n = 10) -->

    
<!--     repeats <- as.data.frame(FetchData(d[[slot]], vars = selected, slot = 'data')) -->
<!--     repeats$cell <- rownames(repeats) -->

    
<!--     d$genes_cellranger@meta.data$cell <- rownames(d$genes_cellranger@meta.data) -->
<!--     repeats <- merge(d$genes_cellranger@meta.data[, c('scina', 'cell') ], -->
<!--                      repeats, by = 'cell', all.x = TRUE) -->

<!--     rownames(repeats) <- repeats$cell -->
    
<!--     repeats <- melt(repeats, id.vars = c('cell', 'scina')) -->

<!--     colnames(repeats) <- c('cell', 'scina', 'repfamily', 'data') -->
    
<!--     print(ggplot(repeats, -->
<!--            aes(x = scina, y = data)) +  -->
<!--           geom_boxplot(outlier.size=1) + -->
<!--           scale_y_continuous(trans='log10') + -->
<!--         scale_fill_discrete(drop=FALSE) + -->
<!--         facet_wrap(~ factor(repfamily), ncol = 10) + -->
<!--         theme(axis.text.x = element_text(angle = 90, hjust = 1)) + -->
<!--         ylab('repeat expression [ncount]') + -->
<!--         xlab('SCINA identity') + ggtitle(sprintf('%s %s\n%s', slot, 'repeats', 'scina'))) -->

<!--     rm(repeats) -->
<!--     cat('\n\n') -->
<!-- } -->
<!-- ``` -->



# Dimred PCA comparing modalities and SCINA {.tabset}

Colour: SCINA-based celltype.

```{r, fig.width = 10, fig.height = 10, results = 'asis'}

for (flavour1 in names(d)) {
    ## d[[flavour]][["pca"]]
    ## ## A dimensional reduction object with key PC_ 
    ## ##  Number of dimensions: 50 
    ## ##  Projected dimensional reduction calculated:  FALSE 
    ## ##  Jackstraw run: TRUE 
    ## ##  Computed using assay: RNA
    ## head(Embeddings(d[[flavour]], reduction = "pca")[, 1:5])
    ## head(Loadings(d[[flavour]], reduction = "pca")[, 1:5])
    for (flavour2 in setdiff(names(d), flavour1)) {
        cat('## ', flavour1, flavour2, '\n\n')
    
        common <- intersect(rownames(Embeddings(d[[flavour1]])),
                            rownames(Embeddings(d[[flavour2]])))

        palette <- brewer.pal(n = nlevels(d[[flavour1]]@meta.data$scina), name = "Paired")

        par(mar=c(5.1, 4.1, 7.1, 2.1), mfrow = c(3,3)) ## here
        for (i in 1:3) {
            for (j in 1:3) {
                ## cat ('### ', i, j, '\n\n')

               
                ## par(mfrow = c(5,5))
                plot(x = Embeddings(d[[flavour1]], reduction = "pca")[common,i],
                     y = Embeddings(d[[flavour2]], reduction = "pca")[common,j],
                     ## main = sprintf('flavour1 %s PC %s\nflavour2 %s PC %s',
                                    ## flavour1, i, flavour2, j),
                     ## col = palette[as.numeric(d[[flavour1]]@meta.data[common, 'scina'])],
                     col = pal[d[[flavour1]]@meta.data[common, 'scina'],'color'],
                     pch = 19, cex = 0.5,
                     xlab = sprintf('%s PC %s', flavour1, i),
                     ylab = sprintf('%s PC %s', flavour2, j))

                ## if (i == 1 & j == 1) {
                    legend('top',
                           legend = pal$identity,
                           ## col = palette[1:nlevels(d[[flavour1]]@meta.data[common, 'scina'])],
                           col = pal$color,
                           pch=19, cex=0.8,
                           inset=c(0,-0.42),
                           ncol = 2,
                           xpd = TRUE)
                ## }

                ## cat('\n\n')
            }
        }

        cat('\n\n')
    }
}



```


<!-- # Descriptive (clustering) {.tabset} -->

<!-- Tabset: coloring according to the clustering results. -->

<!-- ```{r descriptive, results = 'asis', fig.width =8, fig.height = 8} -->

<!-- res <- 'RNA_snn_res.0.2' -->
<!-- ## common_cells <- Reduce(intersect, sapply(d, colnames)) # <_ HERE @todo -->
<!-- common_cells <- colnames(d[[1]]) -->

<!-- ## length(common_cells) -->

<!-- for (item_clust in names(d)) { -->
<!--     tag <- sprintf('%s\n%s', item_clust, res) -->
<!--     cat('## ', tag, '\n\n') -->
    
<!--     merged <- data.frame(cell = common_cells, -->
<!--                          percent.mt = d$genes_cellranger@meta.data[common_cells, 'percent.mt']) -->

<!--     merged[,tag] <- d[[item_clust]]@meta.data[common_cells,res] -->

<!--     for (item in names(d)) { -->
<!--         d[[item]]@meta.data$cell <- rownames(d[[item]]@meta.data) -->

<!--         merged <- merge(merged, -->
<!--                         d[[item]]@meta.data[c('cell', 'nCount_RNA', 'nFeature_RNA')], -->
<!--                         by = 'cell', -->
<!--                         all.x = TRUE, -->
<!--                         suffixes = c('', sprintf('\n%s', item))) -->

<!--         ## cat("### ", item, "\n\n") -->

<!--     } -->
<!--     rownames(merged) <- merged$cell -->
<!--     merged <- merged[,-1] -->
<!--     colnames(merged) <- gsub('_RNA', '', colnames(merged)) -->
<!--     plot(merged, pch = 20, cex = 0.5, col = ac(as.numeric(merged[,tag]), 0.1)) -->
<!--     ## ggpairs( -->
<!--     ##     merged, -->
<!--     ##     upper = list(continuous = "density", combo = "box_no_facet"), -->
<!--     ##     lower = list(continuous = "points", combo = "dot_no_facet"), -->
<!--     ##     mapping = ggplot2::aes(color = ac(as.numeric(merged[,tag], 0.1))) -->
<!--     ## ) -->
<!--     cat('\n\n') -->
<!-- } -->

<!-- rm(res) -->
<!-- rm(merged) -->
<!-- ``` -->

# Descriptive (with scina)

Tabset: coloring according to the clustering results.

```{r, fig.width=12, fig.height=12}

tag <- 'scina'

## common_cells <- Reduce(intersect, sapply(d, colnames))
common_cells <- colnames(d[[1]]) 
merged <- data.frame(cell = common_cells,
                     percent.mt = d$genes_alevin@meta.data[common_cells, 'percent.mt'])

## merged[,tag] <- d[[item_clust]]@meta.data[common_cells,res]
merged[,tag] <- d[[item]]@meta.data[common_cells, tag]

for (item in names(d)) {
        ## cat('## ', tag, '\n\n')
        d[[item]]@meta.data$cell <- rownames(d[[item]]@meta.data)

        merged <- merge(merged,
                        d[[item]]@meta.data[c('cell', 'nCount_RNA', 'nFeature_RNA')],
                        by = 'cell',
                        all.x = TRUE,
                        suffixes = c('', sprintf('\n%s', item)))

        ## cat("### ", item, "\n\n")
}

rownames(merged) <- merged$cell
merged <- merged[,-1]
colnames(merged) <- gsub('_RNA', '', colnames(merged))
```

Diagonal labels:

```{r}
colnames(merged)
```

```{r descriptive2, results = 'asis', fig.width =8, fig.height = 8}
tryCatch({
    plot(merged[,setdiff(colnames(merged), 'scina')], pch = 20, cex = 0.5, col = ac(pal[merged$scina, 'color'], 0.1))
## plot(merged, pch = 20, cex = 0.5, col = ac(as.numeric(as.factor(merged[,tag])), 1))
## cat('\n\n')
}, error = function(x) print(x))
    
rm(merged)
```


# Descriptive with SCINA and PCs {.tabset}


Comparing PCs to SCINA

```{r descriptive3, results = 'asis', fig.width = 12, fig.height = 12}
## ```{r descriptive3, results = 'asis'}
tryCatch({
    tag <- 'scina'

    merged <- data.frame(cell = common_cells,
                         percent.mt = d$genes_alevin@meta.data[common_cells, 'percent.mt'])

    ## merged[,tag] <- d[[item_clust]]@meta.data[common_cells,res]
    merged[,tag] <- d[['genes_alevin']]@meta.data[common_cells, tag]

    for (item in names(d)) {
        cat('## ', tag, '\n\n')
        d[[item]]@meta.data$cell <- rownames(d[[item]]@meta.data)

        merged <- merge(merged,
                        d[[item]]@meta.data[c('cell', 'nCount_RNA', 'nFeature_RNA')],
                        by = 'cell',
                        all.x = TRUE,
                        suffixes = c('', sprintf('\n%s', item)))

        cat("### ", item, "\n\n")
    }

    rownames(merged) <- merged$cell
    merged <- merged[,-1]
    colnames(merged) <- gsub('_RNA', '', colnames(merged))

    plot(merged[,setdiff(colnames(merged), 'scina')],
         pch = 20, cex = 0.5, col = ac(pal[merged$scina, 'color'], 0.1))
    ## plot(merged, pch = 20, cex = 0.5, col = ac(as.numeric(as.factor(merged[,tag])), 1))
    cat('\n\n')
}, error = function(x) print(x))

```


<!-- # Correlation values distribution -->

<!-- Repeats by cellranger vs repeats by featurecounts on cellranger-standard bams. -->

<!-- Skipped currently -->

<!-- ## Correlations per cell -->

<!-- Skipped -->

<!-- First repeats vs featurecounts -->

<!-- ```{r correl_first, warning = FALSE, eval = FALSE} -->
<!-- ccell <- list() -->
     
<!-- for (cell in intersect( colnames(GetAssay(d$repeats_cellranger, 'RNA')), -->
<!--                        colnames(GetAssay(d$repeats_featurecounts, 'RNA')))) { -->
<!--     reps <- intersect(rownames(d$repeats_cellranger), rownames(d$repeats_featurecounts)) -->
    
<!--     ccell[[cell]] <- cor(as.numeric(GetAssay(d$repeats_cellranger, 'RNA')[reps,cell]), -->
<!--                          as.numeric(GetAssay(d$repeats_featurecounts, 'RNA')[reps,cell]), -->
<!--                          method = 'spearman') -->
<!-- } -->
<!-- ``` -->

<!-- ```{r, eval = FALSE} -->
<!-- hist(unlist(ccell), -->
<!--      main = "correlation across cells\nrepeats cellranger vs repeats (featurecounts)") -->
<!-- ## lines(density(unlist(ccell))) -->

<!-- ``` -->

<!-- Second featurecounts on all repeats vs featurecounts on some repeats only -->

<!-- ```{r, eval = FALSE} -->
<!-- ccell <- list() -->
     
<!-- for (cell in intersect( colnames(GetAssay(d$control_repeats_only, 'RNA')), -->
<!--                        colnames(GetAssay(d$repeats_featurecounts, 'RNA')))) { -->
<!--     reps <- intersect(rownames(d$control_repeats_only), rownames(d$repeats_featurecounts)) -->
    
<!--     ccell[[cell]] <- cor(as.numeric(GetAssay(d$control_repeats_only, 'RNA')[reps,cell]), -->
<!--                          as.numeric(GetAssay(d$repeats_featurecounts, 'RNA')[reps,cell]), -->
<!--                          method = 'spearman') -->
<!-- } -->

<!-- ``` -->


<!-- ```{r, eval = FALSE} -->
<!-- hist(unlist(ccell), -->
<!--      main = "correlation across cells\nrepeats vs nongene-repeats", -->
<!--      xlab = "Spearman's rho") -->
<!-- ``` -->


<!-- ## Correlations per repeat -->

<!-- First cellranger vs featurecounts -->

<!-- ```{r, warning = FALSE, eval = FALSE} -->
<!-- crepeat <- list() -->

<!-- ## GetAssay(d$repeats_cellranger, 'RNA')[1:10,1:10] -->

<!-- for (re in intersect( rownames(GetAssay(d$repeats_cellranger, 'RNA')), -->
<!--                      rownames(GetAssay(d$repeats_featurecounts, 'RNA')))) { -->

<!--     cells <-  intersect(colnames(d$repeats_cellranger), colnames(d$repeats_featurecounts)) -->
<!--     crepeat[[re]] <- cor(as.numeric(GetAssay(d$repeats_cellranger, 'RNA')[re,cells]), -->
<!--                          as.numeric(GetAssay(d$repeats_featurecounts, 'RNA')[re, cells]), -->
<!--                          method = 'spearman') -->
<!-- } -->
<!-- ``` -->

<!-- ```{r, eval = FALSE} -->
<!-- hist(unlist(crepeat), main = "correlation across repeats\nrepeats cellranger vs repeats (featurecounts)", xlab = "Sperman's rho") -->

<!-- ``` -->

<!-- Second featurecounts on all repeats vs featurecounts on some repeats only -->

<!-- ```{r, eval = FALSE} -->
<!-- crepeat <- list() -->

<!-- ## GetAssay(d$control_repeats_only, 'RNA')[1:10,1:10] -->

<!-- for (re in intersect( rownames(GetAssay(d$control_repeats_only, 'RNA')), -->
<!--                      rownames(GetAssay(d$repeats_featurecounts, 'RNA')))) { -->

<!--     cells <-  intersect(colnames(d$control_repeats_only), colnames(d$repeats_featurecounts)) -->
<!--     crepeat[[re]] <- cor(as.numeric(GetAssay(d$control_repeats_only, 'RNA')[re,cells]), -->
<!--                          as.numeric(GetAssay(d$repeats_featurecounts, 'RNA')[re, cells]), -->
<!--                          method = 'spearman') -->
<!-- } -->
<!-- ``` -->


<!-- ```{r, eval = FALSE} -->
<!-- hist(unlist(crepeat), -->
<!--      main = "correlation across repeats\nrepeats vs nongene-repeats", -->
<!--      xlab = "Spearman's rho") -->
<!-- ``` -->

<!-- Show correlation values per family etc -->

<!-- ```{r} -->
<!-- merged <- na.omit(data.frame(repfamily = names(crepeat), -->
<!--                           rho = as.numeric(crepeat))) -->

<!-- means <-  apply(GetAssayData(object = d$repeats, slot = "counts"), 1, mean) -->
<!-- means <- data.frame(repfamily = names(means), -->
<!--                     mean = as.numeric(means), -->
<!--                     stringsAsFactors = FALSE) -->

<!-- sds <-  apply(GetAssayData(object = d$repeats, slot = "counts"), 1, sd) -->
<!-- sds <- data.frame(repfamily = names(sds), -->
<!--                     sd = as.numeric(sds)) -->

<!-- merged <- merge(merged, sds, by = 'repfamily', all.x = TRUE) -->
<!-- merged <- merge(merged, means, by = 'repfamily', all.x = TRUE) -->
<!-- merged$log10mean <- log10(merged$mean + 1)  -->

<!-- idx <- as.character(merged[order(merged$rho, decreasing = TRUE), 'repfamily']) -->

<!-- ## wide to long -->
<!-- merged <- melt(merged, id.vars=c("repfamily")) -->

<!-- ## merged <- merged[order(merged$value, merged$variable),] -->

<!-- merged$repfamily <- factor(merged$repfamily, levels = idx) -->
<!-- ``` -->

<!-- ```{r, fig.width = 20, fig.height = 10} -->
<!-- ggplot(merged, aes(x=repfamily, y=value)) + -->
<!--     geom_point() + -->
<!--     facet_grid(vars(variable), scales ='free') + -->
<!--     theme(axis.text.x = element_text(angle = 45, hjust = 1)) -->

<!-- ``` -->


# Confusion matrix clusters

At a given resolution, compare both clusterings.

Color scale depicts Rand Index.


```{r}
aris <- list()
aris_stored <- list()
```

## All vs SCINA

Not plotted, kept for further analysis

```{r}

for (flavour in names(d)) {
    aris <- list()
    i <- 1

    for (flavour_res in seq(0.2, 2, 0.2)) {
        flavour_res <- sprintf('RNA_snn_res.%s', flavour_res)
        rownames(d[[flavour]]@meta.data) <- d[[flavour]]@meta.data$cell
        known <- rownames(d[[flavour]]@meta.data[d[[flavour]]@meta.data$scina != 'unknown',])

        aris[[i]] <- c(sprintf('%s_%s (n=%s)', flavour, flavour_res,
                               length(unique(d[[flavour]]@meta.data[known, flavour_res]))),
                       sprintf('scina_%s (n=%s)', 'scina',
                               length(unique(d[[flavour]]@meta.data[known, 'scina']))),
                       adjustedRandIndex(d[[flavour]]@meta.data[known, flavour_res],
                                         d[[flavour]]@meta.data[known, 'scina']))
        
        i <- i +1
    }    

    aris <- do.call(rbind.data.frame, aris)
    colnames(aris) <- c(sprintf('%s_res', flavour), 'scina', 'ari')
    aris$ari <- as.numeric(as.character(aris$ari))
    print(aris)
    
    aris_stored[[sprintf('%s__scina', flavour)]] <- aris

}
```


<!-- ## Genes vs repeats (cellranger) -->

<!-- ```{r, results = 'asis', fig.width = 4, fig.height = 4, cache = FALSE} -->
<!-- aris <- list() -->
<!-- i <- 1 -->
<!-- for (genes_res in seq(0.2, 2, 0.2)) { -->
<!--     genes_res_tag <- sprintf('RNA_snn_res.%s', genes_res) -->
    
<!--     for (repeats_res in seq(0.2, 2, 0.2)) { -->
<!--         repeats_res_tag <- sprintf('RNA_snn_res.%s', repeats_res) -->

<!--         cells <- intersect(rownames(d$genes_cellranger@meta.data), rownames(d$repeats_cellranger@meta.data)) -->
        
   

<!--         aris[[i]] <- c(sprintf('genes_%s (n=%s)', genes_res, -->
<!--                                length(unique(d$genes_cellranger@meta.data[cells, genes_res_tag]))), -->
<!--                        sprintf('repeats_cr_%s (n=%s)', repeats_res, -->
<!--                                length(unique(d$repeats_cellranger@meta.data[cells, repeats_res_tag]))), -->
<!--                        adjustedRandIndex(d$genes_cellranger@meta.data[cells,genes_res_tag], -->
<!--                                          d$repeats_cellranger@meta.data[cells,repeats_res_tag])) -->
<!--         i <- i +1 -->
<!--     }     -->
<!-- } -->

<!-- aris <- do.call(rbind.data.frame, aris) -->
<!-- colnames(aris) <- c('genes_res', 'repeats_cr_res', 'ari') -->
<!-- aris$ari <- as.numeric(as.character(aris$ari)) -->
<!-- ``` -->


<!-- ```{r, fig.width = 6, fig.height = 6} -->
<!-- aris_wide <- reshape2::dcast(aris, genes_res~repeats_cr_res, value.var="ari") -->

<!-- rownames(aris_wide)<- aris_wide$genes_res -->
<!-- aris_wide <- aris_wide[,-1] -->

<!-- pheatmap(aris_wide, cluster_rows = FALSE, cluster_cols = FALSE, -->
<!--          color = colorRampPalette(c("white","blue"))(20)) -->
<!-- ``` -->

<!-- ```{r store_aris} -->
<!-- ## aris_stored <- list() -->
<!-- aris_stored[['genes__repeats_cr']] <- aris -->
<!-- ``` -->

<!-- ## Genes vs repeats (featurecounts multimappers) -->


<!-- ```{r, results = 'asis', fig.width = 4, fig.height = 4, cache = FALSE} -->
<!-- aris <- list() -->
<!-- i <- 1 -->
<!-- for (genes_res in seq(0.2, 2, 0.2)) { -->
<!--     genes_res <- sprintf('RNA_snn_res.%s', genes_res) -->
    
<!--     for (repeats_res in seq(0.2, 2, 0.2)) { -->
<!--         repeats_res <- sprintf('RNA_snn_res.%s', repeats_res) -->

<!--         cells <- intersect(rownames(d$genes_cellranger@meta.data), rownames(d$repeats_featurecounts_multi@meta.data)) -->
        
   

<!--         aris[[i]] <- c(sprintf('genes_%s (n=%s)', genes_res, -->
<!--                                length(unique(d$genes_cellranger@meta.data[cells, genes_res]))), -->
<!--                        sprintf('repeats_fc_%s (n=%s)', repeats_res, -->
<!--                                length(unique(d$repeats_featurecounts_multi@meta.data[cells, repeats_res]))), -->
<!--                        adjustedRandIndex(d$genes_cellranger@meta.data[cells,genes_res], -->
<!--                                          d$repeats_featurecounts_multi@meta.data[cells,repeats_res])) -->
<!--         i <- i +1 -->
<!--     }     -->
<!-- } -->

<!-- aris <- do.call(rbind.data.frame, aris) -->
<!-- colnames(aris) <- c('genes_res', 'repeats_fc_res', 'ari') -->
<!-- aris$ari <- as.numeric(as.character(aris$ari)) -->
<!-- ``` -->

<!-- ```{r, fig.width = 6, fig.height = 6} -->
<!-- aris_wide <- reshape2::dcast(aris, genes_res~repeats_fc_res, value.var="ari") -->

<!-- rownames(aris_wide)<- aris_wide$genes_res -->
<!-- aris_wide <- aris_wide[,-1] -->

<!-- pheatmap(aris_wide, cluster_rows = FALSE, cluster_cols = FALSE, -->
<!--          color = colorRampPalette(c("white","blue"))(20)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- aris_stored[['genes__repeats_fc_multi']] <- aris -->
<!-- ``` -->


<!-- ## Genes vs repeats (featurecounts uniquemappers) -->


<!-- ```{r, results = 'asis', fig.width = 4, fig.height = 4, cache = FALSE} -->
<!-- aris <- list() -->
<!-- i <- 1 -->
<!-- for (genes_res in seq(0.2, 2, 0.2)) { -->
<!--     genes_res <- sprintf('RNA_snn_res.%s', genes_res) -->
    
<!--     for (repeats_res in seq(0.2, 2, 0.2)) { -->
<!--         repeats_res <- sprintf('RNA_snn_res.%s', repeats_res) -->

<!--         cells <- intersect(rownames(d$genes_cellranger@meta.data), rownames(d$repeats_featurecounts_unique@meta.data)) -->
        
   

<!--         aris[[i]] <- c(sprintf('genes_%s (n=%s)', genes_res, -->
<!--                                length(unique(d$genes_cellranger@meta.data[cells, genes_res]))), -->
<!--                        sprintf('repeats_fc_%s (n=%s)', repeats_res, -->
<!--                                length(unique(d$repeats_featurecounts_unique@meta.data[cells, repeats_res]))), -->
<!--                        adjustedRandIndex(d$genes_cellranger@meta.data[cells,genes_res], -->
<!--                                          d$repeats_featurecounts_unique@meta.data[cells,repeats_res])) -->
<!--         i <- i +1 -->
<!--     }     -->
<!-- } -->

<!-- aris <- do.call(rbind.data.frame, aris) -->
<!-- colnames(aris) <- c('genes_res', 'repeats_fc_res', 'ari') -->
<!-- aris$ari <- as.numeric(as.character(aris$ari)) -->
<!-- ``` -->

<!-- ```{r, fig.width = 6, fig.height = 6} -->
<!-- aris_wide <- reshape2::dcast(aris, genes_res~repeats_fc_res, value.var="ari") -->

<!-- rownames(aris_wide)<- aris_wide$genes_res -->
<!-- aris_wide <- aris_wide[,-1] -->

<!-- pheatmap(aris_wide, cluster_rows = FALSE, cluster_cols = FALSE, -->
<!--          color = colorRampPalette(c("white","blue"))(20)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- aris_stored[['genes__repeats_fc_unique']] <- aris -->
<!-- ``` -->



<!-- ## Repeats cellranger vs repeats featurecounts multimappers -->

<!-- ```{r, results = 'asis', fig.width = 4, fig.height = 4, cache = FALSE} -->
<!-- aris <- list() -->
<!-- i <- 1 -->
<!-- for (featurecounts_multi_res in seq(0.2, 2, 0.2)) { -->
<!--     featurecounts_multi_res <- sprintf('RNA_snn_res.%s', featurecounts_multi_res) -->
    
<!--     for (repeats_res in seq(0.2, 2, 0.2)) { -->
<!--         repeats_res <- sprintf('RNA_snn_res.%s', repeats_res) -->

<!--         cells <- intersect(rownames(d$repeats_featurecounts_multi@meta.data), rownames(d$repeats_cellranger@meta.data)) -->
           
<!--         aris[[i]] <- c(sprintf('repeats_fc_%s (n=%s)', featurecounts_multi_res, -->
<!--                                length(unique(d$repeats_featurecounts_multi@meta.data[cells, featurecounts_multi_res]))), -->
<!--                        sprintf('repeats_cr_%s (n=%s)', repeats_res, -->
<!--                                length(unique(d$repeats_cellranger@meta.data[cells, repeats_res]))), -->
<!--                        adjustedRandIndex(d$repeats_featurecounts_multi@meta.data[cells,featurecounts_multi_res], -->
<!--                                          d$repeats_cellranger@meta.data[cells,repeats_res])) -->
<!--         i <- i +1 -->
<!--     }     -->
<!-- } -->

<!-- aris <- do.call(rbind.data.frame, aris) -->
<!-- colnames(aris) <- c('featurecounts_multi_res', 'repeats_res', 'ari') -->
<!-- aris$ari <- as.numeric(as.character(aris$ari)) -->
<!-- ``` -->


<!-- ```{r, fig.width = 6, fig.height = 6} -->
<!-- aris_wide <- reshape2::dcast(aris, featurecounts_multi_res~repeats_res, value.var="ari") -->

<!-- rownames(aris_wide)<- aris_wide$featurecounts_multi_res -->
<!-- aris_wide <- aris_wide[,-1] -->

<!-- pheatmap(aris_wide, cluster_rows = FALSE, cluster_cols = FALSE, -->
<!--          color = colorRampPalette(c("white","blue"))(20)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- aris_stored[['repeats_cr__repeats_fc_multi']] <- aris -->

<!-- ``` -->

<!-- ## Repeats cellranger vs repeats featurecounts uniquemappers -->

<!-- ```{r, results = 'asis', fig.width = 4, fig.height = 4, cache = FALSE} -->
<!-- aris <- list() -->
<!-- i <- 1 -->
<!-- for (featurecounts_unique_res in seq(0.2, 2, 0.2)) { -->
<!--     featurecounts_unique_res <- sprintf('RNA_snn_res.%s', featurecounts_unique_res) -->
    
<!--     for (repeats_res in seq(0.2, 2, 0.2)) { -->
<!--         repeats_res <- sprintf('RNA_snn_res.%s', repeats_res) -->

<!--         cells <- intersect(rownames(d$repeats_featurecounts_unique@meta.data), rownames(d$repeats_cellranger@meta.data)) -->
           
<!--         aris[[i]] <- c(sprintf('repeats_fc_%s (n=%s)', featurecounts_unique_res, -->
<!--                                length(unique(d$repeats_featurecounts_unique@meta.data[cells, featurecounts_unique_res]))), -->
<!--                        sprintf('repeats_cr_%s (n=%s)', repeats_res, -->
<!--                                length(unique(d$repeats_cellranger@meta.data[cells, repeats_res]))), -->
<!--                        adjustedRandIndex(d$repeats_featurecounts_unique@meta.data[cells,featurecounts_unique_res], -->
<!--                                          d$repeats_cellranger@meta.data[cells,repeats_res])) -->
<!--         i <- i +1 -->
<!--     }     -->
<!-- } -->

<!-- aris <- do.call(rbind.data.frame, aris) -->
<!-- colnames(aris) <- c('featurecounts_unique_res', 'repeats_res', 'ari') -->
<!-- aris$ari <- as.numeric(as.character(aris$ari)) -->
<!-- ``` -->


<!-- ```{r, fig.width = 6, fig.height = 6} -->
<!-- aris_wide <- reshape2::dcast(aris, featurecounts_unique_res~repeats_res, value.var="ari") -->

<!-- rownames(aris_wide)<- aris_wide$featurecounts_unique_res -->
<!-- aris_wide <- aris_wide[,-1] -->

<!-- pheatmap(aris_wide, cluster_rows = FALSE, cluster_cols = FALSE, -->
<!--          color = colorRampPalette(c("white","blue"))(20)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- aris_stored[['repeats_cr__repeats_fc_unique']] <- aris -->

<!-- ``` -->

<!-- ## Genes vs repeats controls -->


<!-- ```{r, results = 'asis', fig.width = 4, fig.height = 4, cache = FALSE} -->
<!-- aris <- list() -->
<!-- i <- 1 -->
<!-- for (control_res in seq(0.2, 2, 0.2)) { -->
<!--     control_res <- sprintf('RNA_snn_res.%s', control_res) -->
    
<!--     for (genes_res in seq(0.2, 2, 0.2)) { -->
<!--         genes_res <- sprintf('RNA_snn_res.%s', genes_res) -->

<!--         cells <- intersect(rownames(d$control_repeats_only_unique@meta.data), rownames(d$genes_cellranger@meta.data)) -->
        
   

<!--         aris[[i]] <- c(sprintf('control_fc_%s (n=%s)', control_res, -->
<!--                                length(unique(d$control_repeats_only_unique@meta.data[cells, control_res]))), -->
<!--                        sprintf('all_genes_cr_%s (n=%s)', genes_res, -->
<!--                                length(unique(d$genes_cellranger@meta.data[cells, genes_res]))), -->
<!--                        adjustedRandIndex(d$control_repeats_only_unique@meta.data[cells,control_res], -->
<!--                                          d$genes_cellranger@meta.data[cells,genes_res])) -->
<!--         i <- i +1 -->
<!--     }     -->
<!-- } -->

<!-- aris <- do.call(rbind.data.frame, aris) -->
<!-- colnames(aris) <- c('control_res', 'genes_res', 'ari') -->
<!-- aris$ari <- as.numeric(as.character(aris$ari)) -->
<!-- ``` -->


<!-- ```{r, fig.width = 6, fig.height = 6} -->
<!-- aris_wide <- reshape2::dcast(aris, control_res~genes_res, value.var="ari") -->

<!-- rownames(aris_wide)<- aris_wide$control_res -->
<!-- aris_wide <- aris_wide[,-1] -->

<!-- pheatmap(aris_wide, cluster_rows = FALSE, cluster_cols = FALSE, -->
<!--          color = colorRampPalette(c("white","blue"))(20)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- aris_stored[['control_fc_unique__genes_cr']] <- aris -->

<!-- ``` -->

<!-- ## Genes vs SCINA -->

<!-- Removed the unassigned class in SCINA -->

<!-- ```{r} -->
<!-- aris <- list() -->
<!-- i <- 1 -->
<!-- for (genes_res in seq(0.2, 2, 0.2)) { -->
<!--     genes_res <- sprintf('RNA_snn_res.%s', genes_res) -->
<!--     rownames(d$genes_cellranger@meta.data) <- d$genes_cellranger@meta.data$cell -->
<!--     known <- rownames(d$genes_cellranger@meta.data[d$genes_cellranger@meta.data$scina != 'unknown',]) -->

<!--     aris[[i]] <- c(sprintf('genes_%s (n=%s)', genes_res, -->
<!--                            length(unique(d$genes_cellranger@meta.data[known, genes_res]))), -->
<!--                    sprintf('scina_%s (n=%s)', 'scina', -->
<!--                            length(unique(d$genes_cellranger@meta.data[known, 'scina']))), -->
<!--                    adjustedRandIndex(d$genes_cellranger@meta.data[known, genes_res], -->
<!--                                      d$genes_cellranger@meta.data[known, 'scina'])) -->
                                     
<!--     i <- i +1 -->
<!-- }     -->

<!-- aris <- do.call(rbind.data.frame, aris) -->
<!-- colnames(aris) <- c('genes_res', 'scina', 'ari') -->
<!-- aris$ari <- as.numeric(as.character(aris$ari)) -->
<!-- print(aris) -->

<!-- ``` -->


# Differential repeat expression by SCINA identity {.tabset}

```{r}
## marker list
ml <- list()
```

```{r datatable_does_not_render, eval = TRUE}
for (item in names(d)) {
    cat('## ', item, '\n\n')
    
    Idents(d[[item]]) <- 'scina'

    ## find markers for every scina identity (discarding the unplaced); report only positives    
    ml[[item]] <- FindAllMarkers(subset(d[[item]], idents = 'unknown', invert = TRUE),
                              only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)

    ## DT::datatable(ml[[item]])
    print(head(ml[[item]]))
    
    cat('\n\n')
}

```



# F1 scores unsupervised clustering : SCINA cell types

Largely derived from Lukas Weber's https://github.com/lmweber/cytometry-clustering-comparison/blob/master/helpers/helper_match_evaluate_multiple.R (Hungarian algorithm)

@todo document parameters

```{r}
map_levels <- function(x){
    ## x<- as.character(iris$Species)
    if(is.factor(x)) { 
        nlevs <- nlevels(x)
        levs <- levels(x)
    } else {   # character
        levs <- unique(x)
        nlevs <- length(levs)
    }
    fd <- data.frame(level = levs, code = 1:nlevs)
    return(fd)
}

## data(iris)
## map_levels(iris$Species)
## map_levels(as.character(iris$Species))
```

```{r}

## inputs are factor vectors
hungarian_weber_with_labels <- function(clus_algorithm, clus_truth) {    
    ## number of detected clusters
    n_clus <- length(table(clus_algorithm))

    clus_names <- map_levels(clus_algorithm)
    clus <- as.numeric(clus_algorithm)

    truth_names <- map_levels(clus_truth)
    clus_truth <- as.numeric(clus_truth)

    ## remove unassigned cells (NA's in clus_truth)
    unassigned <- is.na(clus_truth)
    clus <- clus[!unassigned]
    clus_truth <- clus_truth[!unassigned]
    if (length(clus) != length(clus_truth)) warning("vector lengths are not equal")
    
    tbl_algorithm <- table(clus)
    tbl_truth <- table(clus_truth)

    ## detected clusters in rows, true populations in columns
    pr_mat <- re_mat <- F1_mat <- matrix(NA, nrow = length(tbl_algorithm), ncol = length(tbl_truth))
    
    for (i in 1:length(tbl_algorithm)) {
        for (j in 1:length(tbl_truth)) {
            i_int <- as.integer(names(tbl_algorithm))[i]  ## cluster number from algorithm
            j_int <- as.integer(names(tbl_truth))[j]  ## cluster number from true labels
            j_label <- as.character(truth_names[truth_names$code== j_int, 'level'])
                
            true_positives <- sum(clus == i_int & clus_truth == j_int, na.rm = TRUE)
            detected <- sum(clus == i_int, na.rm = TRUE)
            truth <- sum(clus_truth == j_int, na.rm = TRUE)
            
            ## calculate precision, recall, and F1 score
            precision_ij <- true_positives / detected
            recall_ij <- true_positives / truth
            F1_ij <- 2 * (precision_ij * recall_ij) / (precision_ij + recall_ij)
            
            if (F1_ij == "NaN") F1_ij <- 0
            
            pr_mat[i, j] <- precision_ij
            re_mat[i, j] <- recall_ij
            F1_mat[i, j] <- F1_ij
        }
    }
    
    ## put back cluster labels (note some row names may be missing due to removal of unassigned cells)
    rownames(pr_mat) <- rownames(re_mat) <- rownames(F1_mat) <- names(tbl_algorithm)
    colnames(pr_mat) <- colnames(re_mat) <- colnames(F1_mat) <- names(tbl_truth)
  
    ## match labels using Hungarian algorithm applied to matrix of F1 scores (Hungarian
    ## algorithm calculates an optimal one-to-one assignment)
    
    ## use transpose matrix (Hungarian algorithm assumes n_rows <= n_cols)
    F1_mat_trans <- t(F1_mat)
    
    if (nrow(F1_mat_trans) <= ncol(F1_mat_trans)) {
        ## if fewer (or equal no.) true populations than detected clusters, can match all true populations
        labels_matched <- clue::solve_LSAP(F1_mat_trans, maximum = TRUE)
        ## use row and column names since some labels may have been removed due to unassigned cells
        labels_matched <- as.numeric(colnames(F1_mat_trans)[as.numeric(labels_matched)])
        names(labels_matched) <- rownames(F1_mat_trans)
        
    } else {
        ## if fewer detected clusters than true populations, use transpose matrix and assign
        ## NAs for true populations without any matching clusters
        labels_matched_flipped <- clue::solve_LSAP(F1_mat, maximum = TRUE)
        ## use row and column names since some labels may have been removed due to unassigned cells
        labels_matched_flipped <- as.numeric(rownames(F1_mat_trans)[as.numeric(labels_matched_flipped)])
        names(labels_matched_flipped) <- rownames(F1_mat)
        
        labels_matched <- rep(NA, ncol(F1_mat))
        names(labels_matched) <- rownames(F1_mat_trans)
        labels_matched[as.character(labels_matched_flipped)] <- as.numeric(names(labels_matched_flipped))
    }
    
    ## precision, recall, F1 score, and number of cells for each matched cluster
    pr <- re <- F1 <- n_cells_matched <- rep(NA, ncol(F1_mat))
    names(pr) <- names(re) <- names(F1) <- names(n_cells_matched) <- names(labels_matched)
    
    for (i in 1:ncol(F1_mat)) {
        ## set to 0 if no matching cluster (too few detected clusters); use character names 
        ## for row and column indices in case subsampling completely removes some clusters
        pr[i] <- ifelse(is.na(labels_matched[i]), 0, pr_mat[as.character(labels_matched[i]), names(labels_matched)[i]])
        re[i] <- ifelse(is.na(labels_matched[i]), 0, re_mat[as.character(labels_matched[i]), names(labels_matched)[i]])
        F1[i] <- ifelse(is.na(labels_matched[i]), 0, F1_mat[as.character(labels_matched[i]), names(labels_matched)[i]])
        
        n_cells_matched[i] <- sum(clus == labels_matched[i], na.rm = TRUE)
    }
    
    ## means across populations
    mean_pr <- mean(pr)
    mean_re <- mean(re)
    mean_F1 <- mean(F1)

    ## add back original names
    for (item in c('pr', 're', 'F1', 'labels_matched', 'n_cells_matched')) {
        curr <- get(item)
        names(curr) <- truth_names[names(curr), 'level']
        assign(item, curr) 
    }
   
    return(list(n_clus = n_clus, 
                pr = pr, 
                re = re, 
                F1 = F1, 
                labels_matched = labels_matched, 
                n_cells_matched = n_cells_matched, 
                mean_pr = mean_pr, 
                mean_re = mean_re, 
                mean_F1 = mean_F1))
}

```

```{r, eval = FALSE}
a <- 1
saveRDS(object = d, file = params$seurat_output) # checkpoint
saveRDS(object = a, file = params$aris_output)
saveRDS(object = a, file = params$cobra_output)
saveRDS(object = a, file = params$markers_output)

```

```{r, eval = FALSE}
knitr::knit_exit()
```

```{r}
hung <- list()

for (flavour in names(d)) {
    resolutions <- grep('RNA_snn_res', colnames(d[[flavour]]@meta.data), value = TRUE)
    hung[[flavour]] <- list()
    for (res in resolutions) {
        rownames(d[[flavour]]@meta.data) <- d[[flavour]]@meta.data$cell
        known <- rownames(d[[flavour]]@meta.data[d[[flavour]]@meta.data$scina != 'unknown',])

        length(as.factor(d[[flavour]]@meta.data[known, res]))
        length(as.factor(d[[flavour]]@meta.data[known, 'scina']))
        hung[[flavour]][[res]] <- hungarian_weber_with_labels(d[[flavour]]@meta.data[known, res],
                                                         as.factor(d[[flavour]]@meta.data[known, 'scina']))

    }    
}

```

```{r}

cobra <- list()
i <- 1
for (flavour in names(hung)) {
    for (res in names(hung[[flavour]])) {
    cobra[[i]] <- data.frame(cell = names(hung[[flavour]][[res]]$pr),
                             pr = hung[[flavour]][[res]]$pr,
                             re = hung[[flavour]][[res]]$re,
                             F1 = hung[[flavour]][[res]]$F1,
                             res = res,
                             flavour = flavour)
    i = i +1
    }
}

cobra <- do.call(rbind.data.frame, cobra)
cobra$id <- params$identifier

```


For each cell type, get the max F1 stratifying by flavour *regardless of the resolution*.

```{r}
tryCatch({
    ## cobra <- cobra[order(cobra$F1, cobra$cell, decreasing = TRUE),]
    ## maxf1 <- cobra[0,]
    maxF1 <- list()

    for (flavour in levels(cobra$flavour)) {
        for (cell in levels(cobra$cell)) {
            maxF1[[paste(flavour, cell)]] <- c(flavour, cell, max(cobra[cobra$flavour == flavour &
                                                                        cobra$cell == cell, 'F1']))
        }
        
    }


    maxF1 <- do.call(rbind.data.frame, maxF1)
    colnames(maxF1) <- c('flavour', 'cell', 'max_F1')
    maxF1$max_F1 <- as.numeric(as.character(maxF1$max_F1))
    
    maxF1$cell <- factor(as.character(maxF1$cell),
                         levels = unique(as.character(maxF1$cell[order(maxF1$max_F1)])))
}, error = function(x) print(x))
```

```{r}
DT::datatable(as.data.frame(cobra %>%
              group_by(flavour, cell) %>%
              summarize(max(F1)) %>%
              arrange(desc(`max(F1)`))))
````


```{r, fig.height = 8, fig.width = 10}
ggplot(data = cobra, aes(x = pr, y =  re, group = cell, col = cell)) +
    geom_point() +
    facet_grid(flavour~res, margins = FALSE) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
    scale_colour_manual(values = setNames(pal$color, as.character(pal$identity)))

```

```{r, fig.height = 8, fig.width = 8}
ggplot(data = cobra, aes(x = res, y =  F1, group=flavour, col = cell)) +
    geom_point() +
    facet_wrap(~flavour) + 
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
    scale_colour_manual(values = setNames(pal$color, as.character(pal$identity))) +
    labs(x = 'resolution')

```

```{r, fig.height = 7, fig.width = 10}

cobra$resolution <- gsub('RNA_snn_res_', '', cobra$res)
ggplot(data = cobra, aes(x = re, y =  F1, group=resolution, col =cell)) +
    geom_point() +
    facet_grid(flavour~res) + 
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
    scale_colour_manual(values = setNames(pal$color, as.character(pal$identity)))

```

```{r, fig.width = 5, fig.height = 5}

tryCatch({
    ## ## sorting in a more sensible way
    ## @todo adapt to this run
    ## maxF1$flavour <- factor(maxF1$flavour,
    ##                         levels = c('genes_alevin', 'genes_featurecounts',
    ##                                    'both_unique', 'both_multi', 'both_alevin',
    ##                                    'repeats_alevin',
    ##                                    'repeats_bowtie_unique', 'repeats_bowtie_multi',
    ##                                    'repeats_featurecounts_unique', 'repeats_featurecounts_multi',
    ##                                    'control_repeats_only_unique', 'control_repeats_only_multi'))
    

    ggplot(data = maxF1, aes(x= flavour, y = max_F1, col = cell, group = cell)) +
        geom_point() +
        theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
        scale_colour_manual(values = setNames(pal$color, as.character(pal$identity)))
}, error = function(x) print(x)) 
```

# Comparison across techniques


<!-- ## For genes -->


<!-- ## Euclidean distance -->


<!-- ```{r} -->


<!-- genes_shared <- Reduce(intersect, sapply(d[grep('genes', names(d))], rownames)) -->
<!-- cells_shared <- Reduce(intersect, sapply(d[grep('genes', names(d))], colnames)) -->
<!-- ## rather, use old variable from the qc step -->
<!-- ## cells_shared <- selected_cells -->

<!-- stopifnot(length(genes_shared) > 0) -->



<!-- stopifnot(length(cells_shared) > 0) -->
          
    
<!-- ## oned <- lapply(d, function(x) as.vector(as.matrix( -->
<!--                                   ## GetAssayData(d[[x]])[genes_shared, cells_shared], 'counts'))) -->


<!-- oned <- list() -->
<!-- for (item in grep('repeats', names(d), value = TRUE)) { -->
<!--       oned[[item]] <- as.vector(as.matrix( -->
<!--           GetAssayData(d[[item]], 'counts')[genes_shared, cells_shared])) -->
<!-- } -->

<!-- ## oned_df <- setNames(object = do.call(rbind.data.frame, oned), -->
<!-- ##                     c(NULL,  grep('repeats', names(d), value = TRUE))) -->

<!-- oned_df <- t(simplify2array(oned)) -->

<!-- rm(oned) -->

<!-- oned_dist <- dist(oned_df,  method = 'euclidean') -->

<!-- oned_dist <- as.data.frame(as.matrix(oned_dist)) -->

<!-- colnames(oned_dist) <-  grep('repeats', names(d), value = TRUE) -->
<!-- rownames(oned_dist) <- colnames(oned_dist) -->
<!-- head(oned_dist) -->
<!-- hc_dist <- hclust(d = as.dist(oned_dist), method = 'ward.D') -->


<!-- plot(hc_dist) -->

<!-- ``` -->

<!-- Plus pheatmap-like representation.. of the distances maybe? -->

<!-- ```{r, fig.width = 8, fig.height = 8} -->
<!-- pheatmap(oned_dist, cluster_rows = hc_dist, cluster_cols = hc_dist) -->
<!-- ``` -->



<!-- ### Correlations -->

<!-- Similarly, for Spearman's correlations (it's not angular distances! 1 - rho value here). -->

<!-- ```{r} -->
<!-- oned_cor <- cor(t(oned_df), method = 'spearman') -->

<!-- oned_cor <- as.data.frame(as.matrix(oned_cor)) -->

<!-- colnames(oned_cor) <-  grep('repeats', names(d), value = TRUE) -->
<!-- rownames(oned_cor) <- colnames(oned_cor) -->
<!-- head(oned_cor) -->
<!-- hc_cor <- hclust(d = as.dist(1- oned_cor)) -->


<!-- plot(hc_cor) -->
<!-- ``` -->



<!-- ```{r, fig.width = 8, fig.height = 8} -->
<!-- pheatmap(oned_cor, cluster_rows = hc_cor, cluster_cols = hc_cor, display_numbers = TRUE ) -->
<!-- ``` -->

<!-- ## For repeats -->


<!-- ## Euclidean distance -->


<!-- ```{r} -->


<!-- repeats_shared <- Reduce(intersect, sapply(d[grep('repeats|both', names(d))], rownames)) -->
<!-- ## cells_shared <- Reduce(intersect, sapply(d[grep('repeats|both', names(d))], colnames)) -->
<!-- ## rather, use old variable from the qc step -->
<!-- cells_shared <- selected_cells -->

<!-- stopifnot(length(repeats_shared) > 0) -->



<!-- stopifnot(length(cells_shared) > 0) -->
          
    
<!-- ## oned <- lapply(d, function(x) as.vector(as.matrix( -->
<!--                                   ## GetAssayData(d[[x]])[repeats_shared, cells_shared], 'counts'))) -->


<!-- oned <- list() -->
<!-- for (item in grep('repeats', names(d), value = TRUE)) { -->
<!--       oned[[item]] <- as.vector(as.matrix( -->
<!--           GetAssayData(d[[item]], 'counts')[repeats_shared, cells_shared])) -->
<!-- } -->

<!-- ## oned_df <- setNames(object = do.call(rbind.data.frame, oned), -->
<!-- ##                     c(NULL,  grep('repeats', names(d), value = TRUE))) -->

<!-- oned_df <- t(simplify2array(oned)) -->

<!-- rm(oned) -->

<!-- oned_dist <- dist(oned_df,  method = 'euclidean') -->

<!-- oned_dist <- as.data.frame(as.matrix(oned_dist)) -->

<!-- colnames(oned_dist) <-  grep('repeats', names(d), value = TRUE) -->
<!-- rownames(oned_dist) <- colnames(oned_dist) -->
<!-- head(oned_dist) -->
<!-- hc_dist <- hclust(d = as.dist(oned_dist), method = 'ward.D') -->


<!-- plot(hc_dist) -->

<!-- ``` -->

<!-- Plus pheatmap-like representation.. of the distances maybe? -->

<!-- ```{r, fig.width = 8, fig.height = 8} -->
<!-- pheatmap(oned_dist, cluster_rows = hc_dist, cluster_cols = hc_dist) -->
<!-- ``` -->



<!-- ### Correlations -->

<!-- Similarly, for Spearman's correlations (it's not angular distances! 1 - rho value here). -->

<!-- ```{r} -->
<!-- oned_cor <- cor(t(oned_df), method = 'spearman') -->

<!-- oned_cor <- as.data.frame(as.matrix(oned_cor)) -->

<!-- colnames(oned_cor) <-  grep('repeats', names(d), value = TRUE) -->
<!-- rownames(oned_cor) <- colnames(oned_cor) -->
<!-- head(oned_cor) -->
<!-- hc_cor <- hclust(d = as.dist(1- oned_cor)) -->


<!-- plot(hc_cor) -->
<!-- ``` -->

# Export objects

List of seurat objects

```{r}
saveRDS(object = d, file = params$seurat_output)
saveRDS(object = aris_stored, file = params$aris_output)
saveRDS(object = cobra, file = params$cobra_output)
saveRDS(object = ml, file = params$markers_output)
```

# Timestamp

```{r sessionInfo, cache = FALSE}
date()
sessionInfo()
devtools::session_info()

```

