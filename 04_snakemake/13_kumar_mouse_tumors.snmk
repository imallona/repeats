#!/usr/bin/env snakemake -s
## 
## Started 14th Jan 2020
##
## Izaskun Mallona
## GPLv3

import os.path as op
from glob import glob

# https://www.ncbi.nlm.nih.gov/Traces/study/?query_key=8&WebEnv=MCID_5f7acd5b7a1fbfa3a968b8a2&o=protocol_sam_s%3Ad
SRRS = ['SRR8165390', 'SRR8165391', 'SRR8165392', 'SRR8165393', 'SRR8165394', 'SRR8165395',
        'SRR8165396', 'SRR8165397', 'SRR8165398', 'SRR8165399', 'SRR8165400', 'SRR8165401',
        'SRR8165402', 'SRR8165404', 'SRR8165405', 'SRR8165406', 'SRR8165407', 'SRR8165408',
        'SRR8165409', 'SRR8165410', 'SRR8165411', 'SRR8165412', 'SRR8165413', 'SRR8165414',
        'SRR8165415', 'SRR8165416', 'SRR8165417', 'SRR8165418', 'SRR8165419', 'SRR8165420',
        'SRR8165421', 'SRR8165422', 'SRR8165423', 'SRR8165424', 'SRR8165425', 'SRR8165426',
        'SRR8165427', 'SRR8165428', 'SRR8165429', 'SRR8165430', 'SRR8165431', 'SRR8165432',
        'SRR8165433', 'SRR8165434', 'SRR8165435', 'SRR8165436', 'SRR8165437', 'SRR8165438']

SRRS_PROOF_OF_CONCEPT = ['SRR8165390', 'SRR8165391']

## config file start ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# configfile: "config.yaml"
# validate(config, "schemas/config.schema.yaml")

# samples = pd.read_csv(config["samples"], sep = '\t').set_index("id", drop=False)

# print(op.join(config["base"], 'data', config["run_name"]))

# samples_R2, = glob_wildcards(op.join(config["base"], "data", config["run_name"], "{sample}_1.fastq.gz"))
# samples_R1, = glob_wildcards(op.join(config["base"], "data", config["run_name"], "{sample}_2.fastq.gz"))
# samples_I3, = glob_wildcards(op.join(config["base"], "data", config["run_name"], "{sample}_3.fastq.gz"))

# ## 
# this is needed to be hardcoded/config file

configfile: op.join('config', 'config_13_kumar_mouse_tumors.yaml')
# validate(data = config, schema = op.join("schemas", "config.schema.yaml"))


try:
   if not op.exists(op.dirname(op.join(config["base"], 'annotation'))):
      os.makedirs(op.join(config["base"], 'annotation'))
except OSError as err:
   print(err)
      
for item in ['bowtie', 'star', 'salmon']:
   try:
      if not op.exists(op.dirname(op.join(config["base"], 'indices', item))):
         os.makedirs(op.join(config["base"], 'indices', item))
   except OSError as err:
      print(err)
      
## Folder structure end ----------------------------------------------------------------------- ##

include: "/home/imallona/src/repeats_sc/04_snakemake/chromium_flow_with_config.snmk"

def get_samples():
   return(SRRS)

def get_samples_comma():
   return(','.join(SRRS))

def get_cbs(path):
   return(' '.join([ op.join(path, item) + '_S1_L001_R2_001.fastq.gz' for item in get_samples()]))


def get_reads(path):
   return(' '.join([ op.join(path, item) + '_S1_L001_R1_001.fastq.gz' for item in get_samples()]))

# print(get_samples())

rule all:
    input:
        expand(op.join(config["base"], 'data', config["run_name"], '{sample}' + '_S1_L001_R1_001.fastq.gz'),
               sample = get_samples()),
        expand(op.join(config["base"], 'runs', config["run_name"], "{sample}", 'cellranger_standard', 'outs',
                       'possorted_genome_bam.bam'),
          sample = get_samples()),
        expand(op.join(config["base"], 'runs', config["run_name"], "{sample}", 'cellranger_repeats', 'outs', 'web_summary.html'),
          sample = get_samples()),
        op.join(config["base"], 'runs', config["run_name"], 'alevin', 'genes', 'alevin', 'quants_mat.gz'),
        op.join(config["base"], 'runs', config["run_name"], 'alevin', 'repeats', 'alevin', 'quants_mat.gz'),
        op.join(config["base"], 'runs', 'kumar_integration.html'),
        expand(op.join(config["base"], "runs", config["run_name"], "{sample}",
                       'bowtie_repeatome', "{sample}"
                       '{multimappers}',
                       "all_cells_repeats.counts.gz"),
               sample = get_samples(),
               multimappers = ['unique_reads']),
        expand(op.join(config["base"], "runs", config["run_name"], '{sample}', 
                       "count_repeats_on_cellranger_standard",
                       "{multimappers}",
                       config["run_name"] + "_transcriptome_repeats.counts.summary.png"),
               multimappers = ['multimappers', 'unique_reads'],
               sample = get_samples()),
        expand(op.join(config["base"], "runs", config["run_name"], '{sample}',
                       "count_repeats_on_cellranger_standard_not_overlapping_genes",
                       "{multimappers}",
                       config["run_name"] + "_transcriptome_repeats_not_genes.counts.summary.png"),
               multimappers = ['multimappers', 'unique_reads'],
               sample = get_samples()),
        # expand(op.join(config["base"], 'runs', config["run_name"], '{sample}', '{sample}_chromium_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.html'),
        #        sample = get_samples(),
        #        regress_ncount = ['TRUE', 'FALSE'],
        #        regress_nfeature = ['TRUE', 'FALSE'])

        ## files: just two files, from the many generated during the process

rule integration_kumar:
    input:
        expand(op.join(config["base"], 'data', config["run_name"], '{sample}' + '_S1_L001_R1_001.fastq.gz'),
               sample = get_samples()),
        expand(op.join(config["base"], 'runs', config["run_name"], "{sample}", 'cellranger_standard', 'outs', 'web_summary.html'),
          sample = get_samples()),
        expand(op.join(config["base"], 'runs', config["run_name"], "{sample}", 'cellranger_repeats', 'outs', 'web_summary.html'),
          sample = get_samples()),
        op.join(config["base"], 'runs', config["run_name"], 'alevin', 'genes', 'alevin', 'quants_mat.gz'),
        op.join(config["base"], 'runs', config["run_name"], 'alevin', 'repeats', 'alevin', 'quants_mat.gz'),
        expand(op.join(config["base"], "runs", config["run_name"], '{sample}', 
                       "count_repeats_on_cellranger_standard",
                       "{multimappers}",
                       config["run_name"] + "_transcriptome_repeats.counts.summary.png"),
               multimappers = ['multimappers', 'unique_reads'],
               sample = get_samples()),
        expand(op.join(config["base"], "runs", config["run_name"], '{sample}',
                       "count_repeats_on_cellranger_standard_not_overlapping_genes",
                       "{multimappers}",
                       config["run_name"] + "_transcriptome_repeats_not_genes.counts.summary.png"),
               multimappers = ['multimappers', 'unique_reads'],
               sample = get_samples())
    params:
        rmd = 'integrate_runs_kumar.Rmd',
        data_path = op.join(config["base"], 'runs', config["run_name"]),
        Rscript = config['software']['Rscript']
    output:
        html = op.join(config["base"], 'runs', 'kumar_integration.html'),
        rds = op.join(config["base"], 'runs', 'kumar_integration_seurat.rds'),
        markers = op.join(config["base"], 'runs', 'kumar_integration_markers.rds')
    log:
        op.join(config["base"], 'runs', 'kumar_integration.log')
    shell:
        """
        {params.Rscript} -e 'rmarkdown::render(\"{params.rmd}\", 
          output_file = \"{output.html}\", 
          params = list(results_path= \"{params.data_path}\",
                        markers_rds = \"{output.markers}\",
                        seurat_rds = \"{output.rds}\"))' &> {log}
        """
        
# rule knit_report_chromium_agnostic_per_sample:
#     input:
#         genes = op.join(config["base"], 'runs', config["run_name"], '{sample}', 'cellranger_standard', 'outs', 'filtered_feature_bc_matrix', 'barcodes.tsv.gz'),
#         repeats = op.join(config["base"], 'runs', config["run_name"], '{sample}', 'cellranger_repeats', 'outs', 'filtered_feature_bc_matrix', 'barcodes.tsv.gz'),
#         featurecounts_multi = op.join(config["base"], "runs", config["run_name"], '{sample}',
#                                       'count_repeats_on_cellranger_standard',
#                                       'multimappers',
#                                       config["run_name"] + "_repeats.counts.gz"),
#         featurecounts_unique = op.join(config["base"], "runs", config["run_name"], '{sample}',
#                                       'count_repeats_on_cellranger_standard',
#                                       'unique_reads',
#                                       config["run_name"] + "_repeats.counts.gz"),
#         repeats_only_featurecounts_control_multi = op.join(
#             config["base"], "runs", config["run_name"], '{sample}',
#             'count_repeats_on_cellranger_standard_not_overlapping_genes',
#             'multimappers',
#             config["run_name"] + "_repeats_not_overlapping_genes.counts.gz"),
#         repeats_only_featurecounts_control_unique = op.join(
#             config["base"], "runs", config["run_name"], '{sample}',
#             'count_repeats_on_cellranger_standard_not_overlapping_genes',
#             'unique_reads',
#             config["run_name"] + "_repeats_not_overlapping_genes.counts.gz"),
#         repeats_bowtie_multi = op.join(
#             config["base"], "runs", config["run_name"], '{sample}',
#             'bowtie_repeatome',
#             'multimappers',
#             'all_cells_repeats.counts.gz'),
#         repeats_bowtie_unique = op.join(
#             config["base"], "runs", config["run_name"], '{sample}',
#             'bowtie_repeatome',
#             'unique_reads',
#             'all_cells_repeats.counts.gz'),
#         genes_alevin = op.join(config["base"], 'runs', config["run_name"],  'alevin', 'genes', 'alevin',
#                                'quants_mat.gz'),
#         repeats_alevin = op.join(config["base"], 'runs', config["run_name"], 'alevin', 'repeats', 'alevin',
#                                  'quants_mat.gz')
#     params:
#         rmd = 'summarize_chromium_run_markers_agnostic.Rmd',
#         run_name = config["run_name"]
#     output:
#         html = op.join(config["base"], 'runs', config["run_name"], '{sample}', '{sample}_chromium_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.html'),
#         rds = op.join(config["base"], 'runs', config["run_name"], '{sample}',  '{sample}_chromium_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.rds'),
#         aris = op.join(config["base"], 'runs', config["run_name"], '{sample}',  '{sample}_aris_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.rds')
#     log:
#         op.join(config["base"], 'runs', config["run_name"], '{sample}', '{sample}_summarize_chromium_run_regress_nCount_{regress_ncount}_nFeature_{regress_nfeature}.log')
#     shell: """
#         {Rscript} -e 'rmarkdown::render(\"{params.rmd}\", 
#           output_file = \"{output.html}\", 
#           params = list(identifier = \"{params.run_name}\", 
#                      genes_cellranger = \"{input.genes}\", 
#                      repeats_cellranger = \"{input.repeats}\", 
#                      repeats_featurecounts_multi = \"{input.featurecounts_multi}\", 
#                      repeats_featurecounts_unique = \"{input.featurecounts_unique}\",
#                      repeats_only_featurecounts_control_multi = \"{input.repeats_only_featurecounts_control_multi}\", 
#                      repeats_only_featurecounts_control_unique = \"{input.repeats_only_featurecounts_control_unique}\",
#                      seurat_output = \"{output.rds}\", 
#                      aris_output = \"{output.aris}\", 
#                      regress_genes_nCount = \"{wildcards.regress_ncount}\", 
#                      regress_genes_nFeature = \"{wildcards.regress_nfeature}\",
#                      repeats_bowtie_multi = \"{input.repeats_bowtie_multi}\",
#                      repeats_bowtie_unique = \"{input.repeats_bowtie_unique}\", 
#                      genes_alevin = \"{input.genes_alevin}\",
#                      repeats_alevin = \"{input.repeats_alevin}\"))' &> {log}
#         """

    
# read 1 should contain the cell barcode and UMI tag -> _2.fastq here
# read 2 should contain cDNA sequence -> _3.fastq here
# i1 should contain the sample index -> _1.fastq here

# the index reads contain the sample index

rule get_data:
    priority:
        100
    params:
        path = op.join(config["base"], 'data', config["run_name"]),
        path_data = op.join(config["base"], 'data', config["run_name"]),
        prefetch = config['software']['prefetch'],
        vdb_validate= config['software']['vdb_validate'],
        fastqdump = config['software']['fastqdump'],
        # srr = '{wildcards.srr}'
    output:
        cb = op.join(config["base"], 'data', config["run_name"], '{srr}' + '_S1_L001_R2_001.fastq.gz'),
        r = op.join(config["base"], 'data', config["run_name"],  '{srr}' + '_S1_L001_R1_001.fastq.gz'),
        i1 = op.join(config["base"], 'data', config["run_name"],  '{srr}' + '_S1_L001_I1_001.fastq.gz'),
        tmp = temp(op.join(config["base"], 'data', config["run_name"],  '{srr}' + '.sra'))
    shell:
        """
        mkdir -p {params.path}
        cd {params.path}

        {params.prefetch} {wildcards.srr} --output-file {wildcards.srr}.sra &> \
               {wildcards.srr}_prefetch.log

        {params.vdb_validate} {wildcards.srr}.sra &> {wildcards.srr}_vdbvalidation.log
            
        {params.fastqdump}  --gzip --split-files  {wildcards.srr}.sra
  
        cd {params.path_data}
        ln -s {wildcards.srr}_1.fastq.gz {wildcards.srr}_S1_L001_I1_001.fastq.gz

        ln -s {wildcards.srr}_2.fastq.gz {wildcards.srr}_S1_L001_R1_001.fastq.gz
        ln -s {wildcards.srr}_3.fastq.gz {wildcards.srr}_S1_L001_R2_001.fastq.gz

        """

rule map_salmon_repeats_chromium:
    input:        
        tgmap = op.join(config["base"], 'indices', 'salmon', config["genome"], 'repeats_salmon', 'txp2gene.tsv'),
        idx_tracker = op.join(config["base"], 'indices', 'salmon', config["genome"], 'repeats_salmon', 'duplicate_clusters.tsv'),
        flag = op.join(config["base"], 'data', config["run_name"], SRRS[-1] + '_S1_L001_R2_001.fastq.gz')

    output:
        op.join(config["base"], 'runs', config["run_name"], 'alevin', 'repeats', 'alevin', 'quants_mat.gz')
    threads:
        config["params"]["nthreads"]
    params:
        fastqs_path = op.join(config["base"], 'data', config["run_name"]),
        processing_path = op.join(config["base"], 'runs', config["run_name"], 'alevin', 'repeats'),
        salmon_idx = op.join(config["base"], 'indices', 'salmon', config["genome"], 'repeats_salmon'),
        # cb = op.join(config["base"], 'data', config["run_name"], config["run_name"] + '_S1_L001_R1_001.fastq.gz'),
        # r = op.join(config["base"], 'data', config["run_name"], config["run_name"] + '_S1_L001_R2_001.fastq.gz'),
        r2 = get_cbs(op.join(config["base"], 'data', config["run_name"])),
        r1 = get_reads(op.join(config["base"], 'data', config["run_name"])),
        salmon = config['software']['salmon']
    log:
        op.join(config["base"], 'runs', config["run_name"], 'run_salmon_repeats_chromium.log')
    shell:
        """
    mkdir -p {params.processing_path}
    cd {params.processing_path}

    ({params.salmon} alevin \
    -l ISR \
    -1 {params.r1} \
    -2 {params.r2} \
    --chromium  \
    -i {params.salmon_idx} \
    -p {threads} -o {params.processing_path} \
    --tgMap {input.tgmap} ) 2> {log}

    touch -c {output}
        """
    

rule map_salmon_genes_chromium:
    input:        
        tgmap = op.join(config["base"], 'indices', 'salmon', config["genome"], 'genes_salmon', 'txp2gene.tsv'),
        idx_tracker = op.join(config["base"], 'indices', 'salmon', config["genome"], 'genes_salmon', 'duplicate_clusters.tsv'),
        flag = op.join(config["base"], 'data', config["run_name"], SRRS[-1] + '_S1_L001_R2_001.fastq.gz')
    output:
        op.join(config["base"], 'runs', config["run_name"], 'alevin', 'genes', 'alevin', 'quants_mat.gz')
    threads:
        config["params"]["nthreads"]
    params:
        fastqs_path = op.join(config["base"], 'data', config["run_name"]),
        processing_path = op.join(config["base"], 'runs', config["run_name"], 'alevin', 'genes'),
        salmon_idx = op.join(config["base"], 'indices', 'salmon', config["genome"], 'genes_salmon'),
        r2 = get_cbs(op.join(config["base"], 'data', config["run_name"])),
        r1 = get_reads(op.join(config["base"], 'data', config["run_name"])),
        salmon = config['software']['salmon']
    log:
        op.join(config["base"], 'runs', config["run_name"], 'run_salmon_genes_chromium.log')
    shell:
        """
    mkdir -p {params.processing_path}
    cd {params.processing_path}

    ({params.salmon} alevin \
    -l ISR \
    -1 {params.r1} \
    -2 {params.r2} \
    --chromium  \
    -i {params.salmon_idx} \
    -p {threads} -o {params.processing_path} \
    --tgMap {input.tgmap} ) 2> {log}

    touch -c {output}
        """

## salmon end


## chromium start


# rule run_cellranger_repeats:
#     input:
#         flag = op.join(config["base"], 'data', config["run_name"], SRRS[-1] + '_S1_L001_R2_001.fastq.gz'),
#         transcriptome = op.join(config["base"], 'indices', 'cellranger', 'repeats_' + config["genome"],
#                                 'repeats_' + config["genome"])
#     params:
#         fastqs_path = op.join(config["base"], 'data', config["run_name"]),
#         sample_name = get_samples_comma(),
#         local_mem_gb = config["params"]["local_mem_gb"],
#         processing_path = op.join(config["base"], 'runs', config["run_name"])
#     output:
#         op.join(config["base"], 'runs', config["run_name"], 'cellranger_repeats', 'outs', 'web_summary.html'),
#         op.join(config["base"], 'runs', config["run_name"], 'cellranger_repeats', 'outs', 'filtered_feature_bc_matrix', 'barcodes.tsv.gz')
#     threads:
#         config["params"]["nthreads"]
#     log:
#         op.join(config["base"], 'runs', config["run_name"], 'cellranger_repeats', 'run.log')
#     shell:
#         """
#         mkdir -p {params.processing_path}
#         cd {params.processing_path}
#         rm -rf cellranger_repeats
        
#         {CELLRANGER} count --id=cellranger_repeats \
#           --fastqs={params.fastqs_path} \
#           --transcriptome={input.transcriptome} \
#           --sample={params.sample_name},
#           --jobmode=local \
#           --localcores={threads} \
#           --chemistry={config["chemistry"]} \
#           --localmem={params.local_mem_gb}
#         """

rule run_cellranger_repeats_by_sample:
    input:
        sample = op.join(config["base"], 'data', config["run_name"], "{sample}_S1_L001_R2_001.fastq.gz"),
        transcriptome_flag = op.join(config["base"], 'indices', 'cellranger', 'repeats_' + config["genome"],
                                     'repeats_' + config["genome"], 'reference.json')
    params:
        fastqs_path = op.join(config["base"], 'data', config["run_name"]),
        local_mem_gb = config["params"]["local_mem_gb"],
        processing_path = op.join(config["base"], 'runs', config["run_name"], "{sample}"),
        transcriptome = op.join(config["base"], 'indices', 'cellranger', 'repeats_' + config["genome"],
                                     'repeats_' + config["genome"]),
        chemistry = config["chemistry"],
        cellranger = config['software']['cellranger'],
    output:
        op.join(config["base"], 'runs', config["run_name"],  "{sample}", 'cellranger_repeats',
                'outs', 'web_summary.html'),
        op.join(config["base"], 'runs', config["run_name"], "{sample}",  'cellranger_repeats',
                'outs', 'filtered_feature_bc_matrix', 'barcodes.tsv.gz')
    threads:
        config["params"]["nthreads"]
    log:
        op.join(config["base"], 'runs', config["run_name"], "{sample}", 'cellranger_repeats', 'run.log')
    shell:
        """
        mkdir -p {params.processing_path}
        cd {params.processing_path}
        rm -rf cellranger_repeats
        
        {params.cellranger} count --id=cellranger_repeats \
          --fastqs={params.fastqs_path} \
          --transcriptome={params.transcriptome} \
          --sample={wildcards.sample} \
          --jobmode=local \
          --localcores={threads} \
          --chemistry={params.chemistry} \
          --localmem={params.local_mem_gb}
        """
        
# rule run_cellranger_standard:
#     input:
#         flag = op.join(config["base"], 'data', config["run_name"], SRRS[-1] + '_S1_L001_R2_001.fastq.gz'),
#         transcriptome = op.join(config["base"], 'indices', 'cellranger',
#                                            CELLRANGER_DB_ID, 'reference.json')
#     params:
#         transcriptome = op.join(config["base"], 'indices', 'cellranger', CELLRANGER_DB_ID),
#         fastqs_path = op.join(config["base"], 'data', config["run_name"]),
#         sample_name = get_samples_comma(),
#         local_mem_gb = config["params"]["local_mem_gb"],
#         processing_path = op.join(config["base"], 'runs', config["run_name"])
#     output:
#         op.join(config["base"], 'runs', config["run_name"], 'cellranger_standard', 'outs', 'web_summary.html'),
#         op.join(config["base"], 'runs', config["run_name"], 'cellranger_standard', 'outs', 'filtered_feature_bc_matrix', 'barcodes.tsv.gz'),
#         op.join(config["base"], 'runs', config["run_name"], 'cellranger_standard', 'outs', 'possorted_genome_bam.bam')
#     threads:
#         config["params"]["nthreads"]
#     log:
#         op.join(config["base"], 'runs',  config["run_name"], 'cellranger_standard', 'run.log')
#     shell:
#         """
#         mkdir -p {params.processing_path}
#         cd {params.processing_path}
#         rm -rf cellranger_standard

#         {CELLRANGER} count --id=cellranger_standard \
#           --fastqs={params.fastqs_path} \
#           --transcriptome={params.transcriptome} \
#           --sample={params.sample_name},
#           --jobmode=local \
#           --localcores={threads} \
#           --chemistry={config["chemistry"]} \
#           --localmem={params.local_mem_gb}
#         """

rule run_cellranger_standard:
    input:
        sample = op.join(config["base"], 'data', config["run_name"], "{sample}_S1_L001_R2_001.fastq.gz"),
        transcriptome = op.dirname(op.join(config["base"], 'indices', 'cellranger',
                                           config['cellranger_db_id'], 'reference.json'))
    params:
        fastqs_path = op.join(config["base"], 'data', config["run_name"]),
        local_mem_gb = config["params"]["local_mem_gb"],
        processing_path = op.join(config["base"], 'runs', config["run_name"], "{sample}"),
        chemistry = config["chemistry"],
        cellranger = config['software']['cellranger'],
        transcriptome = op.join(config["base"], 'indices', 'cellranger',
                                           config['cellranger_db_id'])
    output:
        op.join(config["base"], 'runs', config["run_name"],  "{sample}", 'cellranger_standard',
                'outs', 'web_summary.html'),
        op.join(config["base"], 'runs', config["run_name"],  "{sample}", 'cellranger_standard',
                'outs', 'possorted_genome_bam.bam'),
        op.join(config["base"], 'runs', config["run_name"], "{sample}",  'cellranger_standard',
                'outs', 'filtered_feature_bc_matrix', 'barcodes.tsv.gz')
    threads:
        config["params"]["nthreads"]
    log:
        op.join(config["base"], 'runs', config["run_name"], "{sample}", 'cellranger_standard', 'run.log')
    shell:
        """
        mkdir -p {params.processing_path}
        cd {params.processing_path}
        rm -rf cellranger_standard
        
        {params.cellranger} count --id=cellranger_standard \
          --fastqs={params.fastqs_path} \
          --transcriptome={params.transcriptome} \
          --sample={wildcards.sample} \
          --jobmode=local \
          --localcores={threads} \
          --chemistry={params.chemistry} \
          --localmem={params.local_mem_gb}
        """
        
        
## chromium end

## counts, per sample start


rule run_feature_counts_repeats_not_overlapping_genes_spawned_bams_by_sample:
    input:
        flag = op.join(config["base"], "runs", config["run_name"], "{sample}", 'count_repeats_on_cellranger_standard', 'split.flag'),
        gtf = op.join(config["base"], 'annotation', op.basename(config["rep_gtf_url"]) + '_minus_' + op.basename(config["genes_gtf_url"]))
    params:
        path = op.join(config["base"], "runs", config["run_name"], "{sample}", 'count_repeats_on_cellranger_standard', 'split'),
        pigz = config['software']['pigz'],
        featurecounts = config['software']['featurecounts'],
    output:
        counts  = temp(op.join(config["base"], "runs", config["run_name"], "{sample}",
                               'count_repeats_on_cellranger_standard_not_overlapping_genes',
                               '{multimappers}',
                               config["run_name"] + "_repeats_not_overlapping_genes.counts")),
        gz_counts = op.join(config["base"], "runs", config["run_name"], "{sample}", 'count_repeats_on_cellranger_standard_not_overlapping_genes',
                            '{multimappers}',
                            config["run_name"] + "_repeats_not_overlapping_genes.counts.gz"),
        summary = op.join(config["base"], "runs", config["run_name"], "{sample}", 'count_repeats_on_cellranger_standard_not_overlapping_genes',
                          '{multimappers}',
                           config["run_name"] + "_repeats_not_overlapping_genes.counts.summary")
    log :
        log = op.join(config["base"], "runs",  config["run_name"], "{sample}", 'count_repeats_on_cellranger_standard_not_overlapping_genes',
                      '{multimappers}'
                      'feature_counts_not_overlapping_genes.log'),
    threads:
        config["params"]["nthreads"]
    # shell: """
    # cd {params.path}

    # {FEATURECOUNTS} -T {threads} \
    # -t exon \
    # -g gene_id \
    # -a {input.gtf} \
    # -o  {output.counts} \
    # {params.path}/*bam  2>&1 > {log}

    # {PIGZ} --keep -p {threads} {output.counts}
    # """
    run:
        if wildcards.multimappers == 'multimappers':
            shell("""
            echo multimappers allowed

            cd {params.path}

            {params.featurecounts} -T {threads} \
            -t exon \
            -g gene_id \
            -a {input.gtf} \
            -o  {output.counts} \
            -M \
            --fraction \
            {params.path}/*bam  2>&1 > {log}

            {params.pigz} -f --keep -p {threads} {output.counts} -c > {output.gz_counts}

            """)
        elif wildcards.multimappers == 'unique_reads':
            shell("""
            echo unique only

            cd {params.path}

            {params.featurecounts} -T {threads} \
            -t exon \
            -g gene_id \
            -a {input.gtf} \
            -o  {output.counts} \
            {params.path}/*bam  2>&1 > {log}

            {params.pigz} -f --keep -p {threads} {output.counts} -c > {output.gz_counts}
            """)
        
    
## test run bowtie start
## to avoid explicitly handling the cell barcodes, we take the cellranger output as correct
##   (e.g. splitting the cells by CB from the cellranger standard output)
rule map_bowtie_by_cell_by_sample:
    input:
        flag = op.join(config["base"], "runs", config["run_name"], "{sample}", 'count_repeats_on_cellranger_standard', 'split.flag')
    output:
        flag_map_bowtie =  op.join(config["base"], "runs", config["run_name"], "{sample}", 'bowtie_repeatome', 'split_bowtie.flag')
    params:
        bedtools = config['software']['bedtools'],
        bowtie = config['software']['bowtie'],
        split_bam_path = op.join(config["base"], "runs", config["run_name"], "{sample}", 'count_repeats_on_cellranger_standard', 'split'),
        split_fastq_path = op.join(config["base"], "runs", config["run_name"], "{sample}", 'bowtie_repeatome'),
        repeatome = op.join(config["base"], 'indices', 'bowtie', config["genome"], 'repeatome', op.splitext(op.basename(config["rep_gtf_url"]))[0])
    threads:
        config["params"]["nthreads"]
    shell:
        """
        mkdir -p {params.split_fastq_path}
        cd {params.split_fastq_path}

        for fn in $(find {params.split_bam_path} -name "*bam")
        do
           echo "$fn"
           
           {params.bedtools} bamtofastq -i "$fn" -fq "$(basename $fn .bam).fastq"
        
           ( {params.bowtie} -q \
            -v 2 \
            --threads {threads} \
            -a -k 10 --best --strata \
            --sam \
            --chunkmbs 128 {params.repeatome} "$(basename $fn .bam).fastq" | \
              samtools view -@ {threads} -bS - > "$(basename $fn .bam)_bowtie.bam" ) 2> \
              "$(basename $fn .bam)_bowtie.log"

            ## removing the fastq
            rm "$fn"
        done

        touch {output.flag_map_bowtie}
        """

# multimappers with ifelse?
rule featurecounts_bowtie_repeats_repeatome_by_sample:
    input:
        # bam = op.join(config["base"], "runs", config["run_name"], "{sample}", "bowtie_repeatome", "{fastq}.bam"),
        flag_map_bowtie =  op.join(config["base"], "runs", config["run_name"], "{sample}", 'bowtie_repeatome', 'split_bowtie.flag'),
        gtf = op.join(config["base"], 'annotation', op.basename(config["rep_gtf_url"])),
        fake_repeatome_gtf = op.join(config["base"], 'annotation', 'fake_repeatome_from_' + op.splitext(op.basename(config["rep_gtf_url"]))[0]) + '.gtf.gz',
        pigz = config['software']['pigz'],
        featurecounts = config['software']['featurecounts'],
    output:
        counts  = temp(op.join(config["base"], "runs", config["run_name"], "{sample}", "bowtie_repeatome", "{multimappers}",
                               "all_cells_repeats.counts")),
        gz_counts = op.join(config["base"], "runs", config["run_name"], "{sample}", "bowtie_repeatome", "{multimappers}",
                            "all_cells_repeats.counts.gz")
    params:
        bam_path = op.join(config["base"], "runs", config["run_name"], "{sample}", 'bowtie_repeatome'),
        processing_path = op.join(config["base"], "runs", config["run_name"], "{sample}", "{multimappers}", 'bowtie_repeatome')
    log :
        op.join(config["base"], "runs", config["run_name"], "{sample}", "bowtie_repeatome", "{multimappers}", "all_cell_featurecounts.log"),
    threads:
        config["params"]["nthreads"]
    # shell:
    #    """
    #    ## note multimappers are counted

    #    mkdir -p {params.processing_path}

    #    cd {params.processing_path}
       
    #    {FEATURECOUNTS} -T {threads} \
    #    -t exon \
    #    -g gene_id \
    #    -a {input.fake_repeatome_gtf} \
    #    -o  {output.counts} \
    #    -M \
    #    {params.bam_path}/*bam  &> {log}

    #    {PIGZ} --keep  -p {threads} {output.counts}
    #    """
    run:
        if wildcards.multimappers == 'multimappers':
            shell("""
            echo multimappers allowed

            mkdir -p {params.processing_path}

            cd {params.processing_path}
            
            {params.featurecounts} -T {threads} \
            -t exon \
            -g gene_id \
            -a {input.fake_repeatome_gtf} \
            -o  {output.counts} \
            -M --fraction \
            {params.bam_path}/*bam  &> {log}

            {params.pigz} --keep  -p {threads} {output.counts}
         """)
        elif wildcards.multimappers == 'unique_reads':
            shell("""
            echo unique only

            mkdir -p {params.processing_path}

            cd {params.processing_path}
            
            {params.featurecounts} -T {threads} \
            -t exon \
            -g gene_id \
            -a {input.fake_repeatome_gtf} \
            -o  {output.counts} \
            {params.bam_path}/*bam  &> {log}

            {params.pigz} --keep  -p {threads} {output.counts}

            """)
    

## test run bowtie end

rule spawn_cellranger_bam_file_by_cell_by_sample:
    input:
        bam = op.join(config["base"], 'runs', config["run_name"], "{sample}", 'cellranger_standard',
                      'outs', 'possorted_genome_bam.bam'),
        barcodes = op.join(config["base"], 'runs', config["run_name"], "{sample}",'cellranger_standard',
                           'outs', 'filtered_feature_bc_matrix', 'barcodes.tsv.gz')
    output:
        rgs = temp(op.join(config["base"], "runs", config["run_name"], "{sample}",
                           'count_repeats_on_cellranger_standard', 'rgs.txt')),
        header = temp(op.join(config["base"], "runs", config["run_name"], "{sample}",
                              'count_repeats_on_cellranger_standard', 'header.txt')),
        body = temp(op.join(config["base"], "runs", config["run_name"], "{sample}",
                            'count_repeats_on_cellranger_standard', 'body.txt.gz')),
        shortened_bam = temp(op.join(config["base"], "runs", config["run_name"], "{sample}",
                                     'count_repeats_on_cellranger_standard', 'shortened.bam')),
        flag = op.join(config["base"], "runs", config["run_name"], "{sample}",
                       'count_repeats_on_cellranger_standard', 'split.flag'),
        path = directory(op.join(config["base"], "runs", config["run_name"], "{sample}",
                                 'count_repeats_on_cellranger_standard', 'split')),
    threads:
        config["params"]["nthreads"]
    params:
        pigz = config['software']['pigz'],
        barcodes_script = 'get_cell_barcodes.py',
        split_script = 'split_by_cell_barcode_in_sorted_bam.py',
        split_path = op.join(config["base"], "runs", config["run_name"], "{sample}",
                             'count_repeats_on_cellranger_standard', 'split')
    log:
        log1 = op.join(config["base"], "runs", config["run_name"], "{sample}",
                       'count_repeats_on_cellranger_standard', 'split_add_rg.log'),
        log2 = op.join(config["base"], "runs", config["run_name"], "{sample}",
                       'count_repeats_on_cellranger_standard', 'split_pick.log'),
    shell:
        """
        mkdir -p {output.path}
        
        # python3 {params.barcodes_script} {input.bam} | {params.pigz} -p {threads} > {output.rgs}

        python3 {params.barcodes_script} {input.bam}  > {output.rgs}

        samtools view -@ {threads} -H {input.bam} > {output.header}

        # ## buffer size in sort due to https://superuser.com/questions/938558/sort-parallel-isnt-parallelizing
        # ( samtools view -@ {threads} {input.bam} | cut -f 1-15 | \
        # paste - {output.rgs} | \
        #   sed 's/\t$//' | sort -S1G --parallel={threads} -k16 | {params.pigz} -p {threads} --keep --stdout > {output.body} ) &> {log.log1}
        ## updated 2 oct to handle SRR8847571
        ( samtools view -@ {threads} {input.bam} | cut -f 1-15 | \
        paste - {output.rgs} | \
          fgrep "RG:Z" | \
          sed 's/\t$//' | sort -S1G --parallel={threads} -k16 | {params.pigz} -p {threads} --keep --stdout > {output.body} ) &> {log.log1}


        {params.pigz} --decompress -p {threads} --keep --stdout {output.body} | cat {output.header} - | samtools view -@ {threads} -Sb - > {output.shortened_bam}
        
        python3 {params.split_script} {output.shortened_bam} -outdir {params.split_path} -barcodes {input.barcodes} &> {log.log2}

        touch {output.flag}

        """

        
rule profile_featurecounts_run_repeats_by_sample:
    input:        
        summary = op.join(config["base"], "runs", config["run_name"], "{sample}", 'count_repeats_on_cellranger_standard',
                          "{multimappers}",
                          config["run_name"] + "_repeats.counts.summary")
    params:
        path = op.join(config["base"], "runs", config["run_name"], "{sample}", "count_repeats_on_cellranger_standard",
                       "{multimappers}"),
        script = config["dependencies"]["featurecounts_parsing"],
        gtf = 'cellranger_repeats',
        Rscript = config['software']['Rscript'],
    output:
        png = op.join(config["base"], "runs", config["run_name"], "{sample}", "count_repeats_on_cellranger_standard",
                      "{multimappers}",
                      config["run_name"] + "_transcriptome_repeats.counts.summary.png")
    threads: 1
    shell:
       """
       cd {params.path}
       
       {params.Rscript} {params.script} --summary {input.summary} --output {output.png} \
           --identifier {params.gtf}
       """

## potentially broken, multimappers wildcard missing
rule profile_featurecounts_run_repeats_not_genes_by_sample:
    input:        
        summary = op.join(config["base"], "runs", config["run_name"], "{sample}",
                          'count_repeats_on_cellranger_standard_not_overlapping_genes',
                          "{multimappers}",
                          config["run_name"] + "_repeats_not_overlapping_genes.counts.summary")
    params:
        path = op.join(config["base"], "runs", config["run_name"], "{sample}",                       
                       "count_repeats_on_cellranger_standard_not_overlapping_genes",
                       "{multimappers}"),
        script = config["dependencies"]["featurecounts_parsing"],
        gtf = 'cellranger_repeats_not_genes',
        Rscript = config['software']['Rscript']
    output:
        png = op.join(config["base"], "runs", config["run_name"], "{sample}",
                      "count_repeats_on_cellranger_standard_not_overlapping_genes",
                      "{multimappers}",
                      config["run_name"] + "_transcriptome_repeats_not_genes.counts.summary.png")
    threads: 1
    shell:
       """
       cd {params.path}
       
       {params.Rscript} {params.script} --summary {input.summary} --output {output.png} \
          --identifier {params.gtf}
       """    

       
rule run_featurecounts_spawned_bams_by_sample:
    input:
        flag = op.join(config["base"], "runs", config["run_name"], "{sample}", 'count_repeats_on_cellranger_standard', 'split.flag'),
        gtf = op.join(config["base"], 'annotation', op.basename(config["rep_gtf_url"]))
    params:
        path = op.join(config["base"], "runs", config["run_name"], "{sample}",
                       'count_repeats_on_cellranger_standard', 'split'),
        featurecounts = config['software']['featurecounts'],
        pigz = config['software']['pigz']
    output:
        counts  = temp(op.join(config["base"], "runs", config["run_name"], "{sample}",
                               'count_repeats_on_cellranger_standard',
                               '{multimappers}',
                               config["run_name"] + "_repeats.counts")),
        gz_counts = op.join(config["base"], "runs", config["run_name"], "{sample}",
                            'count_repeats_on_cellranger_standard',
                            '{multimappers}',
                            config["run_name"] + "_repeats.counts.gz"),
        summary = op.join(config["base"], "runs", config["run_name"], "{sample}",
                          'count_repeats_on_cellranger_standard',
                          '{multimappers}',
                            config["run_name"] + "_repeats.counts.summary")
    log :
        log = op.join(config["base"], "runs",  config["run_name"], "{sample}",
                      'count_repeats_on_cellranger_standard',
                      '{multimappers}',                      
                      'feature_counts.log'),
    threads:
        config["params"]["nthreads"]
    # shell: """
    # cd {params.path}

    # {FEATURECOUNTS} -T {threads} \
    # -t exon \
    # -g gene_id \
    # -a {input.gtf} \
    # -o  {output.counts} \
    # {params.path}/*bam  2>&1 > {log}

    # {PIGZ} --keep -p {threads} {output.counts}
    # """
    run:
        if wildcards.multimappers == 'multimappers':
            shell("""
            echo multimappers allowed

            cd {params.path}

            {params.featurecounts} -T {threads} \
            -t exon \
            -g gene_id \
            -a {input.gtf} \
            -o  {output.counts} \
            -M \
            --fraction \
            {params.path}/*bam  2>&1 > {log}

            {params.pigz} -f --keep -p {threads} {output.counts} -c > {output.gz_counts}

            """)
        elif wildcards.multimappers == 'unique_reads':
            shell("""
            echo unique only

            cd {params.path}

            {params.featurecounts} -T {threads} \
            -t exon \
            -g gene_id \
            -a {input.gtf} \
            -o  {output.counts} \
            {params.path}/*bam  2>&1 > {log}

            {params.pigz} -f --keep -p {threads} {output.counts} -c > {output.gz_counts}
            """)

        
## counts, per sample end
